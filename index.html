<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>던전 법률 퀴즈 RPG</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&family=Cinzel+Decorative:wght@700&display=swap');

        :root {
            --bg-color: #2c2a4a;
            --surface-color: #4f4c7a;
            --primary-color: #9b59b6;
            --secondary-color: #8e44ad;
            --text-color: #ecf0f1;
            --accent-color: #f1c40f;
            --danger-color: #e74c3c;
            --success-color: #2ecc71;
            --challenge-color: #e67e22;
            --font-family: 'Noto Sans KR', sans-serif;
            --title-font: 'Cinzel Decorative', cursive;
        }

        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100dvh;
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--font-family);
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #game-container {
            width: 100%;
            height: 100%;
            max-width: 1000px;
            max-height: 800px;
            position: relative;
            background-color: #1e1c3a;
            border-radius: 15px;
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
            background: linear-gradient(135deg, var(--bg-color), #3e3b6b);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease, visibility 0.5s ease;
            text-align: center;
            overflow-y: auto;
        }

        .screen.active {
            opacity: 1;
            visibility: visible;
        }
        
        #story-screen {
            background: radial-gradient(ellipse at bottom, #1b2735 0%, #090a0f 100%);
            cursor: pointer;
        }
        .story-content {
            background: rgba(0,0,0,0.5);
            padding: 20px 40px;
            border-radius: 15px;
            border: 2px solid var(--accent-color);
            max-width: 80%;
            text-align: center;
        }
        .story-content h2 {
            font-family: var(--title-font);
            color: var(--accent-color);
            margin-bottom: 20px;
        }
        .story-content h3 {
            margin-top: 20px;
            color: var(--text-color);
        }
        .story-content p {
            font-size: 1.1em;
            line-height: 1.6;
            margin-bottom: 15px;
        }
        .skip-message {
            margin-top: 30px;
            font-style: italic;
            font-size: 0.9em;
            color: var(--accent-color);
            animation: pulse 2s infinite;
        }
        @keyframes pulse { 0% { opacity: 0.7; } 50% { opacity: 1; } 100% { opacity: 0.7; } }


        #start-screen {
            background: radial-gradient(ellipse at center, #4a477a 0%, #2c2a4a 70%),
                        repeating-linear-gradient(-45deg, rgba(255,255,255,0.02), rgba(255,255,255,0.02) 2px, transparent 2px, transparent 6px);
        }
        #start-screen .title-container {
            border: 4px double var(--accent-color);
            padding: 20px 40px;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
        }
        #start-screen h1 {
            font-family: var(--title-font);
            font-size: 3em;
            color: var(--accent-color);
            text-shadow: 0 0 5px var(--accent-color), 0 0 15px #000, 0 0 25px #000;
            animation: title-glow 4s infinite alternate;
            margin: 0;
        }
        #start-screen p {
            font-size: 1.1em;
            color: var(--text-color);
            text-shadow: 1px 1px 2px #000;
            margin-top: 10px;
        }

        @keyframes title-glow {
            from { text-shadow: 0 0 5px var(--accent-color), 0 0 15px #000, 0 0 25px #000; }
            to { text-shadow: 0 0 15px var(--accent-color), 0 0 35px #000, 0 0 50px #000; }
        }

        h2, h3 {
            color: var(--accent-color);
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .button-group {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            background-color: var(--primary-color);
            color: var(--text-color);
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px var(--secondary-color);
            transform: translateY(0);
        }

        .btn:hover {
            background-color: #a569bd;
            transform: translateY(-2px);
            box-shadow: 0 6px var(--secondary-color);
        }

        .btn:active {
            transform: translateY(2px);
            box-shadow: 0 2px var(--secondary-color);
        }
        
        .btn.disabled {
            background-color: #7f8c8d;
            cursor: not-allowed;
            box-shadow: 0 4px #616a6b;
            opacity: 0.6;
        }
        
        .btn-small {
            padding: 8px 15px;
            font-size: 0.9em;
        }
        
        .btn-challenge {
           background-color: var(--challenge-color);
           box-shadow: 0 4px #d35400;
        }
        .btn-challenge:hover {
           background-color: #f39c12;
           box-shadow: 0 6px #d35400;
        }


        #character-selection-screen .char-options, #ingame-char-change-modal .char-options {
            display: flex;
            gap: 20px;
            margin: 20px 0;
        }
        .char-card {
            background-color: var(--surface-color);
            padding: 15px;
            border-radius: 10px;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.3s ease;
        }
        .char-card.selected {
            border-color: var(--accent-color);
            transform: scale(1.05);
        }
        .char-card img {
            width: 100px;
            height: 100px;
            object-fit: contain;
        }
        .char-card p {
            margin: 5px 0 0;
            font-weight: bold;
        }
        #character-name {
            padding: 10px;
            font-size: 1em;
            border-radius: 5px;
            border: 2px solid var(--primary-color);
            background-color: var(--bg-color);
            color: var(--text-color);
            margin-top: 15px;
            width: 80%;
            max-width: 300px;
            text-align: center;
        }

        #difficulty-selection-screen #difficulty-char-status {
            background-color: rgba(0,0,0,0.2);
            padding: 10px 20px;
            border-radius: 10px;
            border: 2px solid var(--primary-color);
            margin-bottom: 20px;
        }
        #difficulty-selection-screen #difficulty-char-status h3 {
            margin: 0 0 5px 0;
        }
        #difficulty-selection-screen #difficulty-char-status p {
            margin: 0;
            color: #bdc3c7;
        }

        #difficulty-selection-screen .difficulty-option {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .difficulty-desc {
            font-size: 0.9em;
            color: #bdc3c7;
            margin-top: 8px;
            max-width: 200px;
        }

        #game-screen {
            justify-content: flex-start;
            padding: 0;
            overflow: hidden;
        }
        #status-bar {
            width: 100%;
            padding: 10px 20px;
            background-color: rgba(0,0,0,0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-sizing: border-box;
            font-size: 1.1em;
            z-index: 10;
            flex-wrap: wrap;
            gap: 10px;
            position: relative;
        }
        #status-bar > div {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        #progress-display {
            font-size: 0.9em;
            color: #bdc3c7;
            text-align: center;
            width: 100%;
            order: 2;
        }
        @media (min-width: 768px) {
            #progress-display {
                width: auto;
                order: 0;
            }
        }

        #game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        #quiz-container {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: rgba(44, 42, 74, 0.95);
            padding: 15px;
            box-sizing: border-box;
            border-top: 3px solid var(--primary-color);
            z-index: 10;
            display: none;
            flex-direction: column;
            gap: 10px;
            max-height: 60%;
        }
        #quiz-case {
            flex-shrink: 1;
            min-height: 0;
            overflow-y: auto;
            overscroll-behavior: contain;
            padding: 15px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            font-size: 1.1em;
            line-height: 1.6;
            text-align: left;
            width: 100%;
            box-sizing: border-box;
            -webkit-overflow-scrolling: touch;
        }
        #q1-options {
            flex-shrink: 0;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        #q2-options {
            flex-grow: 1;
            min-height: 0;
            overflow-y: auto;
            overscroll-behavior: contain;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-right: 10px;
            box-sizing: border-box;
            -webkit-overflow-scrolling: touch;
        }

        .quiz-btn {
            width: 45%;
            max-width: 300px;
            padding: 12px;
            font-size: 1em;
        }
        .q2-btn {
            width: 98%;
            max-width: 620px;
            text-align: left;
            font-size: 0.9em;
            padding: 10px;
            flex-shrink: 0;
            margin-bottom: 5px;
        }
        
        .modal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.6);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 99;
            padding: 15px;
            box-sizing: border-box;
        }
        .modal-content {
            background-color: var(--surface-color);
            padding: 30px;
            border-radius: 15px;
            border: 3px solid var(--accent-color);
            box-shadow: 0 0 20px rgba(0,0,0,0.7);
            text-align: center;
            max-width: 90%;
            max-height: 90%;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            overscroll-behavior: contain;
        }
        #message-text {
            font-size: 1.2em;
            line-height: 1.7;
            margin-bottom: 20px;
            text-align: left;
        }
        #message-text b {
            color: var(--accent-color);
        }
        #message-text .capture-guide {
           font-size: 0.9em;
           margin-top: 20px;
           padding-top: 15px;
           border-top: 1px solid var(--primary-color);
        }
        #message-text .capture-guide h4 {
           color: var(--accent-color);
           margin-bottom: 10px;
        }
        #message-text .capture-guide ul {
           list-style: none;
           padding: 0;
        }
        #message-text .capture-guide li {
           margin-bottom: 8px;
        }

        #instructions-modal .modal-content {
            text-align: left;
        }
        #instructions-modal h3 {
            margin-top: 0;
        }
        #instructions-modal ul {
            padding-left: 20px;
        }
        #instructions-modal li {
            margin-bottom: 10px;
        }
        
        #monster-info-display {
            position: absolute;
            top: 70px;
            right: 20px;
            background-color: rgba(0,0,0,0.6);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 1.1em;
            text-align: right;
            z-index: 10;
            display: none;
            border-left: 3px solid var(--danger-color);
        }
        
        #temp-message-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px 40px;
            background-color: rgba(0,0,0,0.75);
            color: var(--accent-color);
            font-size: 2em;
            font-weight: bold;
            border-radius: 10px;
            z-index: 110;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        #temp-message-overlay.visible {
            opacity: 1;
            visibility: visible;
        }
        
        #fixed-buttons-container {
            position: absolute;
            bottom: 15px;
            right: 15px;
            z-index: 120;
        }

        /* Responsive Design */
        @media (max-width: 600px) {
            #start-screen h1 { font-size: 2.2em; }
            .btn { padding: 10px 20px; font-size: 1em; }
            #character-selection-screen .char-options, #ingame-char-change-modal .char-options { flex-direction: column; align-items: center; }
            .char-card img { width: 80px; height: 80px; }
            #status-bar { font-size: 0.9em; padding: 8px 15px; }
            #monster-info-display { top: 70px; font-size: 0.9em; }
            #quiz-container { max-height: 55%; padding: 10px; }
            #quiz-case { font-size: 0.95em; padding: 10px; }
            .quiz-btn { width: 90%; }
            .q2-btn { font-size: 0.85em; }
            #temp-message-overlay { font-size: 1.5em; }
            .story-content p { font-size: 1em; }
        }

        @media (max-height: 600px) {
             #quiz-container {
                 max-height: 70%;
             }
             #quiz-case {
                 font-size: 0.9em;
             }
             .q2-btn {
                 font-size: 0.8em;
                 padding: 8px;
             }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- 스토리 화면 -->
        <div id="story-screen" class="screen">
            <div class="story-content">
                <h2>🕯️ 지식의 서를 찾아서 🕯️</h2>
                <p>옛 전설에 따르면, 이 세상 모든 법과 지혜가 담긴 ‘지식의 서’는 어둠의 던전에 숨겨져 있다고 한다. 그 서를 지키는 건 형법의 수수께끼를 품은 몬스터들.</p>
                <p>그들은 정의와 논리의 검이 아니면 결코 쓰러뜨릴 수 없다!</p>
                <p>지금 당신은 법의 수호자로 선택받았다. 각 던전의 퀴즈를 풀고, 형법의 지식을 무기로 몬스터를 물리쳐라.</p>
                <p>던전마다 기다리는 강력한 시험을 통과하면, 한 걸음씩 지식의 서에 가까워질 것이다.</p>
                <h3>⚔️ 지금, 정의로운 여정을 시작하라! ⚖️</h3>
                <p class="skip-message">(화면을 클릭하여 계속하기)</p>
            </div>
        </div>

        <!-- 시작 화면 -->
        <div id="start-screen" class="screen">
            <div class="title-container">
                <h1>Dungeon & Law</h1>
                <p>범죄의 성립 여부를 퀴즈로 배우는 던전 탐험!</p>
            </div>
            <div class="button-group">
                <button id="start-new-game-btn" class="btn">새 게임 시작</button>
                <button id="load-game-btn" class="btn">불러오기</button>
            </div>
        </div>

        <!-- 캐릭터 선택 화면 -->
        <div id="character-selection-screen" class="screen">
            <h2>캐릭터 선택</h2>
            <p>이름을 정하고, 당신의 분신이 될 용사를 선택하세요.</p>
            <input type="text" id="character-name" placeholder="캐릭터 이름 입력" maxlength="10">
            <div class="char-options">
                <div class="char-card" data-class="전사" data-gender="남">
                    <img src="https://raw.githubusercontent.com/dessa1995/crime/main/mw.png" alt="남자 전사" onerror="this.src='https://placehold.co/100x100/4f4c7a/ecf0f1?text=Warrior'">
                    <p>남자 전사</p>
                </div>
                <div class="char-card" data-class="전사" data-gender="여">
                    <img src="https://raw.githubusercontent.com/dessa1995/crime/main/fw.png" alt="여자 전사" onerror="this.src='https://placehold.co/100x100/4f4c7a/ecf0f1?text=Warrior'">
                    <p>여자 전사</p>
                </div>
                <div class="char-card" data-class="마법사" data-gender="남">
                    <img src="https://raw.githubusercontent.com/dessa1995/crime/main/mm.png" alt="남자 마법사" onerror="this.src='https://placehold.co/100x100/4f4c7a/ecf0f1?text=Mage'">
                    <p>남자 마법사</p>
                </div>
                <div class="char-card" data-class="마법사" data-gender="여">
                    <img src="https://raw.githubusercontent.com/dessa1995/crime/main/fm.png" alt="여자 마법사" onerror="this.src='https://placehold.co/100x100/4f4c7a/ecf0f1?text=Mage'">
                    <p>여자 마법사</p>
                </div>
            </div>
            <button id="confirm-character-btn" class="btn">선택 완료</button>
        </div>
        
        <!-- 난이도 선택 화면 -->
        <div id="difficulty-selection-screen" class="screen">
            <div id="difficulty-char-status"></div>
            <h2>난이도 선택</h2>
            <div class="button-group" id="difficulty-options">
                <div class="difficulty-option">
                    <button class="btn difficulty-btn" data-difficulty="하">하</button>
                    <p class="difficulty-desc">5문제 정답 시 보스 등장</p>
                </div>
                <div class="difficulty-option">
                    <button class="btn difficulty-btn" data-difficulty="중">중</button>
                    <p class="difficulty-desc">8문제 정답 시 보스 등장</p>
                </div>
                <div class="difficulty-option">
                    <button class="btn difficulty-btn" data-difficulty="상">상</button>
                    <p class="difficulty-desc">10문제 정답 시 보스 등장</p>
                </div>
            </div>
             <div class="button-group">
                  <button id="save-game-btn" class="btn">게임 저장</button>
                  <button id="change-character-btn" class="btn">캐릭터 변경</button>
             </div>
        </div>

        <!-- 메인 게임 화면 -->
        <div id="game-screen" class="screen">
            <div id="status-bar">
                <div id="player-info-left">
                    <span id="status-name"></span> | LV.<span id="status-level"></span>
                </div>
                <div id="progress-display"></div>
                <div id="player-info-right">
                    <span>목숨:</span>
                    <span id="status-lives"></span>
                    <button id="ingame-change-char-btn" class="btn btn-small">캐릭터 변경</button>
                    <button id="back-to-difficulty-btn" class="btn btn-small">메인으로</button>
                </div>
            </div>
            <div id="monster-info-display"></div>
            <div id="temp-message-overlay"></div>
            <canvas id="game-canvas"></canvas>
            <div id="quiz-container">
                <div id="quiz-case"></div>
                <div id="q1-options">
                    <button class="btn quiz-btn" data-answer="O">O (맞다)</button>
                    <button class="btn quiz-btn" data-answer="X">X (틀리다)</button>
                </div>
                <div id="q2-options" style="display: none;"></div>
            </div>
        </div>
        
        <!-- 메시지 모달 -->
        <div id="message-modal" class="modal-overlay">
            <div class="modal-content">
                <p id="message-text"></p>
                <button id="message-ok-btn" class="btn">확인</button>
            </div>
        </div>
        
        <!-- 게임 설명 모달 -->
        <div id="instructions-modal" class="modal-overlay">
            <div class="modal-content">
                <h3>게임 설명</h3>
                <ul>
                    <li><strong>목표:</strong> 형법 퀴즈를 풀어 몬스터를 물리치고 던전을 클리어하세요!</li>
                    <li><strong>게임 흐름:</strong>
                        <ol>
                            <li>캐릭터 생성 후, 원하는 난이도를 선택하여 게임을 시작합니다.</li>
                            <li>몬스터가 등장하면 퀴즈가 출제됩니다.</li>
                            <li>퀴즈를 맞혀야 몬스터에게 데미지를 줄 수 있습니다.</li>
                            <li>틀리면 목숨이 1개 줄어듭니다. 목숨이 0이 되면 게임 오버!</li>
                            <li>난이도별 정답 수를 채우면 강력한 보스가 등장합니다.</li>
                        </ol>
                    </li>
                    <li><strong>레벨업:</strong> 각 난이도의 보스를 물리칠 때마다 레벨이 오르며, 공격 이펙트가 화려해집니다.</li>
                    <li><strong>도전자 모드:</strong> 모든 난이도를 클리어하면 '도전자' 모드가 해금됩니다. 이 모드에서는 3개의 목숨으로 최대한 높은 점수를 기록하는 것에 도전합니다!</li>
                    <li><strong>저장/불러오기:</strong> '게임 저장' 또는 '메인으로' 버튼으로 현재 레벨과 클리어 정보를 저장할 수 있습니다. 메인 화면의 '불러오기'로 이어할 수 있습니다.</li>
                </ul>
                <button id="instructions-close-btn" class="btn">닫기</button>
            </div>
        </div>

        <!-- 인게임 캐릭터 변경 모달 -->
        <div id="ingame-char-change-modal" class="modal-overlay">
            <div class="modal-content">
                <h3>캐릭터 변경</h3>
                <p>원하는 직업과 성별을 선택하세요.</p>
                <div class="char-options">
                     <div class="char-card" data-class="전사" data-gender="남">
                        <img src="https://raw.githubusercontent.com/dessa1995/crime/main/mw.png" alt="남자 전사" onerror="this.src='https://placehold.co/100x100/4f4c7a/ecf0f1?text=Warrior'">
                        <p>남자 전사</p>
                    </div>
                    <div class="char-card" data-class="전사" data-gender="여">
                        <img src="https://raw.githubusercontent.com/dessa1995/crime/main/fw.png" alt="여자 전사" onerror="this.src='https://placehold.co/100x100/4f4c7a/ecf0f1?text=Warrior'">
                        <p>여자 전사</p>
                    </div>
                    <div class="char-card" data-class="마법사" data-gender="남">
                        <img src="https://raw.githubusercontent.com/dessa1995/crime/main/mm.png" alt="남자 마법사" onerror="this.src='https://placehold.co/100x100/4f4c7a/ecf0f1?text=Mage'">
                        <p>남자 마법사</p>
                    </div>
                    <div class="char-card" data-class="마법사" data-gender="여">
                        <img src="https://raw.githubusercontent.com/dessa1995/crime/main/fm.png" alt="여자 마법사" onerror="this.src='https://placehold.co/100x100/4f4c7a/ecf0f1?text=Mage'">
                        <p>여자 마법사</p>
                    </div>
                </div>
                <div class="button-group">
                    <button id="confirm-ingame-char-change-btn" class="btn">변경 완료</button>
                    <button id="cancel-ingame-char-change-btn" class="btn">취소</button>
                </div>
            </div>
        </div>

        <div id="fixed-buttons-container">
            <button id="instructions-btn" class="btn btn-small">게임 설명</button>
        </div>

        <audio id="bgm-audio" src="https://raw.githubusercontent.com/dessa1995/crime/main/bbgm.mp3" loop></audio>

    </div>

    <script>
        // 전역 변수 및 DOM 요소
        const gameContainer = document.getElementById('game-container');
        const screens = document.querySelectorAll('.screen');
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        
        const quizContainer = document.getElementById('quiz-container');
        const quizCaseEl = document.getElementById('quiz-case');
        const q1OptionsEl = document.getElementById('q1-options');
        const q2OptionsEl = document.getElementById('q2-options');

        const messageModal = document.getElementById('message-modal');
        const messageText = document.getElementById('message-text');
        let messageOkBtn = document.getElementById('message-ok-btn');
        const monsterInfoDisplay = document.getElementById('monster-info-display');
        const tempMessageOverlay = document.getElementById('temp-message-overlay');
        const bgmAudioElement = document.getElementById('bgm-audio');
        const progressDisplay = document.getElementById('progress-display');

        const assets = {
            monsters: {
                '하': 'https://raw.githubusercontent.com/dessa1995/crime/main/monster1.png',
                '중': 'https://raw.githubusercontent.com/dessa1995/crime/main/monster2.png',
                '상': 'https://raw.githubusercontent.com/dessa1995/crime/main/monster3.png',
                '보스': 'https://raw.githubusercontent.com/dessa1995/crime/main/monster4.png'
            },
            characters: {
                '전사_남': 'https://raw.githubusercontent.com/dessa1995/crime/main/mw.png',
                '전사_여': 'https://raw.githubusercontent.com/dessa1995/crime/main/fw.png',
                '마법사_남': 'https://raw.githubusercontent.com/dessa1995/crime/main/mm.png',
                '마법사_여': 'https://raw.githubusercontent.com/dessa1995/crime/main/fm.png'
            },
            misc: {
               'book': 'https://raw.githubusercontent.com/dessa1995/crime/main/book.png'
            }
        };
        const loadedImages = {};

        let gameState = {};
        let dungeonPillars = [];
        let effectParticles = [];
        let gameOverDebris = [];

        // 퀴즈 데이터
        const quizzes = [
            { id: 101, type: 'one-step-ox', difficulty: '하', case: "형법은 범죄와 그에 대한 법적 효과로서 형벌과 보안 처분을 규정한 모든 법 규범을 의미한다.", q1: 'O', explanation: "형법은 넓은 의미에서 범죄와 그에 대한 법적 효과로서 형벌과 보안 처분을 규정한 모든 법 규범의 총체를 의미한다." },
            { id: 102, type: 'one-step-ox', difficulty: '하', case: "실질적 의미의 형법은 ‘형법’이라는 명칭이 붙여진 법률만을 의미한다.", q1: 'X', explanation: "단순히 '형법'이라는 이름의 법률을 지칭하는 것은 형식적 의미의 형법이다." },
            { id: 103, type: 'one-step-ox', difficulty: '하', case: "형법의 보장적 기능은 국가 형벌권의 자의적 행사로부터 국민의 자유와 권리를 보장한다.", q1: 'O', explanation: "형법은 형법에 규정되지 아니한 행위는 범죄가 되지 않고 처벌받지 않도록 보장하며, 규정된 형벌의 종류와 양을 넘어서서 처벌받지 않도록 함으로써 국가 형벌권으로부터 국민의 자유와 권리를 보장하는 보장적 기능을 수행한다." },
            { id: 104, type: 'one-step-ox', difficulty: '하', case: "「도로교통법」에 규정된 벌칙 조항은 실질적 의미의 형법에 해당하지 않는다.", q1: 'X', explanation: "「도로교통법」과 같이 법의 명칭이나 형식을 불문하고 범죄와 그에 대한 법적 효과로서 형벌과 보안 처분을 규정한 모든 법 규범은 실질적 의미의 형법에 해당한다." },
            { id: 105, type: 'one-step-ox', difficulty: '하', case: "죄형 법정주의는 미리 성문의 법률에 규정되어 있지 않은 행위에 대해서도 처벌을 가능하게 하는 원칙이다.", q1: 'X', explanation: "죄형 법정주의는 어떠한 행위가 범죄이고 그 범죄를 어떻게 처벌할 것인지 미리 성문의 법률로 규정되어야 한다는 원칙이다." },
            { id: 106, type: 'one-step-ox', difficulty: '하', case: "관습 형법 금지의 원칙에 따라 불문법인 관습법을 근거로 처벌할 수 없다.", q1: 'O', explanation: "관습 형법 금지의 원칙은 의회에서 제정한 성문법이 아닌 불문법인 관습법을 근거로는 처벌할 수 없다는 원칙이다." },
            { id: 107, type: 'one-step-ox', difficulty: '하', case: "소급효 금지의 원칙은 행위자에게 불리한 소급효만 허용하지 않고, 행위자에게 유리한 소급효는 허용한다.", q1: 'O', explanation: "소급효 금지의 원칙은 범죄와 형벌이 행위 당시 법률에 규정되어 있어야 하며, 행위 이후에 제정한 법률로는 소급하여 처벌할 수 없다는 것을 의미하지만, 행위자에게 유리한 소급효는 예외적으로 허용된다." },
            { id: 108, type: 'one-step-ox', difficulty: '하', case: "명확성의 원칙은 범죄의 구성 요건과 형벌이 불명확하게 규정되어도 무방하다고 본다.", q1: 'X', explanation: "명확성의 원칙은 법률이 처벌하고자 하는 행위가 무엇이며 그에 대해 어떤 형벌이 부과되는지를 누구나 예견할 수 있도록 범죄의 구성 요건과 형벌을 명확하게 규정하여야 한다는 원칙이다." },
            { id: 109, type: 'one-step-ox', difficulty: '하', case: "유추 해석 금지의 원칙은 법률에 규정이 없는 사항에 대해 유사한 성질의 법률을 적용하여 행위자에게 불리한 새로운 구성 요건을 만들 수 없다는 원칙이다.", q1: 'O', explanation: "유추 해석 금지의 원칙은 범죄 행위가 형법에 명확히 규정되어 있지 않은 때에 유사한 규정을 적용해서는 행위자에게 불리하게 적용해서는 안 된다는 원칙이다." },
            { id: 110, type: 'one-step-ox', difficulty: '하', case: "적정성의 원칙은 범죄가 되는 행위와 그에 따른 형벌의 질과 양이 비례해야 한다는 원칙이다.", q1: 'O', explanation: "적정성의 원칙은 범죄가 되는 행위와 그에 따른 형벌의 질과 양이 비례하여야 한다는 원칙으로, 비례성의 원칙 또는 과잉 금지의 원칙이라고도 한다." },
            { id: 111, type: 'one-step-ox', difficulty: '하', case: "범죄의 3단계 성립 요건은 구성 요건 해당성, 위법성, 책임이다.", q1: 'O', explanation: "범죄가 성립하기 위해서는 구성 요건 해당성, 위법성, 책임이라는 세 가지 요건이 충족되어야 한다." },
            { id: 112, type: 'one-step-ox', difficulty: '하', case: "위법성 조각 사유는 구성 요건에 해당하는 행위의 위법성을 배제하는 특별한 사유이다.", q1: 'O', explanation: "위법성 조각 사유는 구성 요건에 해당하는 행위의 위법성을 배제하는 특별한 사유이다." },
            { id: 113, type: 'one-step-ox', difficulty: '하', case: "자구행위는 현재의 부당한 법익 침해로부터 자신이나 타인의 법익을 방위하기 위한 상당한 이유가 있는 행위이다.", q1: 'X', explanation: "자기 또는 타인의 법익에 대한 현재의 부당한 침해를 방위하기 위한 상당한 이유가 있는 행위는 정당방위다." },
            { id: 114, type: 'one-step-ox', difficulty: '하', case: "긴급 피난은 자기 또는 타인의 법익에 대한 현재의 위난을 피하기 위한 행위로 상당한 이유가 있는 경우에 해당한다.", q1: 'O', explanation: "긴급 피난은 자기 또는 타인의 법익에 대한 현재의 위난을 피하기 위한 행위로 상당한 이유가 있는 경우이다." },
            { id: 115, type: 'one-step-ox', difficulty: '하', case: "14세 미만인 사람의 행위는 위법성 조각 사유에 해당한다.", q1: 'X', explanation: "14세 미만인 사람의 행위는 책임 조각 사유에 해당하여 범죄가 성립하지 않는다." },
            { id: 116, type: 'one-step-ox', difficulty: '하', case: "형벌은 국가가 범죄 행위를 저지른 사람에게 가하는 법익 박탈로서의 제재이다.", q1: 'O', explanation: "형벌은 국가가 범죄 행위를 저지른 사람에게 가하는 제재로, 법익의 박탈을 내용으로 한다." },
            { id: 117, type: 'one-step-ox', difficulty: '하', case: "사형은 생명을 빼앗는 형벌에 해당한다.", q1: 'O', explanation: "사형은 생명을 빼앗는 생명형에 해당한다." },
            { id: 118, type: 'one-step-ox', difficulty: '하', case: "보호 관찰은 교정 시설에 수용하지 않고 사회생활을 허용하면서 보호 관찰관의 지도·감독을 받는 보안 처분이다.", q1: 'O', explanation: "보호 관찰은 형의 집행 유예나 선고 유예를 받거나 가석방되는 경우 등을 대상으로 교정 시설에 수용하지 않고 사회생활을 허용하면서 보호 관찰관의 지도·감독을 통해 사회 복귀를 촉진하는 제도이다." },
            { id: 119, type: 'one-step-ox', difficulty: '하', case: "형사 절차에서 피의자와 피고인은 자신에게 불리한 진술을 거부할 수 있는 진술 거부권을 가진다.", q1: 'O', explanation: "모든 형사 절차에서 피의자와 피고인은 자신에게 불리한 진술을 거부할 수 있는 진술 거부권을 가진다." },
            { id: 120, type: 'one-step-ox', difficulty: '하', case: "재심 제도는 하급법원의 재판 결과에 불복하여 재판 당사자가 상급 법원에 다시 재판할 것을 청구하는 제도이다.", q1: 'X', explanation: "재심 제도는 유죄의 확정 판결에 중대한 사실 오인이 있는 경우 그 오류를 시정하여 무고한 자의 이익을 구제하여 주는 제도이다." },
            { id: 201, type: 'single', difficulty: '중', case: "다음 중 형법의 보충성 원칙을 가장 잘 설명하는 것은?", q2: ["형법은 사회 윤리적 행위 가치를 보호하는 기능을 한다.", "형법은 국가 형벌권 남용으로부터 국민의 자유와 권리를 보장한다.", "법익을 보호하기 위해 다른 수단이 있다면 그것을 먼저 행사하고 형법은 가장 마지막 수단으로 발동되어야 한다.", "형법은 범죄 행위로 인해 얻는 이익과 형벌이라는 불이익을 통해 국민이 자신의 행위를 결정하게 하는 역할을 한다."], answerIndex: 2, explanation: "형법의 보충성 또는 최후 수단성은 형벌이 국가의 가장 강력한 물리력 행사로서, 그러한 법익을 보호하기 위한 다른 수단이 있다면 그것을 먼저 행사하고 형법은 가장 마지막 수단으로 발동되어야 함을 의미한다." },
            { id: 202, type: 'single', difficulty: '중', case: "다음 중 죄형 법정주의의 파생 원칙인 소급효 금지의 원칙에 대한 설명으로 옳지 않은 것은?", q2: ["범죄와 형벌은 행위 당시 법률에 규정되어 있어야 한다.", "행위 이후에 제정된 법률로는 소급하여 처벌할 수 없다.", "행위자에게 불리한 경우에도 소급효가 허용된다.", "재판 시의 법이 행위 시의 법보다 경할 때에는 재판 시의 법을 적용한다."], answerIndex: 2, explanation: "소급효 금지의 원칙은 행위자에게 불리한 소급효를 금지하는 것이 원칙이다. 다만, 행위자에게 유리한 소급효는 예외적으로 허용된다. 따라서 행위자에게 불리한 경우에도 소급효가 허용된다는 설명은 옳지 않다." },
            { id: 203, type: 'single', difficulty: '중', case: "다음 중 유추 해석 금지의 원칙에 위배되는 사례는?", q2: ["법에 규정된 '상해'에 '정신적 고통'을 포함하여 해석하더라도 행위자에게 불리하지 않은 경우", "형법에 명시된 '절도'에 '컴퓨터를 이용한 정보 탈취'를 포함하는 새로운 범죄 유형을 법률로 명확히 규정한 경우", "명확하지 않은 조항을 입법 취지에 맞게 합리적으로 해석하여 적용한 경우", "범죄 행위가 유사하지만 형법에 명확히 규정되어 있지 않은 때에 유사한 규정을 적용하여 행위자에게 불리하게 형을 가중한 경우"], answerIndex: 3, explanation: "유추 해석 금지의 원칙은 법률에 규정이 없는 사항에 대해 유사한 성질의 법률을 적용하여 행위자에게 불리한 새로운 구성 요건을 만들거나 형을 가중할 수 없다는 원칙이다. ①과 ③은 허용될 수 있는 법 해석이며, ②는 새로운 법률 제정의 문제이다." },
            { id: 204, type: 'single', difficulty: '중', case: "다음 중 범죄의 3단계 성립 요건에 해당하지 않는 것은?", q2: ["구성 요건 해당성", "위법성", "책임", "도덕적 비난 가능성"], answerIndex: 3, explanation: "범죄의 3단계 성립 요건은 구성 요건 해당성, 위법성, 책임이다. 도덕적 비난 가능성은 범죄의 성립 요건에 직접 해당하지 않는다." },
            { id: 205, type: 'single', difficulty: '중', case: "甲은 자신의 집 마당에서 삽으로 땅을 파던 중 실수로 이웃집의 수도관을 파손시켰다. 이 경우 甲의 행위에 대한 형법상 처벌 가능성은? (단, 甲에게 고의는 없었으며, 과실에 의한 수도관 파손에 대한 특별한 처벌 규정은 없다고 가정한다.)", q2: ["甲은 재물 손괴죄로 처벌받는다.", "甲은 과실에 의한 재물 손괴죄로 처벌받는다.", "甲은 형법상 재물 손괴죄의 구성 요건에 해당하지 않아 처벌받지 않는다.", "甲은 민사상 손해 배상 책임도 지고 형사 처벌도 받게 된다."], answerIndex: 2, explanation: "형법은 고의범을 처벌하는 것을 원칙으로 하며, 예외적으로 과실범을 처벌하는 규정이 있는 경우에만 처벌한다. 과실에 의한 재물 손괴에 대한 처벌 규정이 없다면, 甲에게 고의가 없으므로 형법상 구성 요건에 해당하지 않아 처벌받지 않는다. (참고: 민사상 손해배상 책임은 별개로 발생할 수 있으나, 이 문제는 형법상 처벌 가능성을 묻고 있다.)" },
            { id: 206, type: 'single', difficulty: '중', case: "다음 중 위법성 조각 사유에 해당하지 않는 것은?", q2: ["정당방위", "긴급 피난", "강요된 행위", "자구 행위"], answerIndex: 2, explanation: "강요된 행위는 책임 조각 사유에 해당한다. 정당방위, 긴급 피난, 자구 행위는 위법성 조각 사유에 해당한다." },
            { id: 207, type: 'single', difficulty: '중', case: "형벌의 종류 중 신체의 자유를 빼앗는 자유형에 해당하지 않는 것은?", q2: ["징역", "금고", "구류", "자격 상실"], answerIndex: 3, explanation: "징역, 금고, 구류는 신체의 자유를 빼앗는 자유형에 해당한다. 자격 상실은 명예형에 해당한다." },
            { id: 208, type: 'single', difficulty: '중', case: "다음 중 보안 처분의 특징으로 옳지 않은 것은?", q2: ["범죄자의 재사회화를 위한 대안적 제재 수단이다.", "과거의 불법에 대한 책임을 전제로 한다.", "장래의 위험성으로부터 행위자를 보호하고 사회를 방위하기 위한 예방적 조치이다.", "부과 요건이나 절차 등에 있어서 적법 절차의 원리가 준수되어야 한다."], answerIndex: 1, explanation: "보안 처분은 과거의 불법에 대한 책임을 전제로 하는 형벌과 달리, 장래의 위험성으로부터 행위자를 보호하고 사회를 방위하기 위한 합목적적인 예방적 조치이다." },
            { id: 209, type: 'single', difficulty: '중', case: "형사 절차의 진행 순서로 가장 적절한 것은?", q2: ["공판 절차 → 수사 절차 → 형 집행 절차", "수사 절차 → 공판 절차 → 형 집행 절차", "형 집행 절차 → 수사 절차 → 공판 절차", "수사 절차 → 형 집행 절차 → 공판 절차"], answerIndex: 1, explanation: "형사 절차는 범죄가 발생하였을 때 이를 수사·심판하고 선고된 형을 집행하는 과정으로, 수사 절차 → 공판 절차 → 형 집행 절차의 순서로 진행된다." },
            { id: 210, type: 'single', difficulty: '중', case: "검사의 불기소 처분 중 피의 사실은 인정되나 피의자의 연령이나 지능, 피해자와의 관계, 범행의 동기나 수단, 범행의 결과 등을 참작하여 소추할 필요가 없는 경우는?", q2: ["기소 유예", "혐의 없음", "죄가 안 됨", "공소권 없음"], answerIndex: 0, explanation: "기소 유예는 피의 사실이 인정되나 피의자의 제반 사정을 참작하여 소추할 필요가 없는 경우 검사가 공소를 제기하지 않는 불기소 처분이다." },
            { id: 211, type: 'single', difficulty: '중', case: "법원이 피고인의 유죄를 인정하면서도 정상을 참작하여 형의 선고를 미루는 것으로, 유예된 날로부터 일정 기간을 경과하면 형의 선고가 없었던 것으로 간주되는 것은?", q2: ["실형", "집행 유예", "선고 유예", "가석방"], answerIndex: 2, explanation: "선고 유예는 형의 선고 자체를 미루었다가 2년이 지나면 형의 선고가 없었던 것으로 간주하는 제도이다." },
            { id: 212, type: 'single', difficulty: '중', case: "우리나라의 국민 참여 재판에 대한 설명으로 옳은 것은?", q2: ["배심원의 평결은 법원을 기속한다.", "모든 형사 재판에 의무적으로 적용된다.", "배심원은 직업 법관과 동등한 권한으로 사실 문제 및 법률 문제를 판단한다.", "배심원은 양형에 관한 의견을 밝힐 수 있으나, 양형 결정에 직접 참여하여 표결하는 것은 아니다."], answerIndex: 3, explanation: "우리나라 국민 참여 재판에서 배심원의 평결은 법원을 기속하지 않고 권고적 효력만을 가지며, 양형에 관하여 의견을 밝힐 수 있으나 표결을 통해 양형 결정에 참여하는 것은 아니다." },
            { id: 213, type: 'single', difficulty: '중', case: "형사 절차상 인권 보장을 위한 원칙 중 '유죄 판결이 확정될 때까지 무죄로 추정한다'는 원칙은?", q2: ["적법 절차의 원칙", "진술 거부권", "변호인의 조력을 받을 권리", "무죄 추정의 원칙"], answerIndex: 3, explanation: "유죄 판결이 확정될 때까지 피의자나 피고인을 무죄로 추정하는 원칙은 무죄 추정의 원칙이다." },
            { id: 214, type: 'single', difficulty: '중', case: "위법 수집 증거 배제 법칙의 내용으로 옳은 것은?", q2: ["고문, 폭행 등으로 임의로 진술한 것이 아니라고 의심되는 자백은 증거 능력이 없다.", "자백이 불이익한 유일한 증거인 때에는 유죄의 증거로 할 수 없다.", "위법한 절차에 의하여 수집된 증거는 증거 능력이 없다.", "경험한 사실을 경험자가 직접 구두로 법원에 보고하지 않은 간접 증거는 원칙적으로 증거 능력이 없다."], answerIndex: 2, explanation: "위법 수집 증거 배제 법칙은 위법한 절차에 의해 수집된 증거는 증거 능력이 없다는 원칙이다. ①은 자백 배제 법칙, ②는 자백 보강 법칙, ④는 전문 법칙에 해당한다." },
            { id: 215, type: 'single', difficulty: '중', case: "범죄 피해자가 가해자에게 신속하고 간편하게 손해 배상을 받을 수 있도록 하는 제도는?", q2: ["범죄 피해자 구조 제도", "배상 명령 제도", "형사 보상 제도", "명예 회복 제도"], answerIndex: 1, explanation: "배상 명령 제도는 범죄 피해자가 가해자에게 신속하고 간편하게 손해 배상을 받을 수 있도록 하는 제도이다." },
            { id: 301, type: 'two-step', difficulty: '상', case: "형법의 규범적 기능은 국민에게 행위의 준칙으로 삼도록 하고, 법관에게는 범죄 성립 여부를 판단하는 평가 규범으로서의 역할을 한다.", q1: 'O', q2_question: "다음은 어떤 사람이 법정에서 '범죄인 줄 몰랐다'고 주장했으나 처벌받은 사례입니다. 이 사례를 통해 알 수 있는 형법의 기능으로 가장 적절한 것은?", q2: ["보호적 기능", "보장적 기능", "규범적 기능", "보충적 기능"], answerIndex: 2, explanation: "국민이 준수해야 할 행위 준칙을 제시하고, 법관에게는 판단 기준을 제공하는 규범적 기능에 해당한다." },
            { id: 302, type: 'two-step', difficulty: '상', case: "형법 제243조는 '음란한 문서, 도화, 필름, 그 밖의 물건을 공공연하게 전시한 자'를 처벌하도록 규정하고 있으나, '음란'의 개념이 명확히 정의되어 있지 않다. 이에 따라 A가 성인용 만화를 출판한 사건에서, 법원은 해당 만화가 예술성과 표현의 자유를 고려할 때 명백한 음란물로 단정하기 어렵고, '음란'이라는 용어 자체가 불명확하다는 이유로 무죄를 선고하였다. 법원의 판단은 죄형법정주의 원칙에 어긋나는가?", q1: 'X', q2_question: "이 사례에서 법원의 판단 근거가 된 죄형 법정주의의 원칙은 무엇입니까?", q2: ["관습 형법 금지의 원칙", "소급효 금지의 원칙", "명확성의 원칙", "유추 해석 금지의 원칙"], answerIndex: 2, explanation: "'음란'이라는 용어가 모호하여 법 적용이 어려웠던 사례로, 죄형 법정주의의 명확성 원칙을 보여준다." },
            { id: 303, type: 'two-step', difficulty: '상', case: "범죄가 성립하려면 고의가 요구되며, 과실에 의한 행위는 특별한 규정이 있는 경우에만 처벌된다. 따라서 과실에 의한 행위는 어떤 경우에도 형법상 범죄가 성립하지 않는다.", q1: 'X', q2_question: "다음 중 과실범 처벌 규정이 없을 경우 범죄로 성립하지 않는 사례는?", q2: ["타인의 물건을 훔치려 했으나 자기 물건인 줄 알고 가져온 경우", "실수로 타인의 물건을 파손했으나 과실범 처벌 규정이 없는 경우", "법률상 금지된 행위임을 알면서 저지른 경우", "금전적 이득을 목적으로 타인을 속여 재산을 편취한 경우"], answerIndex: 1, explanation: "과실에 의한 행위라도 법에 명시된 처벌 규정이 있어야만 범죄로 성립한다." },
            { id: 304, type: 'two-step', difficulty: '상', case: "피해자의 승낙이 있다고 하여 모든 경우에 위법성이 조각되는 것은 아니다. 따라서 피해자의 승낙이 있는 경우 위법성은 항상 조각된다.", q1: 'X', q2_question: "다음 중 피해자의 승낙에도 불구하고 위법성이 조각되지 않아 범죄가 성립하는 사례는?", q2: ["의사의 수술로 상해를 입힌 경우", "채무자가 동의했지만 신체 일부를 취득한 경우", "조난자를 위해 타인의 집에 침입한 경우", "15세 미성년자의 성적 자기결정권 동의가 있는 경우"], answerIndex: 1, explanation: "사회 통념상 용인될 수 없는 경우(예: 신체 일부를 강제로 취득)는 승낙이 있어도 위법성이 조각되지 않는다." },
            { id: 305, type: 'two-step', difficulty: '상', case: "형벌의 종류 중 재산형에는 벌금, 과료, 몰수가 포함된다.", q1: 'O', q2_question: "다음 중 재산형에 해당하지 않는 형벌은?", q2: ["벌금 5,000만 원", "과료 30,000원", "몰수", "자격 정지 1년"], answerIndex: 3, explanation: "자격 정지는 인격이나 자격을 제한하는 명예형이다." },
            { id: 306, type: 'two-step', difficulty: '상', case: "소년 보호 처분에는 보호 관찰, 소년원 송치 등이 포함되며, 이는 형벌이 아닌 보호 처분의 일종이다.", q1: 'O', q2_question: "다음 중 「소년법」상 소년에게 사형 또는 무기형이 선고될 경우 적용되는 특칙은?", q2: ["사형 또는 무기형이 그대로 집행된다.", "사형 또는 무기형 대신 15년의 유기 징역으로 한다.", "23세가 될 때까지 소년 교도소에 수용된다.", "소년 보호 처분으로 소년원에 송치된다."], answerIndex: 1, explanation: "형법상 만 18세 미만인 소년에게는 사형·무기형을 선고할 수 없으며, 유기징역 15년으로 대체된다." },
            { id: 307, type: 'two-step', difficulty: '상', case: "기소 독점주의는 검사만이 공소 제기를 할 수 있도록 하는 제도이다.", q1: 'O', q2_question: "검사의 불기소 처분에 불복하여 재판을 요청할 수 있는 절차는?", q2: ["배상 명령 제도", "재정 신청 제도", "형사 보상 제도", "국민 참여 재판"], answerIndex: 1, explanation: "재정 신청 제도는 검사의 불기소에 대한 피해자의 불복 절차다." },
            { id: 308, type: 'two-step', difficulty: '상', case: "형사 재판에서 법관은 양심에 따라 판단하지만, 반드시 증거에 따라야 한다. 따라서 형사 재판에서 법관은 증거 없이도 선고할 수 있다.", q1: 'X', q2_question: "다음 중 형사 절차상 증거 관련 원칙으로 옳지 않은 것은?", q2: ["증거 재판주의: 사실의 인정은 증거에 의하여야 한다.", "자백 배제 법칙: 고문 등으로 자백한 경우에도 증거로 사용 가능하다.", "독수독과의 원칙: 위법하게 수집된 증거에 의한 2차 증거도 무효이다.", "자백 보강 법칙: 자백만으로는 유죄 증거가 될 수 없다."], answerIndex: 1, explanation: "자백은 고문이나 협박에 의해 이끌어졌다면 증거능력을 인정할 수 없다." },
            { id: 309, type: 'two-step', difficulty: '상', case: "피의자나 피고인이 반드시 구속 상태에서 재판을 받는 것은 아니다.", q1: 'O', q2_question: "다음 중 수사 단계에서 피의자 인권 보장을 위한 제도가 아닌 것은?", q2: ["불구속 수사 원칙", "영장주의", "구속 적부심 제도", "보석 제도"], answerIndex: 3, explanation: "보석 제도는 공판 단계에서 피고인에게 적용되는 제도다." },
            { id: 310, type: 'two-step', difficulty: '상', case: "형법에서는 두 개 이상의 같은 종류의 형(예: 징역형)에 대해 형을 정할 때, 가장 무거운 죄의 형에 그 형의 절반까지를 더해 처벌할 수 있도록 하고 있다.", q1: 'O', q2_question: "甲은 특수절도죄(최고 징역 5년)와 사기죄(최고 징역 3년)를 함께 저질렀다. 두 범죄 모두 징역형으로 가능한 같은 종류의 형벌이 부과될 수 있다. 형법 규정에 따라 甲이 받을 수 있는 최대 징역 형량은?", q2: ["5년", "7년 6개월", "8년", "50년"], answerIndex: 1, explanation: "두 범죄가 모두 징역형이므로 같은 종류의 형에 해당한다. 이 경우 형법상 가장 무거운 죄인 특수절도죄(최고 5년)에 그 절반인 2년 6개월을 더해 최대 7년 6개월까지 처벌할 수 있다. 다른 범죄의 형량을 단순히 더하는 것이 아니라, 가장 무거운 죄 기준으로 계산하는 점이 핵심이다." },
            { id: 311, type: 'two-step', difficulty: '상', case: "갑은 밤늦게 귀가하던 중 자신에게 흉기를 휘두르며 금품을 요구하는 강도 을을 만났다. 갑은 을의 공격을 막기 위해 우산으로 반격했고, 이로 인해 을은 골절상을 입었다. 이 경우 갑의 행위는 범죄로 성립한다.", q1: 'X', q2_question: "위 사례에서 갑의 행위에 해당하는 위법성 조각 사유는 무엇인가?", q2: ["긴급 피난", "정당방위", "자구 행위", "정당 행위"], answerIndex: 1, explanation: "현재의 부당한 침해에 대한 자기방어이므로 정당방위에 해당한다." },
            { id: 312, type: 'two-step', difficulty: '상', case: "등산객 갑은 산에서 멧돼지 떼를 만나 위협을 느끼고, 옆에 있던 다른 등산객 을의 텐트 뒤로 몸을 숨겼다. 그 과정에서 텐트가 손상되었다. 이 경우 갑의 행위는 형법상 정당화될 수 있다.", q1: 'O', q2_question: "위 사례에서 갑의 행위에 해당하는 위법성 조각 사유는 무엇인가?", q2: ["정당방위", "긴급 피난", "자구 행위", "정당 행위"], answerIndex: 1, explanation: "자기 법익에 대한 현재의 위난을 피하기 위한 상당한 이유 있는 행위로서 긴급피난에 해당한다." },
            { id: 313, type: 'two-step', difficulty: '상', case: "택배 기사인 갑은 졸음을 이기지 못해 법정 제한 속도를 일시 초과하며 운전했다. 인명 피해는 없었지만 도로교통법 위반으로 단속되었다. 이 경우 갑의 행위는 정당한 사유에 의해 위법성이 조각된다.", q1: 'X', q2_question: "위 사례에서 갑의 행위가 위법성 조각 사유에 해당한다고 보기 어려운 가장 적절한 이유는?", q2: ["정당방위 요건을 충족하지 못했기 때문이다.", "고의가 없었기 때문이다.", "사회 상규에 어긋나는 행위이기 때문이다.", "법률보다 판례가 우선 적용되기 때문이다."], answerIndex: 2, explanation: "정당 행위로 보기 위해서는 사회 상규에 부합해야 하나, 해당 행위는 이에 어긋난다." },
            { id: 314, type: 'two-step', difficulty: '상', case: "채무자 갑은 도망 중이었다. 채권자 을은 우연히 길에서 갑을 마주쳐 도망을 막기 위해 그의 가방을 붙잡았고, 이로 인해 가방이 파손되었다. 이 경우 을의 행위는 위법성이 조각된다.", q1: 'O', q2_question: "위 사례에서 을의 행위에 해당하는 위법성 조각 사유는 무엇인가?", q2: ["정당방위", "긴급 피난", "자구 행위", "정당 행위"], answerIndex: 2, explanation: "국가의 구제를 기대하기 어려운 상황에서 청구권 실현을 위한 불가피한 자구 행위다." },
            { id: 315, type: 'two-step', difficulty: '상', case: "경찰청은 불량 식재료를 유통한 식품 업체에 대한 정보를 수사 후 국민 건강 보호 차원에서 언론에 공표하였다. 이로 인해 업체의 명예는 실추되었다. 이 경우 경찰청의 행위는 위법성이 인정된다.", q1: 'X', q2_question: "위 사례에서 경찰청의 행위에 해당하는 위법성 조각 사유는 무엇인가?", q2: ["정당방위", "긴급 피난", "자구 행위", "정당 행위"], answerIndex: 3, explanation: "공익 목적과 진실성, 필요성이 인정되므로 정당 행위로서 위법성이 조각된다." },
            { id: 316, type: 'two-step', difficulty: '상', case: "야간 근무 중인 경비원 갑은 침입자를 제지하던 중 반격을 받고, 시설 보호를 위해 물리력을 사용해 제압하였다. 침입자는 경미한 상처를 입었다. 이 경우 갑의 행위는 형법상 범죄로 성립한다.", q1: 'X', q2_question: "위 사례에서 갑의 행위에 해당하는 위법성 조각 사유는 무엇인가?", q2: ["긴급 피난", "정당방위", "자구 행위", "정당 행위"], answerIndex: 1, explanation: "현재의 부당한 침해에 대응한 자기방어로서 정당방위에 해당한다." },
            { id: 401, type: 'two-step', difficulty: '최상', case: "오늘날 강조되는 실질적 죄형 법정주의는 입법자가 부당한 법률을 제정하는 것까지도 제한하여 국민의 자유와 권리를 보호하고자 한다.", q1: 'O', q2_question: "다음은 조선시대 형벌에 대한 설명입니다. 이를 통해 알 수 있는 현대적 죄형 법정주의 원칙의 중요성은 무엇입니까? <br>\"조선시대에는 성문법 외에 정령이나 사회 통념에 따라 형벌이 부과되기도 했다.\"", q2: ["예측 가능하고 명확한 법률의 중요성", "형벌과 범죄의 비례성 원칙의 중요성", "행위 당시의 법률을 적용하는 행위시법주의의 중요성", "국가 형벌권 남용을 막기 위한 적법 절차의 원칙의 중요성"], answerIndex: 0, explanation: "조선시대의 사례는 성문법 외의 기준으로 형벌이 부과될 수 있었음을 보여준다. 이는 국민이 어떤 행위가 처벌 대상이 되는지 예측할 수 있도록 법률이 명확해야 한다는 현대의 명확성의 원칙과 관습 형법 금지의 원칙의 중요성을 부각시킨다." },
            { id: 402, type: 'two-step', difficulty: '최상', case: "보호 관찰은 형벌이 아니므로 행위 이전에 반드시 규정되어 있어야 하는 것은 아니며, 재판 시의 규정에 따라 명할 수 있다.", q1: 'O', q2_question: "다음 중 형벌에 대한 설명으로 옳은 것을 고르시오.", q2: ["징역형은 재산형에 해당한다.", "벌금형은 일정 기간 신체의 자유를 박탈하는 형벌이다.", "보안 처분은 범죄자의 사회적 위험성을 전제로 특별 예방의 관점에서 부과된다.", "사형은 무기 징역형보다 범죄자에 대한 법익 침해의 정도가 작다."], answerIndex: 2, explanation: "보안 처분은 행위자의 사회적 위험성과 재범의 우려를 전제로 특별 예방의 관점에서 부과된다. ① 징역형은 자유형, ② 벌금형은 재산형, ④ 사형은 가장 큰 법익 침해를 가하는 형벌이다." },
            { id: 403, type: 'two-step', difficulty: '최상', case: "형사 절차에서 유죄 판결이 확정되기 전까지는 피의자와 피고인을 무죄로 추정하는 것이 원칙이다.", q1: 'O', q2_question: "다음 중 무죄 추정의 원칙이 적용된 것으로 볼 수 없는 상황은?", q2: ["언론이 피의자에 대해 '범죄자'라는 표현을 사용하지 않고 '피의자' 또는 '혐의자'로 보도하는 것", "경찰 수사가 진행 중인 공무원에 대해 유죄 판결이 나기 전에 직위 해제하고 언론에 실명과 사진을 공개한 경우", "피고인이 범죄 혐의로 수사를 받더라도 불구속으로 수사하는 것을 원칙으로 하는 것", "피고인이 재판 중에도 변호인의 조력을 받을 권리를 보장받는 것"], answerIndex: 1, explanation: "무죄 추정의 원칙은 유죄 판결이 확정되기 전까지는 피의자나 피고인을 무죄로 간주해야 한다는 원칙이다. 유죄가 확정되기 전부터 공무원을 범죄자로 취급하여 언론에 보도하는 것은 무죄 추정의 원칙의 취지에 어긋난다." },
            { id: 404, type: 'two-step', difficulty: '최상', case: "보안 처분은 형벌과 달리 과거의 불법에 대한 책임에 기초하며, 그 부과에 죄형 법정주의의 소급효 금지 원칙이 예외 없이 적용된다.", q1: 'X', q2_question: "다음 중 보안 처분으로서 사회 복귀 및 교화를 목적으로 하는 시설에 수용되는 사례는?", q2: ["만 17세의 甲이 심각한 범죄로 일반 형사 법원에서 징역형을 선고받고 소년 교도소에 수용된 경우", "만 16세의 乙이 가정 법원 소년부로부터 '장기 소년원 송치' 처분을 받고 소년원에 수용된 경우", "만 20세의 丙이 음주운전으로 집행 유예를 선고받고 사회봉사 명령을 받은 경우", "만 14세의 丁이 심신상실 상태에서 살인죄를 저질러 치료 감호 시설에 수용된 경우"], answerIndex: 1, explanation: "보안 처분은 장래의 위험성을 예방하기 위한 조치로 소급효 금지 원칙이 적용되지 않는다. 소년원은 소년 보호 처분을 받은 소년을 교정 교육을 통해 사회 복귀와 교화를 목적으로 수용하는 시설이다." },
            { id: 405, type: 'two-step', difficulty: '최상', case: "강제 처분은 실체적 진실을 발견하고 형벌권을 실현하기 위해 불가피하더라도, 개인의 기본권을 침해하므로 반드시 법률에 의하여 그 종류 및 요건과 절차가 갖추어져야 한다.", q1: 'O', q2_question: "다음 사례는 형사 절차에서 인권 보장을 위한 어떤 원칙을 위반한 것으로 볼 수 있습니까? <br>\"경찰관 甲은 乙을 체포 후, 권리 고지 없이 심문하여 자백을 받았고, 이 자백이 유일한 유죄 증거로 제시되었다.\"", q2: ["영장주의", "무죄 추정의 원칙", "자백 보강 법칙 및 미란다 원칙(진술 거부권 고지)", "적법 절차의 원칙 및 형사 보상 제도"], answerIndex: 2, explanation: "이 사례에서는 乙에게 진술 거부권 등의 고지(미란다 원칙)가 이루어지지 않아 위법하게 수집된 자백에 해당하며, 또한 자백이 유일한 증거로 제시되었으므로 자백 보강 법칙에 위배된다. 이 두 원칙 위반이 핵심이다." },
            { id: 121, type: 'one-step-ox', difficulty: '하', case: "검사가 공소를 제기하지 않는 처분을 불기소 처분이라고 한다.", q1: 'O', explanation: "수사 결과 피의자의 범죄 혐의가 인정되어도 검사가 공소를 제기하지 않는 처분을 불기소 처분이라고 한다." },
            { id: 122, type: 'one-step-ox', difficulty: '하', case: "피고인이 유죄 판결을 받을 때까지는 무죄로 추정된다는 원칙은 모든 형사 절차에 적용되는 인권 보장 원칙이다.", q1: 'O', explanation: "무죄 추정의 원칙은 모든 형사 절차에서 피고인이 유죄 판결이 확정될 때까지 무죄로 추정되는 인권 보장 원칙이다." },
            { id: 216, type: 'single', difficulty: '중', case: "다음 중 형벌에 대한 설명으로 옳지 않은 것은?", q2: ["사형은 생명을 빼앗는 생명형에 해당한다.", "징역은 교정 시설에 수용하여 노역에 복무하게 하는 자유형이다.", "벌금은 재산을 빼앗는 재산형에 해당하며, 원칙적으로 5만 원 이상이다.", "자격 정지는 공무원이 되는 자격이나 선거권 등을 영구적으로 박탈하는 명예형이다."], answerIndex: 3, explanation: "자격 정지는 일정 기간 자격을 정지하는 것이며, 영구적으로 박탈하는 것은 자격 상실입니다." },
            { id: 217, type: 'single', difficulty: '중', case: "소년 보호 사건의 처리 절차에 대한 설명으로 옳지 않은 것은?", q2: ["19세 미만의 소년에게는 성인 범죄자와 다른 재판 절차와 형 집행 절차를 거칠 수 있다.", "사건의 경중에 따라 보호 관찰, 소년원 송치 등의 보호 처분을 받을 수 있다.", "가정법원소년부에서 재판을 통해 소년범에게 직접 형벌을 부과할 수 없다.", "소년범은 소년 교도소에 수용될 수 있으나, 소년원에는 수용될 수 없다."], answerIndex: 3, explanation: "소년범은 범죄의 경중에 따라 소년 교도소에 수용될 수도 있고, 가정 법원 소년부에서 소년 보호 처분을 받은 경우 소년원에 수용될 수도 있다. ①, ②, ③은 소년 보호 사건 처리 절차의 특칙에 대한 설명으로 옳다." },
            { id: 218, type: 'single', difficulty: '중', case: "형벌의 종류 중, 교정 시설에 수용하되 노역을 부과하지 않는 형벌은?", q2: ["징역", "금고", "구류", "벌금"], answerIndex: 1, explanation: "금고는 1개월 이상 교정 시설에 수용하여 집행하지만 노역을 부과하지 않는다. 구류도 노역을 부과하지 않으나 기간이 1일 이상 30일 미만으로 제한된다. 징역은 교정 시설에 수용하여 정해진 노역에 복무하게 한다." },
            { id: 311, type: 'two-step', difficulty: '상', case: "갑은 밤늦게 귀가하던 중 자신에게 흉기를 휘두르며 금품을 요구하는 강도 을을 만났다. 갑은 을의 공격을 막기 위해 우산으로 반격했고, 이로 인해 을은 골절상을 입었다. 이 경우 갑의 행위는 범죄로 성립한다.", q1: 'X', q2_question: "위 사례에서 갑의 행위에 해당하는 위법성 조각 사유는 무엇인가?", q2: ["긴급 피난", "정당방위", "자구 행위", "정당 행위"], answerIndex: 1, explanation: "현재의 부당한 침해에 대한 자기방어이므로 정당방위에 해당한다." },
            { id: 312, type: 'two-step', difficulty: '상', case: "등산객 갑은 산에서 멧돼지 떼를 만나 위협을 느끼고, 옆에 있던 다른 등산객 을의 텐트 뒤로 몸을 숨겼다. 그 과정에서 텐트가 손상되었다. 이 경우 갑의 행위는 형법상 정당화될 수 있다.", q1: 'O', q2_question: "위 사례에서 갑의 행위에 해당하는 위법성 조각 사유는 무엇인가?", q2: ["정당방위", "긴급 피난", "자구 행위", "정당 행위"], answerIndex: 1, explanation: "자기 법익에 대한 현재의 위난을 피하기 위한 상당한 이유 있는 행위로서 긴급피난에 해당한다." },
            { id: 313, type: 'two-step', difficulty: '상', case: "택배 기사인 갑은 졸음을 이기지 못해 법정 제한 속도를 일시 초과하며 운전했다. 인명 피해는 없었지만 도로교통법 위반으로 단속되었다. 이 경우 갑의 행위는 정당한 사유에 의해 위법성이 조각된다.", q1: 'X', q2_question: "위 사례에서 갑의 행위가 위법성 조각 사유에 해당한다고 보기 어려운 가장 적절한 이유는?", q2: ["정당방위 요건을 충족하지 못했기 때문이다.", "고의가 없었기 때문이다.", "사회 상규에 어긋나는 행위이기 때문이다.", "법률보다 판례가 우선 적용되기 때문이다."], answerIndex: 2, explanation: "정당 행위로 보기 위해서는 사회 상규에 부합해야 하나, 해당 행위는 이에 어긋난다." },
            { id: 314, type: 'two-step', difficulty: '상', case: "채무자 갑은 도망 중이었다. 채권자 을은 우연히 길에서 갑을 마주쳐 도망을 막기 위해 그의 가방을 붙잡았고, 이로 인해 가방이 파손되었다. 이 경우 을의 행위는 위법성이 조각된다.", q1: 'O', q2_question: "위 사례에서 을의 행위에 해당하는 위법성 조각 사유는 무엇인가?", q2: ["정당방위", "긴급 피난", "자구 행위", "정당 행위"], answerIndex: 2, explanation: "국가의 구제를 기대하기 어려운 상황에서 청구권 실현을 위한 불가피한 자구 행위다." },
            { id: 315, type: 'two-step', difficulty: '상', case: "경찰청은 불량 식재료를 유통한 식품 업체에 대한 정보를 수사 후 국민 건강 보호 차원에서 언론에 공표하였다. 이로 인해 업체의 명예는 실추되었다. 이 경우 경찰청의 행위는 위법성이 인정된다.", q1: 'X', q2_question: "위 사례에서 경찰청의 행위에 해당하는 위법성 조각 사유는 무엇인가?", q2: ["정당방위", "긴급 피난", "자구 행위", "정당 행위"], answerIndex: 3, explanation: "공익 목적과 진실성, 필요성이 인정되므로 정당 행위로서 위법성이 조각된다." },
            { id: 316, type: 'two-step', difficulty: '상', case: "야간 근무 중인 경비원 갑은 침입자를 제지하던 중 반격을 받고, 시설 보호를 위해 물리력을 사용해 제압하였다. 침입자는 경미한 상처를 입었다. 이 경우 갑의 행위는 형법상 범죄로 성립한다.", q1: 'X', q2_question: "위 사례에서 갑의 행위에 해당하는 위법성 조각 사유는 무엇인가?", q2: ["긴급 피난", "정당방위", "자구 행위", "정당 행위"], answerIndex: 1, explanation: "현재의 부당한 침해에 대응한 자기방어로서 정당방위에 해당한다." },
            { id: 406, type: 'two-step', difficulty: '최상', case: ""학생 갑은 학교 폭력 가해자로 지목되어 징계가 확정되기 전에 전면 등교 금지 조치를 받았다. 이러한 학교의 조치는 우리 헌법상 형사사법 절차에 적용되는 기본권 보호 원칙에 비추어 정당하다고 볼 수 있는가?", q1: 'X', q2_question: "위 상황에서 가장 중요한 인권 보장 원칙은 무엇인가?", q2: ["진술 거부권", "변호인의 조력을 받을 권리", "무죄 추정의 원칙", "증거재판주의"], answerIndex: 2, explanation: "형사 절차에서 유죄 확정 전까지는 무죄로 추정해야 하며, 징계 확정 전 불이익 조치는 위 원칙에 반한다." },
            { id: 407, type: 'two-step', difficulty: '최상', case: "갑은 2022년 12월 31일 범죄를 저질렀고, 2023년 1월 1일부터 형량이 감경된 개정 법률이 시행되었다. 법원은 갑에게 개정법을 적용했다. 이 경우 법원의 판단은 법적으로 타당하다.", q1: 'O', q2_question: "이 경우 법원의 판단을 뒷받침하는 법 원칙은 무엇인가?", q2: ["죄형 법정주의의 예외", "피고에게 유리한 소급 적용 허용", "적법 절차 원칙", "법관 재량주의"], answerIndex: 1, explanation: "피고에게 유리한 경우에는 소급하여 법을 적용할 수 있다. 형벌 불소급 원칙의 예외이다." }
        ];

        // 게임 초기화 함수
        function initGame() {
            resetGameState();
            showScreen('story-screen');
        }

        function resetGameState() {
             gameState = {
                 player: { name: '', class: '', gender: '', level: 1, imageKey: '' },
                 difficulty: null, lives: 5, monstersDefeated: 0,
                 currentMonster: null, currentQuiz: null, usedQuizIds: [],
                 clearedStages: { '하': false, '중': false, '상': false },
                 isBossFight: false, bossStage: 0,
                 currentScreen: 'start-screen',
                 animation: { type: null, progress: 0, duration: 0, shake: 0, monsterXOffset: 0, playerShake: {x: 0, y: 0} },
                 questionsAttempted: 0,
                 questionsCorrect: 0,
                 isSkippable: false,
                 onSkip: null,
                 skippableTimeoutId: null,
                 isChallengeUnlocked: false,
                 score: 0
             };
             gameOverDebris = [];
        }

        // 화면 전환
        function showScreen(screenId) {
            screens.forEach(screen => screen.classList.remove('active'));
            document.getElementById(screenId).classList.add('active');
            gameState.currentScreen = screenId;
        }

        // 에셋 로딩
        async function loadAssets() {
            const imageSources = [
                ...Object.values(assets.characters),
                ...Object.values(assets.monsters),
                ...Object.values(assets.misc)
            ];
            const imagePromises = imageSources.map(src => {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.src = src;
                    img.onload = () => {
                        let keyFound = false;
                        for (const category in assets) {
                            const key = Object.keys(assets[category]).find(k => assets[category][k] === src);
                            if (key) {
                                loadedImages[key] = img;
                                keyFound = true;
                                break;
                            }
                        }
                        resolve();
                    };
                    img.onerror = () => {
                        console.error(`이미지 로딩 실패: ${src}`);
                        resolve();
                    }
                });
            });
            await Promise.all(imagePromises);
        }
        
        function initAndPlayBGM() {
            if (bgmAudioElement.paused) {
                const playPromise = bgmAudioElement.play();
                if (playPromise !== undefined) {
                    playPromise.catch(error => {
                        console.error("오디오 자동재생 실패. 사용자 상호작용이 필요합니다.", error);
                    });
                }
            }
        }

        // 게임 로직
        function startNewGame() {
            resetGameState();
            showScreen('character-selection-screen');
        }

        function setupDifficultyScreen() {
            const statusEl = document.getElementById('difficulty-char-status');
            statusEl.innerHTML = `
                <h3>${gameState.player.name}</h3>
                <p>LV. ${gameState.player.level} | 직업: ${gameState.player.class}</p>
            `;
            
            const optionsContainer = document.getElementById('difficulty-options');
            optionsContainer.querySelectorAll('.difficulty-option:not(.challenge-option)').forEach(opt => {
               const btn = opt.querySelector('.difficulty-btn');
               const diff = btn.dataset.difficulty;
               const isCleared = gameState.clearedStages[diff];
               if(isCleared) {
                   btn.textContent = `${diff} (클리어!)`;
                   btn.style.backgroundColor = 'var(--success-color)';
               } else {
                   btn.textContent = diff;
                   btn.style.backgroundColor = 'var(--primary-color)';
               }
               btn.classList.toggle('disabled', (diff === '중' && !gameState.clearedStages['하']) || (diff === '상' && !gameState.clearedStages['중']));
            });
            
            const existingChallengeBtn = optionsContainer.querySelector('.challenge-option');
            if (existingChallengeBtn) existingChallengeBtn.remove();

            if (gameState.isChallengeUnlocked) {
                const challengeOption = document.createElement('div');
                challengeOption.className = 'difficulty-option challenge-option';
                challengeOption.innerHTML = `
                  <button class="btn btn-challenge difficulty-btn" data-difficulty="도전자">도전자</button>
                  <p class="difficulty-desc">최고 점수에 도전하세요!</p>
                `;
                optionsContainer.appendChild(challengeOption);
                challengeOption.querySelector('.difficulty-btn').addEventListener('click', () => startGame('도전자'));
            }

            showScreen('difficulty-selection-screen');
        }

        function startGame(difficulty) {
            gameState.difficulty = difficulty;
            gameState.usedQuizIds = [];
            gameState.isBossFight = false;
            gameState.bossStage = 0;
            gameState.questionsAttempted = 0;
            gameState.questionsCorrect = 0;

            if (difficulty === '상') {
                gameState.lives = 3;
            } else if (difficulty === '도전자') {
                gameState.lives = 3;
                gameState.score = 0;
            } else {
                gameState.lives = 5;
            }

            monsterInfoDisplay.style.display = 'none';
            updateStatus();
            startDungeonAnimation(true);
        }

        function startDungeonAnimation(showInitialMessage = false) {
            showScreen('game-screen');
            dungeonPillars = [];
            for (let i = 0; i < 5; i++) {
                dungeonPillars.push({
                    x: canvas.width + i * (canvas.width / 4),
                    y: canvas.height * 0.2,
                    width: 30,
                    height: canvas.height * 0.4
                });
            }
            gameState.animation = { type: 'dungeon-intro', progress: 0, duration: 2000, shake: 0, monsterXOffset: 0, playerShake: {x:0, y:0} };
            gameLoop();
            
            const callback = () => {
                if (gameState.animation.type === 'dungeon-intro') {
                    gameState.animation.type = null;
                    if (showInitialMessage) {
                        showTemporaryMessage("몬스터가 등장했습니다.", 1000, spawnMonster);
                    } else {
                        spawnMonster();
                    }
                }
            };
            
            makeEventSkippable(callback, 2000);
        }
        
        function makeEventSkippable(callback, duration) {
            if (gameState.skippableTimeoutId) clearTimeout(gameState.skippableTimeoutId);
            
            const onSkipCallback = () => {
                if(gameState.isSkippable) { 
                    gameState.isSkippable = false;
                    clearTimeout(gameState.skippableTimeoutId);
                    gameState.skippableTimeoutId = null;
                    gameState.onSkip = null;
                    callback();
                }
            };

            gameState.isSkippable = true;
            gameState.onSkip = onSkipCallback;
            gameState.skippableTimeoutId = setTimeout(onSkipCallback, duration);
        }

        function skipCurrentEvent() {
            if (gameState.animation.type === 'dungeon-intro' && gameState.isSkippable && typeof gameState.onSkip === 'function') {
                gameState.onSkip();
            }
        }

        function spawnMonster() {
            const difficulty = gameState.difficulty;
            let monsterType;

            if (gameState.isBossFight) {
                monsterType = '보스';
            } else if (difficulty === '도전자') {
               const rand = Math.random();
               if (rand < 0.4) monsterType = '중';
               else if (rand < 0.8) monsterType = '상';
               else monsterType = '보스';
            } else {
                const rand = Math.random() * 100;
                if (difficulty === '하') {
                    if (rand < 65) monsterType = '하'; else if (rand < 90) monsterType = '중'; else monsterType = '상';
                } else if (difficulty === '중') {
                    if (rand < 50) monsterType = '하'; else if (rand < 85) monsterType = '중'; else monsterType = '상';
                } else { 
                    if (rand < 40) monsterType = '하'; else if (rand < 70) monsterType = '중'; else monsterType = '상';
                }
            }
            
            gameState.currentMonster = { type: monsterType, imageKey: monsterType };
            startQuiz();
        }

        function startQuiz() {
            gameState.questionsAttempted++;
            updateStatus();
            let quizDifficulty;

            if (gameState.difficulty === '도전자') {
                const rand = Math.random();
                if (rand < 0.4) quizDifficulty = '중';
                else if (rand < 0.8) quizDifficulty = '상';
                else quizDifficulty = '최상';
            } else if (gameState.isBossFight) {
                if (gameState.difficulty === '하') quizDifficulty = '상';
                else quizDifficulty = '최상';
            } else {
                quizDifficulty = gameState.currentMonster.type;
            }

            monsterInfoDisplay.innerHTML = `몬스터 등급: ${gameState.currentMonster.type}<br>문제 난이도: ${quizDifficulty}`;
            monsterInfoDisplay.style.display = 'block';

            const availableQuizzes = quizzes.filter(q => q.difficulty === quizDifficulty && !gameState.usedQuizIds.includes(q.id));

            if (availableQuizzes.length === 0) {
                const quizzesOfDifficulty = quizzes.filter(q => q.difficulty === quizDifficulty).map(q => q.id);
                gameState.usedQuizIds = gameState.usedQuizIds.filter(id => !quizzesOfDifficulty.includes(id));
                const newAvailableQuizzes = quizzes.filter(q => q.difficulty === quizDifficulty && !gameState.usedQuizIds.includes(q.id));
                if(newAvailableQuizzes.length === 0) {
                    showMessage(`이 난이도의 모든 문제를 정복했습니다!`, prepareNextEncounter);
                    return;
                }
                gameState.currentQuiz = newAvailableQuizzes[Math.floor(Math.random() * newAvailableQuizzes.length)];
            } else {
                gameState.currentQuiz = availableQuizzes[Math.floor(Math.random() * availableQuizzes.length)];
            }
            
            gameState.usedQuizIds.push(gameState.currentQuiz.id);
            displayQuiz();
        }

        function displayQuiz() {
            const quiz = gameState.currentQuiz;
            q2OptionsEl.innerHTML = '';
            
            if (quiz.type === 'single') {
                quizCaseEl.innerHTML = `[문제]<br>${quiz.case}`;
                q1OptionsEl.style.display = 'none';
                q2OptionsEl.style.display = 'flex';
                quiz.q2.forEach((option, index) => {
                    const btn = document.createElement('button');
                    btn.classList.add('btn', 'quiz-btn', 'q2-btn');
                    btn.innerHTML = `${index + 1}. ${option}`;
                    btn.dataset.answerIndex = index;
                    q2OptionsEl.appendChild(btn);
                });
            } else if (quiz.type === 'two-step') {
                quizCaseEl.innerHTML = `[O/X 문제]<br>${quiz.case}`;
                q1OptionsEl.style.display = 'flex';
                q2OptionsEl.style.display = 'none';
            } else { 
                quizCaseEl.innerHTML = `[O/X 문제]<br>${quiz.case}`;
                q1OptionsEl.style.display = 'flex';
                q2OptionsEl.style.display = 'none';
            }
            quizContainer.style.display = 'flex';
        }
        
        function displayQ2ForTwoStep() {
            const quiz = gameState.currentQuiz;
            const q2Question = quiz.q2_question || "위 O/X 판단에 대한 근거로 가장 적절한 것을 고르시오.";
            quizCaseEl.innerHTML = `<b>[심화 문제]</b><br>${q2Question}`;
            q1OptionsEl.style.display = 'none';
            q2OptionsEl.style.display = 'flex';
            
            quiz.q2.forEach((option, index) => {
                const btn = document.createElement('button');
                btn.classList.add('btn', 'quiz-btn', 'q2-btn');
                btn.innerHTML = `${index + 1}. ${option}`;
                btn.dataset.answerIndex = index;
                q2OptionsEl.appendChild(btn);
            });
        }

        function handleQ1Answer(answer) {
            const quiz = gameState.currentQuiz;
            if (answer === quiz.q1) {
                if (quiz.type === 'one-step-ox') {
                    handleCorrectAnswer();
                } else { 
                    displayQ2ForTwoStep();
                }
            } else {
                handleIncorrectAnswer();
            }
        }

        function handleQ2Answer(index) {
            if (index == gameState.currentQuiz.answerIndex) {
                handleCorrectAnswer();
            } else {
                handleIncorrectAnswer();
            }
        }

        function handleCorrectAnswer() {
           if (gameState.difficulty === '도전자') {
               const scoreMap = {'하': 10, '중': 20, '상': 30, '보스': 50, '최상': 50};
               gameState.score += scoreMap[gameState.currentQuiz.difficulty] || 20;
           }
            gameState.questionsCorrect++;
            updateStatus();
            quizContainer.style.display = 'none';
            monsterInfoDisplay.style.display = 'none';
            gameState.animation = { type: 'attack', progress: 0, duration: 1000, shake: 0, monsterXOffset: 0, playerShake: {x:0, y:0} };
            effectParticles = [];

            const nextAction = () => {
                if (gameState.isBossFight) {
                   if (gameState.difficulty === '상' && gameState.bossStage === 0) {
                       gameState.bossStage = 1;
                       showTemporaryMessage("크윽... 이대로 물러날 수 없다..!", 1500, spawnMonster);
                       return;
                   }
                    handleStageClear();
                } else {
                    prepareNextEncounter();
                }
            };

            if (gameState.isBossFight) {
                setTimeout(nextAction, 1000);
            } else {
                showTemporaryMessage("몬스터를 물리쳤다!", 1000, nextAction);
            }
        }
        
        function handleIncorrectAnswer() {
            quizContainer.style.display = 'none';
            monsterInfoDisplay.style.display = 'none';
            gameState.animation = { type: 'player-damage', progress: 0, duration: 1200, shake: 0, monsterXOffset: 0, playerShake: {x:0, y:0} };
            gameState.lives--;
            updateStatus();

            const quiz = gameState.currentQuiz;
            let explanationText = `<b>오답입니다!</b><br><br><b>정답 해설:</b><br>${quiz.explanation || "해설 정보가 없습니다."}`;

            const nextAction = () => {
                if (gameState.lives <= 0) {
                   if (gameState.difficulty === '도전자') {
                       showChallengeResult();
                   } else {
                        startGameOverAnimation();
                   }
                } else {
                    if (gameState.isBossFight) {
                        showTemporaryMessage("다시 도전!", 1000, spawnMonster);
                    } else {
                        startDungeonAnimation();
                    }
                }
            };
            
            setTimeout(() => showMessage(explanationText, nextAction), 1200);
        }

        function startGameOverAnimation() {
            gameOverDebris = [];
            for(let i=0; i<50; i++) {
                gameOverDebris.push({
                    x: Math.random() * canvas.width,
                    y: -Math.random() * canvas.height,
                    width: Math.random() * 40 + 20,
                    height: Math.random() * 30 + 15,
                    vx: (Math.random() - 0.5) * 5,
                    vy: Math.random() * 5 + 2,
                    rotation: 0,
                    vr: (Math.random() - 0.5) * 0.1,
                    color: `rgb(${100 + Math.random()*30}, ${90 + Math.random()*30}, ${90 + Math.random()*30})`
                });
            }
            gameState.animation = { type: 'game-over', progress: 0, duration: 2500, shake: 15, monsterXOffset: 0, playerShake: {x:0, y:0} };
            setTimeout(() => showMessage("GAME OVER", () => setupDifficultyScreen()), 2500);
        }
        
        function prepareNextEncounter() {
            if (gameState.difficulty !== '도전자' && Math.random() < 0.3) {
                if (gameState.difficulty === '상') gameState.lives = Math.min(3, gameState.lives + 1);
                else gameState.lives = Math.min(5, gameState.lives + 1);
            }
            updateStatus();

            if (gameState.difficulty === '도전자') {
               startDungeonAnimation();
               return;
            }

            const bossThresholds = { '하': 5, '중': 8, '상': 10 };
            const correctAnswers = gameState.questionsCorrect;
            let bossConditionMet = correctAnswers >= bossThresholds[gameState.difficulty];
            
            if (bossConditionMet) {
                gameState.isBossFight = true;
                gameState.bossStage = 0;
                showTemporaryMessage("보스가 등장했다!", 1000, spawnMonster);
            } else {
                startDungeonAnimation();
            }
        }
        
        function handleStageClear() {
            gameState.clearedStages[gameState.difficulty] = true;
            gameState.player.level++;
            
            gameState.animation = { type: 'game-clear', progress: 0, duration: 3000, shake: 0, monsterXOffset: 0, playerShake: {x:0, y:0} };
            effectParticles = [];
            for (let i = 0; i < 150; i++) {
                effectParticles.push({
                    type: 'confetti', x: Math.random() * canvas.width, y: Math.random() * -canvas.height,
                    vx: Math.random() * 6 - 3, vy: Math.random() * 5 + 3,
                    size: Math.random() * 10 + 5, color: `hsl(${Math.random() * 360}, 100%, 70%)`,
                    rotation: Math.random() * 360, life: 1
                });
            }
            
            setTimeout(() => {
               if (gameState.clearedStages['하'] && gameState.clearedStages['중'] && gameState.clearedStages['상']) {
                   gameState.isChallengeUnlocked = true;
                   gameState.player.level = 4;
                   startGrandFinale();
               } else {
                    saveGame(false);
                    showMessage(`난이도 '${gameState.difficulty}' 클리어!<br>레벨 업! (현재 LV.${gameState.player.level})`, setupDifficultyScreen);
               }
            }, 3000);
        }

        function startGrandFinale() {
            gameState.animation = { type: 'grand-finale', progress: 0, duration: 6000, shake: 0, monsterXOffset: 0, playerShake: {x:0, y:0} };
            effectParticles = [];
            for (let i = 0; i < 200; i++) {
                effectParticles.push({
                    type: 'confetti', x: Math.random() * canvas.width, y: Math.random() * -canvas.height,
                    vx: Math.random() * 6 - 3, vy: Math.random() * 5 + 3,
                    size: Math.random() * 10 + 5, color: `hsl(${Math.random() * 360}, 100%, 70%)`,
                    rotation: Math.random() * 360, life: 1
                });
            }
            gameLoop();
            
            setTimeout(() => {
                saveGame(false);
                showMessage("지식의 서를 얻고 세상의 모든 지식을 손에 넣었습니다. 축하합니다!", setupDifficultyScreen);
            }, 6000);
        }

        function showChallengeResult() {
           let resultText = `
               <h2>도전 결과</h2>
               <p><b>${gameState.player.name}</b>님의 최종 점수는 <b>${gameState.score}점</b> 입니다!</p>
               <div class="capture-guide">
                   <h4>결과 화면 캡처 안내</h4>
                   <ul>
                       <li><b>📱 아이폰:</b> 측면 버튼 + 음량 높이기 버튼 동시 누르기</li>
                       <li><b>📱 안드로이드:</b> 전원 버튼 + 음량 낮추기 버튼 동시 누르기</li>
                       <li><b>💻 윈도우:</b> 윈도우 키 + Shift + S</li>
                       <li><b>💻 맥:</b> Shift + Command + 4</li>
                   </ul>
               </div>
           `;
           showMessage(resultText, setupDifficultyScreen);
        }


        function updateStatus() {
            document.getElementById('status-name').textContent = gameState.player.name;
            document.getElementById('status-level').textContent = gameState.player.level;
            document.getElementById('status-lives').textContent = '❤️'.repeat(gameState.lives);
            updateProgressDisplay();
        }
        
        function updateProgressDisplay() {
            let progressText = ``;
            if (gameState.difficulty === '도전자') {
                progressText = `점수: ${gameState.score}`;
            } else {
                const bossThresholds = { '하': 5, '중': 8, '상': 10 };
                const needed = bossThresholds[gameState.difficulty];
                const remaining = Math.max(0, needed - gameState.questionsCorrect);
                progressText = `푼 문제: ${gameState.questionsAttempted} | 정답: ${gameState.questionsCorrect}`;
                if (!gameState.isBossFight && !gameState.clearedStages[gameState.difficulty]) {
                    progressText += ` | 보스까지: ${remaining}문제`;
                }
            }
            progressDisplay.textContent = progressText;
        }

        function showMessage(text, callback) {
            messageText.innerHTML = text;
            messageModal.style.display = 'flex';
            
            const newOkBtn = messageOkBtn.cloneNode(true);
            messageOkBtn.parentNode.replaceChild(newOkBtn, messageOkBtn); 
            messageOkBtn = newOkBtn; 

            messageOkBtn.onclick = () => {
                messageModal.style.display = 'none';
                if (callback) callback();
            };
        }
        
        function showTemporaryMessage(text, duration, callback) {
            tempMessageOverlay.textContent = text;
            tempMessageOverlay.classList.add('visible');
            
            setTimeout(() => {
                tempMessageOverlay.classList.remove('visible');
                if (callback) callback();
            }, duration);
        }

        function saveGame(showAlert = true) {
            try {
                localStorage.setItem('crimeQuizRPGSave', JSON.stringify({
                    player: gameState.player,
                    clearedStages: gameState.clearedStages,
                    isChallengeUnlocked: gameState.isChallengeUnlocked
                }));
                if (showAlert) {
                    showMessage("게임이 저장되었습니다.");
                }
            } catch (e) {
                console.error("로컬 스토리지 저장 실패:", e);
                if (showAlert) {
                    showMessage("게임을 저장하는 데 실패했습니다. 브라우저 설정을 확인해주세요.");
                }
            }
        }

        function loadGame() {
            try {
                const saveData = localStorage.getItem('crimeQuizRPGSave');
                if (saveData) {
                    const parsedData = JSON.parse(saveData);
                    resetGameState();
                    gameState.player = parsedData.player;
                    gameState.clearedStages = parsedData.clearedStages;
                    gameState.isChallengeUnlocked = parsedData.isChallengeUnlocked || false;
                    document.getElementById('character-name').value = gameState.player.name;
                    showMessage(`'${gameState.player.name}'님의 데이터를 불러왔습니다.`, setupDifficultyScreen);
                } else {
                    showMessage("저장된 게임이 없습니다.");
                }
            } catch(e) {
                 console.error("로컬 스토리지 불러오기 실패:", e);
                 showMessage("저장된 게임을 불러오는 데 실패했습니다.");
            }
        }

        function resizeCanvas() {
            const container = document.getElementById('game-screen');
            if(container) {
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
            }
        }

        function drawDungeonBackground() {
           const difficulty = gameState.difficulty;
           let grad1 = '#3d3a5e', grad2 = '#5e5a80', wall = '#33304a';

           if (difficulty === '중') { grad1 = '#4a3a3a'; grad2 = '#6b5a5a'; wall = '#403030'; }
           else if (difficulty === '상') { grad1 = '#4a2a4a'; grad2 = '#6b3b6b'; wall = '#402040'; }
           else if (difficulty === '도전자' || gameState.isBossFight) { grad1 = '#5a2a2a'; grad2 = '#7b3b3b'; wall = '#502020'; }

            ctx.fillStyle = grad1;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = grad2;
            ctx.fillRect(0, canvas.height * 0.6, canvas.width, canvas.height * 0.4);
            ctx.strokeStyle = wall;
            ctx.lineWidth = 2;
            for(let y = 0; y < canvas.height * 0.6; y += 40) {
                for(let x = (y/40 % 2) * -20; x < canvas.width; x += 40) {
                    ctx.strokeRect(x, y, 40, 40);
                }
            }
        }

        function drawCharacter(bobbing) {
            const img = loadedImages[gameState.player.imageKey];
            if (!img) return;

            let size = Math.min(canvas.width, canvas.height) * 0.25;
            let yOffset = bobbing ? Math.sin(Date.now() / 200) * 5 : 0;
            let xPos = canvas.width * 0.2 + gameState.animation.playerShake.x;
            let yPos = canvas.height * 0.6 - size + gameState.animation.playerShake.y;
            
            if (gameState.animation.type === 'grand-finale') {
               size = Math.min(canvas.width, canvas.height) * 0.35;
               xPos = canvas.width / 2 - size / 2;
               yPos = canvas.height * 0.4 - size;
               yOffset += Math.abs(Math.sin(Date.now() / 200) * -15);
            }
            
            ctx.drawImage(img, xPos, yPos + yOffset, size, size);
        }

        function drawMonster() {
            if (gameState.currentMonster) {
                const img = loadedImages[gameState.currentMonster.imageKey];
                if (img) {
                    const size = Math.min(canvas.width, canvas.height) * 0.3;
                    let x = canvas.width * 0.8 - size + gameState.animation.monsterXOffset;
                    let y = canvas.height * 0.6 - size;
                    
                    if (gameState.animation.type === 'attack') {
                        const progress = gameState.animation.progress / gameState.animation.duration;
                        x += Math.sin(progress * Math.PI * 10) * 10;
                    }

                    ctx.drawImage(img, x, y, size, size);
                }
            }
        }
        
        function drawEffects(deltaTime) {
            if (gameState.animation.type === 'attack') {
                const progress = Math.min(1, gameState.animation.progress / gameState.animation.duration);
                const level = gameState.player.level;
                const startX = canvas.width * 0.35;
                const startY = canvas.height * 0.45;
                const endX = canvas.width * 0.7;
                
                if (gameState.player.class === '전사') {
                   const easeOutProgress = 1 - Math.pow(1 - progress, 4);
                   const travelX = startX + (endX - startX) * easeOutProgress;
                   const alpha = Math.sin(progress * Math.PI);

                   if (level <= 1) {
                       drawSharpSlash(travelX, startY, 120, 60, alpha, 'white', 'white', 15, 8);
                   } else if (level === 2) {
                       drawSharpSlash(travelX, startY, 140, 70, alpha, '#ffdd00', '#ffdd00', 25, 10);
                       if(progress > 0.2 && progress < 0.8) {
                           drawSharpSlash(travelX + 10, startY, 100, 50, alpha * 0.5, 'white', 'white', 15, 5);
                       }
                   } else if (level === 3) {
                       const p1 = Math.sin(Math.min(1, progress / 0.7) * Math.PI);
                       const p2 = Math.sin(Math.max(0, (progress - 0.3) / 0.7) * Math.PI);
                       drawSharpSlash(endX, startY - 30, 180, 80, p1, '#ff8800', '#ff4400', 35, 15, -20);
                       drawSharpSlash(endX, startY + 30, 180, 80, p2, '#ff8800', '#ff4400', 35, 15, 20);
                   } else { 
                       const p_main = Math.sin(Math.min(1, progress / 0.6) * Math.PI);
                       const p_cross = Math.sin(Math.max(0, (progress-0.4)/0.6) * Math.PI);
                       ctx.save();
                       ctx.translate(endX, startY);
                       drawSharpSlash(0, 0, 300, 150, p_main, 'cyan', 'white', 60, 30, 45);
                       drawSharpSlash(0, 0, 300, 150, p_cross, 'red', 'white', 60, 20, -45);
                       ctx.restore();
                   }
                } else if (gameState.player.class === '마법사') {
                   const currentX = startX + (endX - startX) * progress;
                   const currentY = startY;
                   if (level <= 1) {
                       ctx.fillStyle = `rgba(173, 216, 230, ${1 - progress})`;
                       ctx.shadowColor = 'cyan'; ctx.shadowBlur = 15;
                       ctx.beginPath(); ctx.arc(currentX, currentY, 20, 0, Math.PI * 2); ctx.fill();
                   } else if (level === 2) {
                       for(let i=0; i<3; i++) {
                           const p = (progress + i*0.1) % 1;
                           const x = startX + (endX - startX) * p;
                           ctx.fillStyle = `rgba(100, 180, 255, ${1 - p})`;
                           ctx.shadowColor = 'blue'; ctx.shadowBlur = 20;
                           ctx.beginPath(); ctx.arc(x, currentY + Math.sin(p * Math.PI) * 30, 25, 0, Math.PI * 2); ctx.fill();
                       }
                   } else if (level === 3) {
                       if (progress > 0.1 && progress < 0.9 && Math.random() > 0.5) {
                           effectParticles.push({ type: 'lightning', x: startX, y: startY, tx: endX, ty: startY, life: 0.5 });
                       }
                   } else { 
                       const p_ultimate = Math.sin(progress * Math.PI);
                       ctx.fillStyle = `rgba(255, 215, 0, ${p_ultimate * 0.2})`;
                       ctx.shadowColor = 'gold'; ctx.shadowBlur = 50;
                       ctx.beginPath(); ctx.arc(endX, startY, 200 * p_ultimate, 0, Math.PI * 2); ctx.fill();
                       if (progress > 0.2 && Math.random() > 0.3) {
                           effectParticles.push({ type: 'lightning', x: endX + (Math.random()-0.5)*200, y: startY + (Math.random()-0.5)*200, tx: endX, ty: startY, life: 0.3 });
                       }
                   }
                }
            } else if (gameState.animation.type === 'grand-finale') {
                drawBowingMonsters();
                drawKnowledgeBook();
            }
            
            effectParticles.forEach((p, index) => {
                p.life -= deltaTime / 1000;
                if (p.life <= 0) { effectParticles.splice(index, 1); return; }
                
                ctx.save();
                ctx.globalAlpha = p.life > 0 ? p.life : 0;
                
                if (p.type === 'lightning') {
                    ctx.strokeStyle = `hsl(${200 + Math.random()*100}, 100%, ${70 + Math.random()*30}%)`;
                    ctx.lineWidth = Math.random() * 5 + 2;
                    ctx.shadowColor = '#9b59b6'; ctx.shadowBlur = 20;
                    ctx.beginPath(); ctx.moveTo(p.x, p.y);
                    for(let i=0; i<5; i++) {
                        const nx = p.x + (p.tx-p.x) * (i/4) + (Math.random()-0.5)*40;
                        const ny = p.y + (p.ty-p.y) * (i/4) + (Math.random()-0.5)*40;
                        ctx.lineTo(nx, ny);
                    }
                    ctx.stroke();
                } else { 
                    p.x += p.vx * (deltaTime / 16); p.y += p.vy * (deltaTime / 16);
                    ctx.translate(p.x, p.y);
                    ctx.fillStyle = p.color;
                    ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
                }
                ctx.restore();
            });
        }

        function drawSharpSlash(x, y, height, width, alpha, color, shadowColor, shadowBlur, lineWidth, angle = 0) {
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.shadowColor = shadowColor;
            ctx.shadowBlur = shadowBlur;
            ctx.translate(x, y);
            ctx.rotate(angle * Math.PI / 180);
            ctx.beginPath();
            ctx.moveTo(0, -height / 2);
            ctx.bezierCurveTo(width * 0.8, -height * 0.2, width * 0.8, height * 0.2, 0, height / 2);
            ctx.stroke();
            ctx.restore();
        }

        function drawBowingMonsters() {
            const monsterKeys = ['하', '중', '상', '보스'];
            monsterKeys.forEach((key, index) => {
                const img = loadedImages[key];
                if (!img) return;
                const size = canvas.width * 0.15;
                const x = canvas.width * (0.15 + index * 0.22);
                const y = canvas.height * 0.7 - size;
                ctx.save();
                ctx.translate(x + size / 2, y + size);
                const bowAngle = 0.4 + Math.sin(Date.now() / 500 + index) * 0.1;
                ctx.rotate(bowAngle);
                ctx.drawImage(img, -size / 2, -size, size, size);
                ctx.restore();
            });
        }

        function drawKnowledgeBook() {
            const img = loadedImages['book'];
            if (!img) return;
            const progress = Math.min(1, gameState.animation.progress / 4000);
            const size = canvas.width * 0.25 * progress;
            const x = canvas.width / 2 - size / 2;
            const y = canvas.height * 0.5 - size / 2 + Math.sin(progress * Math.PI * 2) * 10;
            ctx.save();
            ctx.globalAlpha = progress;
            ctx.shadowColor = 'gold';
            ctx.shadowBlur = 30 * progress;
            ctx.drawImage(img, x, y, size, size);
            ctx.restore();
        }

        function drawGameOverAnimation(deltaTime) {
            const gravity = 0.5;
            gameOverDebris.forEach(p => {
                p.vy += gravity * (deltaTime / 16);
                p.x += p.vx * (deltaTime / 16);
                p.y += p.vy * (deltaTime / 16);
                p.rotation += p.vr * (deltaTime / 16);
                
                ctx.save();
                ctx.translate(p.x + p.width/2, p.y + p.height/2);
                ctx.rotate(p.rotation);
                ctx.fillStyle = p.color;
                ctx.fillRect(-p.width/2, -p.height/2, p.width, p.height);
                ctx.strokeStyle = '#2c2a4a';
                ctx.strokeRect(-p.width/2, -p.height/2, p.width, p.height);
                ctx.restore();
            });
        }

        let lastTime = 0;
        function gameLoop(timestamp) {
            if (gameState.currentScreen !== 'game-screen') return;

            const deltaTime = (timestamp - lastTime) || 0;
            lastTime = timestamp;

            // Update animations
            if (gameState.animation.type) {
                gameState.animation.progress += deltaTime;
                const progress = gameState.animation.progress / gameState.animation.duration;

                if (gameState.animation.type === 'player-damage') {
                    const rushProgress = Math.sin(Math.min(1, progress) * Math.PI);
                    gameState.animation.monsterXOffset = -canvas.width * 0.3 * rushProgress;
                    gameState.animation.playerShake.x = (Math.random() - 0.5) * 15 * rushProgress;
                } else {
                    gameState.animation.monsterXOffset = 0;
                    gameState.animation.playerShake.x = 0;
                }

                if (gameState.animation.progress >= gameState.animation.duration) {
                    if(gameState.animation.type !== 'game-over' && gameState.animation.type !== 'game-clear' && gameState.animation.type !== 'grand-finale') {
                        gameState.animation.type = null;
                    }
                }
            }

            ctx.save();
            if(gameState.animation.shake > 0) {
                const shakeAmount = gameState.animation.shake * (1 - (gameState.animation.progress / gameState.animation.duration));
                ctx.translate(Math.random() * shakeAmount - shakeAmount/2, Math.random() * shakeAmount - shakeAmount/2);
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawDungeonBackground();
            
            if (gameState.animation.type === 'dungeon-intro') {
                drawCharacter(true);
            } else if (gameState.animation.type === 'grand-finale') {
                drawCharacter(true); 
            } else {
                drawCharacter(false);
                if (gameState.animation.type !== 'game-over') {
                    drawMonster();
                }
            }
            
            drawEffects(deltaTime);

            if (gameState.animation.type === 'game-over') {
                drawGameOverAnimation(deltaTime);
            }

            ctx.restore();

            requestAnimationFrame(gameLoop);
        }

        // 이벤트 리스너 설정
        window.addEventListener('load', async () => {
            await loadAssets();
            initGame();
            resizeCanvas();
        });
        
        window.addEventListener('resize', resizeCanvas);

        document.getElementById('game-screen').addEventListener('click', (e) => {
            if (e.target.id === 'game-canvas') {
                skipCurrentEvent();
            }
        });

        document.getElementById('story-screen').addEventListener('click', () => {
            showScreen('start-screen');
        });

        document.getElementById('start-new-game-btn').addEventListener('click', () => {
            initAndPlayBGM();
            startNewGame();
        });
        document.getElementById('load-game-btn').addEventListener('click', () => {
            initAndPlayBGM();
            loadGame();
        });
        document.getElementById('save-game-btn').addEventListener('click', () => saveGame(true));
        
        document.getElementById('change-character-btn').addEventListener('click', () => {
            showScreen('character-selection-screen');
        });

        document.getElementById('back-to-difficulty-btn').addEventListener('click', () => {
            saveGame(false);
            setupDifficultyScreen();
        });

        document.querySelectorAll('#character-selection-screen .char-card').forEach(card => {
            card.addEventListener('click', () => {
                document.querySelectorAll('#character-selection-screen .char-card').forEach(c => c.classList.remove('selected'));
                card.classList.add('selected');
            });
        });

        document.getElementById('confirm-character-btn').addEventListener('click', () => {
            const name = document.getElementById('character-name').value.trim();
            const selected = document.querySelector('#character-selection-screen .char-card.selected');
            if (!name) { showMessage("캐릭터 이름을 입력해주세요."); return; }
            if (!selected) { showMessage("캐릭터를 선택해주세요."); return; }
            
            const level = gameState.player.level || 1;
            const clearedStages = gameState.clearedStages || { '하': false, '중': false, '상': false };
            const isChallengeUnlocked = gameState.isChallengeUnlocked || false;

            gameState.player.name = name;
            gameState.player.class = selected.dataset.class;
            gameState.player.gender = selected.dataset.gender;
            gameState.player.imageKey = `${gameState.player.class}_${gameState.player.gender}`;
            gameState.player.level = level;
            gameState.clearedStages = clearedStages;
            gameState.isChallengeUnlocked = isChallengeUnlocked;
            
            setupDifficultyScreen();
        });
        
        document.getElementById('difficulty-options').addEventListener('click', (e) => {
           if (e.target.matches('.difficulty-btn') && !e.target.classList.contains('disabled')) {
               startGame(e.target.dataset.difficulty);
           }
        });

        q1OptionsEl.addEventListener('click', (e) => {
            if (e.target.matches('.quiz-btn')) handleQ1Answer(e.target.dataset.answer);
        });

        q2OptionsEl.addEventListener('click', (e) => {
            const target = e.target.closest('.q2-btn');
            if (target) handleQ2Answer(target.dataset.answerIndex);
        });

        document.getElementById('instructions-btn').addEventListener('click', () => {
            document.getElementById('instructions-modal').style.display = 'flex';
        });
        document.getElementById('instructions-close-btn').addEventListener('click', () => {
            document.getElementById('instructions-modal').style.display = 'none';
        });

        // 인게임 캐릭터 변경 모달 리스너
        const ingameCharChangeModal = document.getElementById('ingame-char-change-modal');
        document.getElementById('ingame-change-char-btn').addEventListener('click', () => {
            ingameCharChangeModal.style.display = 'flex';
        });
        document.getElementById('cancel-ingame-char-change-btn').addEventListener('click', () => {
            ingameCharChangeModal.style.display = 'none';
        });
        ingameCharChangeModal.querySelectorAll('.char-card').forEach(card => {
            card.addEventListener('click', () => {
                ingameCharChangeModal.querySelectorAll('.char-card').forEach(c => c.classList.remove('selected'));
                card.classList.add('selected');
            });
        });
        document.getElementById('confirm-ingame-char-change-btn').addEventListener('click', () => {
            const selected = ingameCharChangeModal.querySelector('.char-card.selected');
            if(selected) {
                gameState.player.class = selected.dataset.class;
                gameState.player.gender = selected.dataset.gender;
                gameState.player.imageKey = `${gameState.player.class}_${gameState.player.gender}`;
                ingameCharChangeModal.style.display = 'none';
            } else {
                showMessage("변경할 캐릭터를 선택해주세요.");
            }
        });

    </script>
</body>
</html>
