 <!DOCTYPE html>
 <html lang="ko">
 <head>
     <meta charset="UTF-8">
     <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
     <title>던전 법률 퀴즈 RPG</title>
     <style>
         @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&family=Cinzel+Decorative:wght@700&display=swap');

         :root {
             --bg-color: #2c2a4a;
             --surface-color: #4f4c7a;
             --primary-color: #9b59b6;
             --secondary-color: #8e44ad;
             --text-color: #ecf0f1;
             --accent-color: #f1c40f;
             --danger-color: #e74c3c;
             --success-color: #2ecc71;
             --challenge-color: #e67e22;
             --font-family: 'Noto Sans KR', sans-serif;
             --title-font: 'Cinzel Decorative', cursive;
         }

         html, body {
             margin: 0;
             padding: 0;
             width: 100%;
             height: 100%;
             overflow: hidden;
             background-color: var(--bg-color);
             color: var(--text-color);
             font-family: var(--font-family);
             display: flex;
             justify-content: center;
             align-items: center;
         }

         #game-container {
             width: 100%;
             height: 100%;
             max-width: 1000px;
             max-height: 800px;
             position: relative;
             background-color: #1e1c3a;
             border-radius: 15px;
             box-shadow: 0 0 30px rgba(0,0,0,0.5);
             overflow: hidden;
             display: flex;
             flex-direction: column;
         }

         .screen {
             position: absolute;
             top: 0;
             left: 0;
             width: 100%;
             height: 100%;
             display: flex;
             flex-direction: column;
             justify-content: center;
             align-items: center;
             padding: 20px;
             box-sizing: border-box;
             background: linear-gradient(135deg, var(--bg-color), #3e3b6b);
             opacity: 0;
             visibility: hidden;
             transition: opacity 0.5s ease, visibility 0.5s ease;
             text-align: center;
         }

         .screen.active {
             opacity: 1;
             visibility: visible;
         }
         
         #story-screen {
             background: radial-gradient(ellipse at bottom, #1b2735 0%, #090a0f 100%);
             cursor: pointer;
         }
         .story-content {
             background: rgba(0,0,0,0.5);
             padding: 20px 40px;
             border-radius: 15px;
             border: 2px solid var(--accent-color);
             max-width: 80%;
             text-align: center;
         }
         .story-content h2 {
             font-family: var(--title-font);
             color: var(--accent-color);
             margin-bottom: 20px;
         }
         .story-content h3 {
             margin-top: 20px;
             color: var(--text-color);
         }
         .story-content p {
             font-size: 1.1em;
             line-height: 1.6;
             margin-bottom: 15px;
         }
         .skip-message {
             margin-top: 30px;
             font-style: italic;
             font-size: 0.9em;
             color: var(--accent-color);
             animation: pulse 2s infinite;
         }
         @keyframes pulse { 0% { opacity: 0.7; } 50% { opacity: 1; } 100% { opacity: 0.7; } }


         #start-screen {
             background: radial-gradient(ellipse at center, #4a477a 0%, #2c2a4a 70%),
                         repeating-linear-gradient(-45deg, rgba(255,255,255,0.02), rgba(255,255,255,0.02) 2px, transparent 2px, transparent 6px);
         }
         #start-screen .title-container {
             border: 4px double var(--accent-color);
             padding: 20px 40px;
             background: rgba(0,0,0,0.3);
             border-radius: 10px;
         }
         #start-screen h1 {
             font-family: var(--title-font);
             font-size: 3em;
             color: var(--accent-color);
             text-shadow: 0 0 5px var(--accent-color), 0 0 15px #000, 0 0 25px #000;
             animation: title-glow 4s infinite alternate;
             margin: 0;
         }
         #start-screen p {
             font-size: 1.1em;
             color: var(--text-color);
             text-shadow: 1px 1px 2px #000;
             margin-top: 10px;
         }

         @keyframes title-glow {
             from { text-shadow: 0 0 5px var(--accent-color), 0 0 15px #000, 0 0 25px #000; }
             to { text-shadow: 0 0 15px var(--accent-color), 0 0 35px #000, 0 0 50px #000; }
         }

         h2, h3 {
             color: var(--accent-color);
             text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
         }

         .button-group {
             display: flex;
             gap: 15px;
             margin-top: 20px;
             flex-wrap: wrap;
             justify-content: center;
         }

         .btn {
             padding: 12px 25px;
             border: none;
             border-radius: 8px;
             background-color: var(--primary-color);
             color: var(--text-color);
             font-size: 1.1em;
             font-weight: bold;
             cursor: pointer;
             transition: all 0.3s ease;
             box-shadow: 0 4px var(--secondary-color);
             transform: translateY(0);
         }

         .btn:hover {
             background-color: #a569bd;
             transform: translateY(-2px);
             box-shadow: 0 6px var(--secondary-color);
         }

         .btn:active {
             transform: translateY(2px);
             box-shadow: 0 2px var(--secondary-color);
         }
         
         .btn.disabled {
             background-color: #7f8c8d;
             cursor: not-allowed;
             box-shadow: 0 4px #616a6b;
             opacity: 0.6;
         }
         
         .btn-small {
             padding: 8px 15px;
             font-size: 0.9em;
         }
         
         .btn-challenge {
            background-color: var(--challenge-color);
            box-shadow: 0 4px #d35400;
         }
         .btn-challenge:hover {
            background-color: #f39c12;
            box-shadow: 0 6px #d35400;
         }


         #character-selection-screen .char-options {
             display: flex;
             gap: 20px;
             margin: 20px 0;
         }
         .char-card {
             background-color: var(--surface-color);
             padding: 15px;
             border-radius: 10px;
             cursor: pointer;
             border: 3px solid transparent;
             transition: all 0.3s ease;
         }
         .char-card.selected {
             border-color: var(--accent-color);
             transform: scale(1.05);
         }
         .char-card img {
             width: 100px;
             height: 100px;
             object-fit: contain;
         }
         .char-card p {
             margin: 5px 0 0;
             font-weight: bold;
         }
         #character-name {
             padding: 10px;
             font-size: 1em;
             border-radius: 5px;
             border: 2px solid var(--primary-color);
             background-color: var(--bg-color);
             color: var(--text-color);
             margin-top: 15px;
             width: 80%;
             max-width: 300px;
             text-align: center;
         }

         #difficulty-selection-screen #difficulty-char-status {
             background-color: rgba(0,0,0,0.2);
             padding: 10px 20px;
             border-radius: 10px;
             border: 2px solid var(--primary-color);
             margin-bottom: 20px;
         }
         #difficulty-selection-screen #difficulty-char-status h3 {
             margin: 0 0 5px 0;
         }
         #difficulty-selection-screen #difficulty-char-status p {
             margin: 0;
             color: #bdc3c7;
         }

         #difficulty-selection-screen .difficulty-option {
             display: flex;
             flex-direction: column;
             align-items: center;
         }
         .difficulty-desc {
             font-size: 0.9em;
             color: #bdc3c7;
             margin-top: 8px;
             max-width: 200px;
         }

         #game-screen {
             justify-content: flex-start;
             padding: 0;
         }
         #status-bar {
             width: 100%;
             padding: 10px 20px;
             background-color: rgba(0,0,0,0.3);
             display: flex;
             justify-content: space-between;
             align-items: center;
             box-sizing: border-box;
             font-size: 1.1em;
             z-index: 10;
             flex-wrap: wrap;
             gap: 10px;
         }
         #status-bar > div {
             display: flex;
             align-items: center;
             gap: 10px;
         }
         #progress-display {
             font-size: 0.9em;
             color: #bdc3c7;
             text-align: center;
             width: 100%;
             order: 2; /* Flexbox order */
         }
         @media (min-width: 768px) {
             #progress-display {
                 width: auto;
                 order: 0;
             }
         }

         #game-canvas {
             position: absolute;
             top: 0;
             left: 0;
             width: 100%;
             height: 100%;
             cursor: pointer;
             z-index: 1;
         }
         
         /* --- UI/Scrollbar Fix --- */
         #quiz-container {
             position: absolute;
             bottom: 0;
             left: 0;
             width: 100%;
             background-color: rgba(44, 42, 74, 0.95);
             padding: 15px;
             box-sizing: border-box;
             border-top: 3px solid var(--primary-color);
             display: none;
             flex-direction: column;
             align-items: center;
             gap: 10px;
             z-index: 10;
             max-height: 60%;
             height: auto;
         }
         #quiz-case {
             font-size: 1.1em;
             line-height: 1.6;
             text-align: left;
             width: 100%;
             padding: 15px;
             background: rgba(0,0,0,0.2);
             border-radius: 8px;
             overflow-y: auto;
             flex-shrink: 1;
             -webkit-overflow-scrolling: touch;
         }
         #q1-options {
             width: 100%;
             display: flex;
             justify-content: center;
             gap: 15px;
             flex-wrap: wrap;
             flex-shrink: 0;
         }
         #q2-options {
             width: 100%;
             display: flex;
             flex-direction: column;
             align-items: center;
             overflow-y: auto;
             flex-grow: 1; /* Take remaining space */
             min-height: 0; /* Important for flex-grow in a flex column */
             padding-right: 10px;
             box-sizing: border-box;
             -webkit-overflow-scrolling: touch;
         }
         /* --- End of UI/Scrollbar Fix --- */

         .quiz-btn {
             width: 45%;
             max-width: 300px;
             padding: 12px;
             font-size: 1em;
         }
         .q2-btn {
              width: 98%;
              max-width: 620px;
              text-align: left;
              font-size: 0.9em;
              padding: 10px;
              flex-shrink: 0;
              margin-bottom: 5px;
         }
         
         .modal-overlay {
             position: absolute;
             top: 0;
             left: 0;
             width: 100%;
             height: 100%;
             background-color: rgba(0,0,0,0.6);
             display: none;
             justify-content: center;
             align-items: center;
             z-index: 99;
             padding: 15px;
             box-sizing: border-box;
         }
         .modal-content {
             background-color: var(--surface-color);
             padding: 30px;
             border-radius: 15px;
             border: 3px solid var(--accent-color);
             box-shadow: 0 0 20px rgba(0,0,0,0.7);
             text-align: center;
             max-width: 90%;
             max-height: 90%;
             overflow-y: auto;
             -webkit-overflow-scrolling: touch;
         }
         #message-text {
             font-size: 1.2em;
             line-height: 1.7;
             margin-bottom: 20px;
             text-align: left;
         }
         #message-text b {
             color: var(--accent-color);
         }
         #message-text .capture-guide {
            font-size: 0.9em;
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid var(--primary-color);
         }
         #message-text .capture-guide h4 {
            color: var(--accent-color);
            margin-bottom: 10px;
         }
         #message-text .capture-guide ul {
            list-style: none;
            padding: 0;
         }
         #message-text .capture-guide li {
            margin-bottom: 8px;
         }

         #instructions-modal .modal-content {
             text-align: left;
         }
         #instructions-modal h3 {
             margin-top: 0;
         }
         #instructions-modal ul {
             padding-left: 20px;
         }
         #instructions-modal li {
             margin-bottom: 10px;
         }
         
         #monster-info-display {
             position: absolute;
             top: 70px; /* status bar height + margin */
             right: 20px;
             background-color: rgba(0,0,0,0.6);
             padding: 10px 15px;
             border-radius: 8px;
             font-size: 1.1em;
             text-align: right;
             z-index: 10;
             display: none;
             border-left: 3px solid var(--danger-color);
         }
         
         #temp-message-overlay {
             position: absolute;
             top: 50%;
             left: 50%;
             transform: translate(-50%, -50%);
             padding: 20px 40px;
             background-color: rgba(0,0,0,0.75);
             color: var(--accent-color);
             font-size: 2em;
             font-weight: bold;
             border-radius: 10px;
             z-index: 110;
             opacity: 0;
             visibility: hidden;
             transition: opacity 0.3s ease, visibility 0.3s ease;
         }
         #temp-message-overlay.visible {
             opacity: 1;
             visibility: visible;
         }
         
         #fixed-buttons-container {
             position: absolute;
             bottom: 15px;
             right: 15px;
             z-index: 120;
         }

         /* Responsive Design */
         @media (max-width: 600px) {
             #start-screen h1 { font-size: 2.2em; }
             .btn { padding: 10px 20px; font-size: 1em; }
             #character-selection-screen .char-options { flex-direction: column; }
             .char-card img { width: 80px; height: 80px; }
             #status-bar { font-size: 0.9em; padding: 8px 15px; }
             #monster-info-display { top: 70px; font-size: 0.9em; }
             #quiz-case { font-size: 1em; }
             .quiz-btn { width: 80%; }
             #temp-message-overlay { font-size: 1.5em; }
         }
     </style>
 </head>
 <body>
     <div id="game-container">
        <!-- 스토리 화면 -->
        <div id="story-screen" class="screen">
            <div class="story-content">
                <h2>🕯️ 지식의 서를 찾아서 🕯️</h2>
                <p>옛 전설에 따르면, 이 세상 모든 법과 지혜가 담긴 ‘지식의 서’는 어둠의 던전에 숨겨져 있다고 한다. 그 서를 지키는 건 형법의 수수께끼를 품은 몬스터들.</p>
                <p>그들은 정의와 논리의 검이 아니면 결코 쓰러뜨릴 수 없다!</p>
                <p>지금 당신은 법의 수호자로 선택받았다. 각 던전의 퀴즈를 풀고, 형법의 지식을 무기로 몬스터를 물리쳐라.</p>
                <p>던전마다 기다리는 강력한 시험을 통과하면, 한 걸음씩 지식의 서에 가까워질 것이다.</p>
                <h3>⚔️ 지금, 정의로운 여정을 시작하라! ⚖️</h3>
                <p class="skip-message">(화면을 클릭하여 계속하기)</p>
            </div>
        </div>

         <!-- 시작 화면 -->
         <div id="start-screen" class="screen">
             <div class="title-container">
                 <h1>Dungeon & Law</h1>
                 <p>범죄의 성립 여부를 퀴즈로 배우는 던전 탐험!</p>
             </div>
             <div class="button-group">
                 <button id="start-new-game-btn" class="btn">새 게임 시작</button>
                 <button id="load-game-btn" class="btn">불러오기</button>
             </div>
         </div>

         <!-- 캐릭터 선택 화면 -->
         <div id="character-selection-screen" class="screen">
             <h2>캐릭터 선택</h2>
             <p>이름을 정하고, 당신의 분신이 될 용사를 선택하세요.</p>
             <input type="text" id="character-name" placeholder="캐릭터 이름 입력" maxlength="10">
             <div class="char-options">
                 <div class="char-card" data-class="전사" data-gender="남">
                     <img src="https://raw.githubusercontent.com/dessa1995/crime/main/mw.png" alt="남자 전사" onerror="this.src='https://placehold.co/100x100/4f4c7a/ecf0f1?text=Warrior'">
                     <p>남자 전사</p>
                 </div>
                 <div class="char-card" data-class="전사" data-gender="여">
                     <img src="https://raw.githubusercontent.com/dessa1995/crime/main/fw.png" alt="여자 전사" onerror="this.src='https://placehold.co/100x100/4f4c7a/ecf0f1?text=Warrior'">
                     <p>여자 전사</p>
                 </div>
                 <div class="char-card" data-class="마법사" data-gender="남">
                     <img src="https://raw.githubusercontent.com/dessa1995/crime/main/mm.png" alt="남자 마법사" onerror="this.src='https://placehold.co/100x100/4f4c7a/ecf0f1?text=Mage'">
                     <p>남자 마법사</p>
                 </div>
                 <div class="char-card" data-class="마법사" data-gender="여">
                     <img src="https://raw.githubusercontent.com/dessa1995/crime/main/fm.png" alt="여자 마법사" onerror="this.src='https://placehold.co/100x100/4f4c7a/ecf0f1?text=Mage'">
                     <p>여자 마법사</p>
                 </div>
             </div>
             <button id="confirm-character-btn" class="btn">선택 완료</button>
         </div>
         
         <!-- 난이도 선택 화면 -->
         <div id="difficulty-selection-screen" class="screen">
             <div id="difficulty-char-status"></div>
             <h2>난이도 선택</h2>
             <div class="button-group" id="difficulty-options">
                 <div class="difficulty-option">
                     <button class="btn difficulty-btn" data-difficulty="하">하</button>
                     <p class="difficulty-desc">5문제 정답 시 보스 등장</p>
                 </div>
                 <div class="difficulty-option">
                     <button class="btn difficulty-btn" data-difficulty="중">중</button>
                     <p class="difficulty-desc">8문제 정답 시 보스 등장</p>
                 </div>
                 <div class="difficulty-option">
                     <button class="btn difficulty-btn" data-difficulty="상">상</button>
                     <p class="difficulty-desc">10문제 정답 시 보스 등장</p>
                 </div>
             </div>
              <div class="button-group">
                   <button id="save-game-btn" class="btn">게임 저장</button>
                   <button id="change-character-btn" class="btn">캐릭터 변경</button>
             </div>
         </div>

         <!-- 메인 게임 화면 -->
         <div id="game-screen" class="screen">
             <div id="status-bar">
                 <div id="player-info-left">
                     <span id="status-name"></span> | LV.<span id="status-level"></span>
                 </div>
                 <div id="progress-display"></div>
                 <div id="player-info-right">
                     <span>목숨:</span>
                     <span id="status-lives"></span>
                     <button id="back-to-difficulty-btn" class="btn btn-small">메인으로</button>
                 </div>
             </div>
             <div id="monster-info-display"></div>
             <div id="temp-message-overlay"></div>
             <canvas id="game-canvas"></canvas>
             <div id="quiz-container">
                 <div id="quiz-case"></div>
                 <div id="q1-options">
                     <button class="btn quiz-btn" data-answer="O">O (맞다)</button>
                     <button class="btn quiz-btn" data-answer="X">X (틀리다)</button>
                 </div>
                 <div id="q2-options" style="display: none;">
                     <!-- 4지선다 버튼은 동적으로 생성됩니다. -->
                 </div>
             </div>
         </div>
         
         <!-- 메시지 모달 -->
         <div id="message-modal" class="modal-overlay">
             <div class="modal-content">
                 <p id="message-text"></p>
                 <button id="message-ok-btn" class="btn">확인</button>
             </div>
         </div>
         
         <!-- 게임 설명 모달 -->
         <div id="instructions-modal" class="modal-overlay">
             <div class="modal-content">
                 <h3>게임 설명</h3>
                 <ul>
                     <li><strong>목표:</strong> 형법 퀴즈를 풀어 몬스터를 물리치고 던전을 클리어하세요!</li>
                     <li><strong>게임 흐름:</strong>
                         <ol>
                             <li>캐릭터 생성 후, 원하는 난이도를 선택하여 게임을 시작합니다.</li>
                             <li>몬스터가 등장하면 퀴즈가 출제됩니다.</li>
                             <li>퀴즈를 맞혀야 몬스터에게 데미지를 줄 수 있습니다.</li>
                             <li>틀리면 목숨이 1개 줄어듭니다. 목숨이 0이 되면 게임 오버!</li>
                             <li>난이도별 정답 수를 채우면 강력한 보스가 등장합니다.</li>
                         </ol>
                     </li>
                     <li><strong>레벨업:</strong> 각 난이도의 보스를 물리칠 때마다 레벨이 오르며, 공격 이펙트가 화려해집니다.</li>
                     <li><strong>도전자 모드:</strong> 모든 난이도를 클리어하면 '도전자' 모드가 해금됩니다. 이 모드에서는 3개의 목숨으로 최대한 높은 점수를 기록하는 것에 도전합니다!</li>
                     <li><strong>저장/불러오기:</strong> '게임 저장' 또는 '메인으로' 버튼으로 현재 레벨과 클리어 정보를 저장할 수 있습니다. 메인 화면의 '불러오기'로 이어할 수 있습니다.</li>
                 </ul>
                 <button id="instructions-close-btn" class="btn">닫기</button>
             </div>
         </div>

         <div id="fixed-buttons-container">
             <button id="instructions-btn" class="btn btn-small">게임 설명</button>
         </div>

         <!-- 오디오 태그 -->
         <audio id="bgm-audio" src="https://raw.githubusercontent.com/dessa1995/crime/main/bbgm.mp3" loop></audio>

     </div>

     <script>
         // 전역 변수 및 DOM 요소
         const gameContainer = document.getElementById('game-container');
         const screens = document.querySelectorAll('.screen');
         const canvas = document.getElementById('game-canvas');
         const ctx = canvas.getContext('2d');
         
         const quizContainer = document.getElementById('quiz-container');
         const quizCaseEl = document.getElementById('quiz-case');
         const q1OptionsEl = document.getElementById('q1-options');
         const q2OptionsEl = document.getElementById('q2-options');

         const messageModal = document.getElementById('message-modal');
         const messageText = document.getElementById('message-text');
         let messageOkBtn = document.getElementById('message-ok-btn');
         const monsterInfoDisplay = document.getElementById('monster-info-display');
         const tempMessageOverlay = document.getElementById('temp-message-overlay');
         const bgmAudioElement = document.getElementById('bgm-audio');
         const progressDisplay = document.getElementById('progress-display');

         let audioContext;
         let bgmSource;
         let bgmBuffer;
         let isAudioReady = false;

         const assets = {
             bgm: 'https://raw.githubusercontent.com/dessa1995/crime/main/bbgm.mp3',
             monsters: {
                 '하': 'https://raw.githubusercontent.com/dessa1995/crime/main/monster1.png',
                 '중': 'https://raw.githubusercontent.com/dessa1995/crime/main/monster2.png',
                 '상': 'https://raw.githubusercontent.com/dessa1995/crime/main/monster3.png',
                 '보스': 'https://raw.githubusercontent.com/dessa1995/crime/main/monster4.png'
             },
             characters: {
                 '전사_남': 'https://raw.githubusercontent.com/dessa1995/crime/main/mw.png',
                 '전사_여': 'https://raw.githubusercontent.com/dessa1995/crime/main/fw.png',
                 '마법사_남': 'https://raw.githubusercontent.com/dessa1995/crime/main/mm.png',
                 '마법사_여': 'https://raw.githubusercontent.com/dessa1995/crime/main/fm.png'
             },
             misc: {
                'book': 'https://raw.githubusercontent.com/dessa1995/crime/main/book.png'
             }
         };
         const loadedImages = {};

         let gameState = {};
         let dungeonPillars = [];
         let effectParticles = [];

         // 퀴즈 데이터 (발문 수정)
         const quizzes = [
            // 난이도 하 (O/X)
            { id: 101, type: 'one-step-ox', difficulty: '하', case: "형법은 범죄와 그에 대한 법적 효과로서 형벌과 보안 처분을 규정한 모든 법 규범을 의미한다.", q1: 'O', explanation: "형법은 넓은 의미에서 범죄와 그에 대한 법적 효과로서 형벌과 보안 처분을 규정한 모든 법 규범의 총체를 의미한다." },
            { id: 102, type: 'one-step-ox', difficulty: '하', case: "형식적 의미의 형법은 ‘형법’이라는 명칭이 붙여진 법률만을 의미한다.", q1: 'O', explanation: "형식적 의미의 형법은 단순히 '형법'이라는 이름의 법률을 지칭한다." },
            { id: 103, type: 'one-step-ox', difficulty: '하', case: "형법의 보장적 기능은 국가 형벌권의 자의적 행사로부터 국민의 자유와 권리를 보장한다.", q1: 'O', explanation: "형법은 형법에 규정되지 아니한 행위는 범죄가 되지 않고 처벌받지 않도록 보장하며, 규정된 형벌의 종류와 양을 넘어서서 처벌받지 않도록 함으로써 국가 형벌권으로부터 국민의 자유와 권리를 보장하는 보장적 기능을 수행한다." },
            { id: 104, type: 'one-step-ox', difficulty: '하', case: "「도로교통법」에 규정된 벌칙 조항은 실질적 의미의 형법에 해당하지 않는다.", q1: 'X', explanation: "「도로교통법」과 같이 법의 명칭이나 형식을 불문하고 범죄와 그에 대한 법적 효과로서 형벌과 보안 처분을 규정한 모든 법 규범은 실질적 의미의 형법에 해당한다." },
            { id: 105, type: 'one-step-ox', difficulty: '하', case: "죄형 법정주의는 미리 성문의 법률에 규정되어 있지 않은 행위에 대해서도 처벌을 가능하게 하는 원칙이다.", q1: 'X', explanation: "죄형 법정주의는 어떠한 행위가 범죄이고 그 범죄를 어떻게 처벌할 것인지 미리 성문의 법률로 규정되어야 한다는 원칙이다." },
            { id: 106, type: 'one-step-ox', difficulty: '하', case: "관습 형법 금지의 원칙에 따라 불문법인 관습법을 근거로 처벌할 수 없다.", q1: 'O', explanation: "관습 형법 금지의 원칙은 의회에서 제정한 성문법이 아닌 불문법인 관습법을 근거로는 처벌할 수 없다는 원칙이다." },
            { id: 107, type: 'one-step-ox', difficulty: '하', case: "소급효 금지의 원칙은 행위자에게 불리한 소급효만 허용하지 않고, 행위자에게 유리한 소급효는 허용한다.", q1: 'O', explanation: "소급효 금지의 원칙은 범죄와 형벌이 행위 당시 법률에 규정되어 있어야 하며, 행위 이후에 제정한 법률로는 소급하여 처벌할 수 없다는 것을 의미하지만, 행위자에게 유리한 소급효는 예외적으로 허용된다." },
            { id: 108, type: 'one-step-ox', difficulty: '하', case: "명확성의 원칙은 범죄의 구성 요건과 형벌이 불명확하게 규정되어도 무방하다고 본다.", q1: 'X', explanation: "명확성의 원칙은 법률이 처벌하고자 하는 행위가 무엇이며 그에 대해 어떤 형벌이 부과되는지를 누구나 예견할 수 있도록 범죄의 구성 요건과 형벌을 명확하게 규정하여야 한다는 원칙이다." },
            { id: 109, type: 'one-step-ox', difficulty: '하', case: "유추 해석 금지의 원칙은 법률에 규정이 없는 사항에 대해 유사한 성질의 법률을 적용하여 행위자에게 불리한 새로운 구성 요건을 만들 수 없다는 원칙이다.", q1: 'O', explanation: "유추 해석 금지의 원칙은 범죄 행위가 형법에 명확히 규정되어 있지 않은 때에 유사한 규정을 적용해서는 행위자에게 불리하게 적용해서는 안 된다는 원칙이다." },
            { id: 110, type: 'one-step-ox', difficulty: '하', case: "적정성의 원칙은 범죄가 되는 행위와 그에 따른 형벌의 질과 양이 비례해야 한다는 원칙이다.", q1: 'O', explanation: "적정성의 원칙은 범죄가 되는 행위와 그에 따른 형벌의 질과 양이 비례하여야 한다는 원칙으로, 비례성의 원칙 또는 과잉 금지의 원칙이라고도 한다." },
            { id: 111, type: 'one-step-ox', difficulty: '하', case: "범죄의 3단계 성립 요건은 구성 요건 해당성, 위법성, 책임이다.", q1: 'O', explanation: "범죄가 성립하기 위해서는 구성 요건 해당성, 위법성, 책임이라는 세 가지 요건이 충족되어야 한다." },
            { id: 112, type: 'one-step-ox', difficulty: '하', case: "위법성 조각 사유는 구성 요건에 해당하는 행위의 위법성을 배제하는 특별한 사유이다.", q1: 'O', explanation: "위법성 조각 사유는 구성 요건에 해당하는 행위의 위법성을 배제하는 특별한 사유이다." },
            { id: 113, type: 'one-step-ox', difficulty: '하', case: "정당방위는 현재의 부당한 법익 침해로부터 자신이나 타인의 법익을 방위하기 위한 상당한 이유가 있는 행위이다.", q1: 'O', explanation: "정당방위는 자기 또는 타인의 법익에 대한 현재의 부당한 침해를 방위하기 위한 상당한 이유가 있는 행위이다." },
            { id: 114, type: 'one-step-ox', difficulty: '하', case: "긴급 피난은 자기 또는 타인의 법익에 대한 현재의 위난을 피하기 위한 행위로 상당한 이유가 있는 경우에 해당한다.", q1: 'O', explanation: "긴급 피난은 자기 또는 타인의 법익에 대한 현재의 위난을 피하기 위한 행위로 상당한 이유가 있는 경우이다." },
            { id: 115, type: 'one-step-ox', difficulty: '하', case: "14세 미만인 사람의 행위는 책임 조각 사유에 해당한다.", q1: 'O', explanation: "14세 미만인 사람의 행위는 책임 조각 사유에 해당하여 범죄가 성립하지 않는다." },
            { id: 116, type: 'one-step-ox', difficulty: '하', case: "형벌은 국가가 범죄 행위를 저지른 사람에게 가하는 법익 박탈로서의 제재이다.", q1: 'O', explanation: "형벌은 국가가 범죄 행위를 저지른 사람에게 가하는 제재로, 법익의 박탈을 내용으로 한다." },
            { id: 117, type: 'one-step-ox', difficulty: '하', case: "사형은 생명을 빼앗는 형벌에 해당한다.", q1: 'O', explanation: "사형은 생명을 빼앗는 생명형에 해당한다." },
            { id: 118, type: 'one-step-ox', difficulty: '하', case: "보호 관찰은 교정 시설에 수용하지 않고 사회생활을 허용하면서 보호 관찰관의 지도·감독을 받는 보안 처분이다.", q1: 'O', explanation: "보호 관찰은 형의 집행 유예나 선고 유예를 받거나 가석방되는 경우 등을 대상으로 교정 시설에 수용하지 않고 사회생활을 허용하면서 보호 관찰관의 지도·감독을 통해 사회 복귀를 촉진하는 제도이다." },
            { id: 119, type: 'one-step-ox', difficulty: '하', case: "형사 절차에서 피의자와 피고인은 자신에게 불리한 진술을 거부할 수 있는 진술 거부권을 가진다.", q1: 'O', explanation: "모든 형사 절차에서 피의자와 피고인은 자신에게 불리한 진술을 거부할 수 있는 진술 거부권을 가진다." },
            { id: 120, type: 'one-step-ox', difficulty: '하', case: "재심 제도는 유죄 확정 판결에 중대한 사실 오인이 있는 경우 그 오류를 시정하여 무고한 자의 이익을 구제하는 제도이다.", q1: 'O', explanation: "재심 제도는 유죄의 확정 판결에 중대한 사실 오인이 있는 경우 그 오류를 시정하여 무고한 자의 이익을 구제하여 주는 제도이다." },
            // 난이도 중 (4지선다)
            { id: 201, type: 'single', difficulty: '중', case: "다음 중 형법의 보충성 원칙을 가장 잘 설명하는 것은?", q2: ["형법은 사회 윤리적 행위 가치를 보호하는 기능을 한다.", "형법은 국가 형벌권 남용으로부터 국민의 자유와 권리를 보장한다.", "법익을 보호하기 위해 다른 수단이 있다면 그것을 먼저 행사하고 형법은 가장 마지막 수단으로 발동되어야 한다.", "형법은 범죄 행위로 인해 얻는 이익과 형벌이라는 불이익을 통해 국민이 자신의 행위를 결정하게 하는 역할을 한다."], answerIndex: 2, explanation: "형법의 보충성 또는 최후 수단성은 형벌이 국가의 가장 강력한 물리력 행사로서, 그러한 법익을 보호하기 위한 다른 수단이 있다면 그것을 먼저 행사하고 형법은 가장 마지막 수단으로 발동되어야 함을 의미한다." },
            { id: 202, type: 'single', difficulty: '중', case: "다음 중 죄형 법정주의의 파생 원칙인 소급효 금지의 원칙에 대한 설명으로 옳지 않은 것은?", q2: ["범죄와 형벌은 행위 당시 법률에 규정되어 있어야 한다.", "행위 이후에 제정된 법률로는 소급하여 처벌할 수 없다.", "행위자에게 불리한 경우에도 소급효가 허용된다.", "재판 시의 법이 행위 시의 법보다 경할 때에는 재판 시의 법을 적용한다."], answerIndex: 2, explanation: "소급효 금지의 원칙은 행위자에게 불리한 소급효를 금지하는 것이 원칙이다. 다만, 행위자에게 유리한 소급효는 예외적으로 허용된다. 따라서 행위자에게 불리한 경우에도 소급효가 허용된다는 설명은 옳지 않다." },
            { id: 203, type: 'single', difficulty: '중', case: "다음 중 유추 해석 금지의 원칙에 위배되는 사례는?", q2: ["법에 규정된 '상해'에 '정신적 고통'을 포함하여 해석하더라도 행위자에게 불리하지 않은 경우", "형법에 명시된 '절도'에 '컴퓨터를 이용한 정보 탈취'를 포함하는 새로운 범죄 유형을 법률로 명확히 규정한 경우", "명확하지 않은 조항을 입법 취지에 맞게 합리적으로 해석하여 적용한 경우", "범죄 행위가 유사하지만 형법에 명확히 규정되어 있지 않은 때에 유사한 규정을 적용하여 행위자에게 불리하게 형을 가중한 경우"], answerIndex: 3, explanation: "유추 해석 금지의 원칙은 법률에 규정이 없는 사항에 대해 유사한 성질의 법률을 적용하여 행위자에게 불리한 새로운 구성 요건을 만들거나 형을 가중할 수 없다는 원칙이다. ①과 ③은 허용될 수 있는 법 해석이며, ②는 새로운 법률 제정의 문제이다." },
            { id: 204, type: 'single', difficulty: '중', case: "다음 중 범죄의 3단계 성립 요건에 해당하지 않는 것은?", q2: ["구성 요건 해당성", "위법성", "책임", "도덕적 비난 가능성"], answerIndex: 3, explanation: "범죄의 3단계 성립 요건은 구성 요건 해당성, 위법성, 책임이다. 도덕적 비난 가능성은 범죄의 성립 요건에 직접 해당하지 않는다." },
            { id: 205, type: 'single', difficulty: '중', case: "甲은 자신의 집 마당에서 삽으로 땅을 파던 중 실수로 이웃집의 수도관을 파손시켰다. 이 경우 甲의 행위에 대한 형법상 처벌 가능성은? (단, 甲에게 고의는 없었으며, 과실에 의한 수도관 파손에 대한 특별한 처벌 규정은 없다고 가정한다.)", q2: ["甲은 재물 손괴죄로 처벌받는다.", "甲은 과실에 의한 재물 손괴죄로 처벌받는다.", "甲은 형법상 재물 손괴죄의 구성 요건에 해당하지 않아 처벌받지 않는다.", "甲은 민사상 손해 배상 책임만 지고 형사 처벌은 받지 않는다."], answerIndex: 2, explanation: "형법은 고의범을 처벌하는 것을 원칙으로 하며, 예외적으로 과실범을 처벌하는 규정이 있는 경우에만 처벌한다. 과실에 의한 재물 손괴에 대한 처벌 규정이 없다면, 甲에게 고의가 없으므로 형법상 구성 요건에 해당하지 않아 처벌받지 않는다. (참고: 민사상 손해배상 책임은 별개로 발생할 수 있으나, 이 문제는 형법상 처벌 가능성을 묻고 있다.)" },
            { id: 206, type: 'single', difficulty: '중', case: "다음 중 위법성 조각 사유에 해당하지 않는 것은?", q2: ["정당방위", "긴급 피난", "강요된 행위", "자구 행위"], answerIndex: 2, explanation: "강요된 행위는 책임 조각 사유에 해당한다. 정당방위, 긴급 피난, 자구 행위는 위법성 조각 사유에 해당한다." },
            { id: 207, type: 'single', difficulty: '중', case: "형벌의 종류 중 신체의 자유를 빼앗는 자유형에 해당하지 않는 것은?", q2: ["징역", "금고", "구류", "자격 상실"], answerIndex: 3, explanation: "징역, 금고, 구류는 신체의 자유를 빼앗는 자유형에 해당한다. 자격 상실은 명예형에 해당한다." },
            { id: 208, type: 'single', difficulty: '중', case: "다음 중 보안 처분의 특징으로 옳지 않은 것은?", q2: ["범죄자의 재사회화를 위한 대안적 제재 수단이다.", "과거의 불법에 대한 책임을 전제로 한다.", "장래의 위험성으로부터 행위자를 보호하고 사회를 방위하기 위한 예방적 조치이다.", "부과 요건이나 절차 등에 있어서 적법 절차의 원리가 준수되어야 한다."], answerIndex: 1, explanation: "보안 처분은 과거의 불법에 대한 책임을 전제로 하는 형벌과 달리, 장래의 위험성으로부터 행위자를 보호하고 사회를 방위하기 위한 합목적적인 예방적 조치이다." },
            { id: 209, type: 'single', difficulty: '중', case: "형사 절차의 진행 순서로 가장 적절한 것은?", q2: ["공판 절차 → 수사 절차 → 형 집행 절차", "수사 절차 → 공판 절차 → 형 집행 절차", "형 집행 절차 → 수사 절차 → 공판 절차", "수사 절차 → 형 집행 절차 → 공판 절차"], answerIndex: 1, explanation: "형사 절차는 범죄가 발생하였을 때 이를 수사·심판하고 선고된 형을 집행하는 과정으로, 수사 절차 → 공판 절차 → 형 집행 절차의 순서로 진행된다." },
            { id: 210, type: 'single', difficulty: '중', case: "검사의 불기소 처분 중 피의 사실은 인정되나 피의자의 연령이나 지능, 피해자와의 관계, 범행의 동기나 수단, 범행의 결과 등을 참작하여 소추할 필요가 없는 경우는?", q2: ["기소 유예", "혐의 없음", "죄가 안 됨", "공소권 없음"], answerIndex: 0, explanation: "기소 유예는 피의 사실이 인정되나 피의자의 제반 사정을 참작하여 소추할 필요가 없는 경우 검사가 공소를 제기하지 않는 불기소 처분이다." },
            { id: 211, type: 'single', difficulty: '중', case: "법원이 피고인의 유죄를 인정하면서도 정상을 참작하여 형의 선고를 미루는 것으로, 유예된 날로부터 일정 기간을 경과하면 형의 선고가 없었던 것으로 간주되는 것은?", q2: ["실형", "집행 유예", "선고 유예", "가석방"], answerIndex: 2, explanation: "선고 유예는 형의 선고 자체를 미루었다가 2년이 지나면 형의 선고가 없었던 것으로 간주하는 제도이다." },
            { id: 212, type: 'single', difficulty: '중', case: "우리나라의 국민 참여 재판에 대한 설명으로 옳은 것은?", q2: ["배심원의 평결은 법원을 기속한다.", "모든 형사 재판에 의무적으로 적용된다.", "배심원은 직업 법관과 동등한 권한으로 사실 문제 및 법률 문제를 판단한다.", "배심원은 양형에 관한 의견을 밝힐 수 있으나, 양형 결정에 직접 참여하여 표결하는 것은 아니다."], answerIndex: 3, explanation: "우리나라 국민 참여 재판에서 배심원의 평결은 법원을 기속하지 않고 권고적 효력만을 가지며, 양형에 관하여 의견을 밝힐 수 있으나 표결을 통해 양형 결정에 참여하는 것은 아니다." },
            { id: 213, type: 'single', difficulty: '중', case: "형사 절차상 인권 보장을 위한 원칙 중 '유죄 판결이 확정될 때까지 무죄로 추정한다'는 원칙은?", q2: ["적법 절차의 원칙", "진술 거부권", "변호인의 조력을 받을 권리", "무죄 추정의 원칙"], answerIndex: 3, explanation: "유죄 판결이 확정될 때까지 피의자나 피고인을 무죄로 추정하는 원칙은 무죄 추정의 원칙이다." },
            { id: 214, type: 'single', difficulty: '중', case: "위법 수집 증거 배제 법칙의 내용으로 옳은 것은?", q2: ["고문, 폭행 등으로 임의로 진술한 것이 아니라고 의심되는 자백은 증거 능력이 없다.", "자백이 불이익한 유일한 증거인 때에는 유죄의 증거로 할 수 없다.", "위법한 절차에 의하여 수집된 증거는 증거 능력이 없다.", "경험한 사실을 경험자가 직접 구두로 법원에 보고하지 않은 간접 증거는 원칙적으로 증거 능력이 없다."], answerIndex: 2, explanation: "위법 수집 증거 배제 법칙은 위법한 절차에 의해 수집된 증거는 증거 능력이 없다는 원칙이다. ①은 자백 배제 법칙, ②는 자백 보강 법칙, ④는 전문 법칙에 해당한다." },
            { id: 215, type: 'single', difficulty: '중', case: "범죄 피해자가 가해자에게 신속하고 간편하게 손해 배상을 받을 수 있도록 하는 제도는?", q2: ["범죄 피해자 구조 제도", "배상 명령 제도", "형사 보상 제도", "명예 회복 제도"], answerIndex: 1, explanation: "배상 명령 제도는 범죄 피해자가 가해자에게 신속하고 간편하게 손해 배상을 받을 수 있도록 하는 제도이다." },
            // 난이도 상 (2단계)
            { id: 301, type: 'two-step', difficulty: '상', case: "형법의 규범적 기능은 국민에게 행위의 준칙으로 삼도록 하고, 법관에게는 범죄 성립 여부를 판단하는 평가 규범으로서의 역할을 한다.", q1: 'O', q2_question: "다음은 어떤 사람이 법정에서 '범죄인 줄 몰랐다'고 주장했으나 처벌받은 사례입니다. 이 사례를 통해 알 수 있는 형법의 기능으로 가장 적절한 것은?", q2: ["보호적 기능", "보장적 기능", "규범적 기능", "보충적 기능"], answerIndex: 2, explanation: "이 사례는 형법이 '빈집에 침입하여 물건을 훔치는 행위'를 금지함으로써 국민에게 지켜야 할 행위의 준칙을 제시하고, 이를 위반했을 때 처벌을 통해 법관의 판단 기준을 제공한다는 것을 보여준다. 이는 형법의 규범적 기능에 해당한다." },
            { id: 302, type: 'two-step', difficulty: '상', case: "형식적 죄형 법정주의는 법률의 내용을 문제 삼지 않기 때문에 부당한 법률에 의한 형벌권 남용의 우려가 있다.", q1: 'O', q2_question: "다음은 '음란물'의 개념이 명확하지 않아 무죄가 선고된 사례입니다. 이 사례가 보여주는 죄형 법정주의의 원칙은 무엇입니까?", q2: ["관습 형법 금지의 원칙", "소급효 금지의 원칙", "명확성의 원칙", "유추 해석 금지의 원칙"], answerIndex: 2, explanation: "'음란물의 개념이 명확히 규정되지 않아 법 적용에 혼란이 있었다'는 점에서, 처벌하고자 하는 행위가 무엇인지 법률에 명확히 기재되어 있어야 한다는 명확성의 원칙에 위배되는 상황이다." },
            { id: 303, type: 'two-step', difficulty: '상', case: "어떤 행위가 범죄로 성립하기 위해서는 고의가 필수적이며, 과실에 의한 행위는 어떤 경우에도 범죄가 되지 않는다.", q1: 'X', q2_question: "다음 중 범죄의 구성 요건 해당성이 충족되지 않는 사례를 고르시오. (단, 특별한 처벌 규정이 없는 경우를 전제로 한다.)", q2: ["타인의 물건을 훔치려는 의도로 가져왔으나 알고 보니 자신의 물건이었던 경우", "실수로 타인의 물건을 파손하였으나, 그 파손 행위에 대한 과실범 처벌 규정이 없는 경우", "법률로 금지된 행위임을 알면서도 이를 저지른 경우", "금전적 이득을 목적으로 타인을 속여 재물을 편취한 경우"], answerIndex: 1, explanation: "형법은 고의범을 처벌하는 것을 원칙으로 하지만, 예외적으로 과실범을 처벌하는 규정도 있다. 실수로 타인의 물건을 파손한 행위는 과실에 의한 행위이며, 과실범 처벌 규정이 없다면 구성 요건에 해당하지 않아 범죄가 성립하지 않는다." },
            { id: 304, type: 'two-step', difficulty: '상', case: "피해자의 승낙이 있다면 어떠한 경우에도 해당 행위의 위법성은 조각되어 범죄가 성립하지 않는다.", q1: 'X', q2_question: "다음 중 피해자의 승낙이 있었음에도 불구하고 위법성이 조각되지 않아 범죄가 성립하는 경우는?", q2: ["병원에서 의사가 환자의 동의를 얻어 수술을 진행하다가 환자에게 상해를 입힌 경우", "채무자가 자신의 신체 일부를 떼어주는 것에 동의했지만, 채권자가 실제로 그 신체 일부를 취득한 경우 (셰익스피어의 '베니스의 상인' 사례)", "산에 조난되어 죽어가는 사람을 구하기 위해 타인의 오두막에 침입하여 식량을 취한 경우", "15세 미성년자가 자신에게 성적 행위를 하는 것에 동의하였으나, 그 행위가 미성년자 대상 범죄로 규정된 경우"], answerIndex: 1, explanation: "피해자의 승낙이 있어도 채무자의 신체의 일부를 대가로 하려고 하는 경우 등 그 행위가 사회 상규에 위배될 때에는 위법성이 조각되지 않고 범죄가 성립한다. 셰익스피어의 '베니스의 상인' 사례가 그 예이다." },
            { id: 305, type: 'two-step', difficulty: '상', case: "형벌의 종류 중 재산형에는 벌금, 과료, 몰수가 포함된다.", q1: 'O', q2_question: "다음 중 재산형에 해당하지 않는 형벌은?", q2: ["벌금 5,000만 원", "과료 30,000원", "몰수", "자격 정지 1년"], answerIndex: 3, explanation: "자격 정지는 공무원이 될 수 있는 자격 등을 일시적으로 정지하는 명예형에 해당한다." },
            { id: 306, type: 'two-step', difficulty: '상', case: "소년 보호 처분에는 보호 관찰, 소년원 송치 등이 포함되며, 이는 형벌이 아닌 보호 처분의 일종이다.", q1: 'O', q2_question: "다음 중 「소년법」상 소년에게 사형 또는 무기형이 선고될 경우 적용되는 특칙은?", q2: ["사형 또는 무기형이 그대로 집행된다.", "사형 또는 무기형 대신 15년의 유기 징역으로 한다.", "23세가 될 때까지 소년 교도소에 수용된다.", "소년 보호 처분으로 소년원에 송치된다."], answerIndex: 1, explanation: "죄를 범할 당시 18세 미만인 소년에 대하여 사형 또는 무기형으로 처할 때에는 15년의 유기 징역으로 한다." },
            { id: 307, type: 'two-step', difficulty: '상', case: "기소 독점주의는 검사만이 공소 제기를 할 수 있도록 하는 제도이다.", q1: 'O', q2_question: "검사의 불기소 처분에 불복하여 재판을 요청하고자 할 때 활용할 수 있는 제도는 무엇입니까?", q2: ["배상 명령 제도", "재정 신청 제도", "형사 보상 제도", "국민 참여 재판"], answerIndex: 1, explanation: "검사가 불기소 처분을 하여 억울한 범죄 피해자가 발생할 수 있는데, 이러한 사람들을 구제하기 위한 제도가 재정 신청 제도이다. 재정 신청이 이유 있다고 판단되면 고등 법원은 검사에게 공소 제기 결정을 내린다." },
            { id: 308, type: 'two-step', difficulty: '상', case: "형사 재판에서 법관은 양심에 따라 선고하지만, 반드시 증거를 통해서만 재판을 할 수 없다.", q1: 'X', q2_question: "다음 중 형사 절차상 증거와 관련된 원칙으로 옳지 않은 것은?", q2: ["증거 재판주의: 사실의 인정은 증거에 의하여야 한다.", "자백 배제 법칙: 고문, 폭행 등으로 임의로 진술한 것이 아니라고 의심되는 자백도 증거로 사용할 수 있다.", "독수독과의 원칙: 위법하게 수집된 증거에 의하여 발견된 제2차의 증거도 증거 능력이 없다.", "자백 보강 법칙: 자백이 불이익한 유일한 증거인 때에는 유죄의 증거로 할 수 없다."], answerIndex: 1, explanation: "자백 배제 법칙에 따르면, 자백이 고문, 폭행, 협박 등의 방법으로 임의로 진술한 것이 아니라고 의심할 만한 이유가 있는 때에는 증거로 사용할 수 없다. 따라서 '증거로 사용할 수 있다'는 설명은 옳지 않다." },
            { id: 309, type: 'two-step', difficulty: '상', case: "피의자나 피고인이 구속 상태에서 재판을 받는 것은 원칙적인 형사 절차이다.", q1: 'X', q2_question: "다음 중 수사 단계에서 피의자의 인권 보장을 위한 제도가 아닌 것은?", q2: ["불구속 수사 원칙", "영장주의", "구속 적부심 제도", "보석 제도"], answerIndex: 3, explanation: "보석 제도는 공판 단계에서 구속 기소된 피고인이 보석금을 납부하고 석방될 수 있는 제도로, 수사 단계의 피의자에게는 적용되지 않는다." },
            { id: 310, type: 'two-step', difficulty: '상', case: "형벌의 계산법 중, 사형이나 무기형 이외의 같은 종류의 형은 가장 중한 죄에 정한 장기 또는 다액의 2분의 1까지 가중하는 방식을 흡수주의라고 한다.", q1: 'X', q2_question: "甲은 특수 절도죄(법정 최고 징역 5년)와 사기죄(법정 최고 징역 3년)를 저질렀다. 우리나라 형법의 계산법에 따라 甲이 받을 수 있는 최대 형량은? (단, 다른 감경/가중 사유는 없다고 가정한다.)", q2: ["5년", "7년 6개월", "8년", "50년"], answerIndex: 1, explanation: "사형/무기형 외의 같은 종류의 형은 가장 중한 죄에 정한 형의 1/2까지 가중하는 '가중주의'를 따른다. 따라서 5년 + (5년의 1/2) = 7년 6개월이 최대 형량이 된다." },
            // 난이도 최상 (2단계)
            { id: 401, type: 'two-step', difficulty: '최상', case: "오늘날 강조되는 실질적 죄형 법정주의는 입법자가 부당한 법률을 제정하는 것까지도 제한하여 국민의 자유와 권리를 보호하고자 한다.", q1: 'O', q2_question: "다음은 조선시대 형벌에 대한 설명입니다. 이를 통해 알 수 있는 현대적 죄형 법정주의 원칙의 중요성은 무엇입니까? <br>\"조선시대에는 성문법 외에 정령이나 사회 통념에 따라 형벌이 부과되기도 했다.\"", q2: ["예측 가능하고 명확한 법률의 중요성", "형벌과 범죄의 비례성 원칙의 중요성", "행위 당시의 법률을 적용하는 행위시법주의의 중요성", "국가 형벌권 남용을 막기 위한 적법 절차의 원칙의 중요성"], answerIndex: 0, explanation: "조선시대의 사례는 성문법 외의 기준으로 형벌이 부과될 수 있었음을 보여준다. 이는 국민이 어떤 행위가 처벌 대상이 되는지 예측할 수 있도록 법률이 명확해야 한다는 현대의 명확성의 원칙과 관습 형법 금지의 원칙의 중요성을 부각시킨다." },
            { id: 402, type: 'two-step', difficulty: '최상', case: "보호 관찰은 형벌이 아니므로 행위 이전에 반드시 규정되어 있어야 하는 것은 아니며, 재판 시의 규정에 따라 명할 수 있다.", q1: 'O', q2_question: "다음 중 형벌에 대한 설명으로 옳은 것을 고르시오.", q2: ["징역형은 재산형에 해당한다.", "벌금형은 일정 기간 신체의 자유를 박탈하는 형벌이다.", "보안 처분은 범죄자의 사회적 위험성을 전제로 특별 예방의 관점에서 부과된다.", "사형은 무기 징역형보다 범죄자에 대한 법익 침해의 정도가 작다."], answerIndex: 2, explanation: "보안 처분은 행위자의 사회적 위험성과 재범의 우려를 전제로 특별 예방의 관점에서 부과된다. ① 징역형은 자유형, ② 벌금형은 재산형, ④ 사형은 가장 큰 법익 침해를 가하는 형벌이다." },
            { id: 403, type: 'two-step', difficulty: '최상', case: "형사 절차에서 유죄 판결이 확정되기 전까지는 피의자와 피고인을 무죄로 추정하는 것이 원칙이다.", q1: 'O', q2_question: "다음 중 무죄 추정의 원칙이 적용된 것으로 볼 수 없는 상황은?", q2: ["언론이 피의자에 대해 '범죄자'라는 표현을 사용하지 않고 '피의자' 또는 '혐의자'로 보도하는 것", "학교 폭력 가해자로 지목된 학생에 대해 징계 심의 절차가 진행 중임에도 학교가 그 학생을 수업에서 배제한 경우", "피고인이 범죄 혐의로 구속 수사를 받다가 법원에서 무죄 판결을 받자 국가에 형사 보상을 청구할 수 있는 것", "피고인이 재판 중에도 변호인의 조력을 받을 권리를 보장받는 것"], answerIndex: 1, explanation: "무죄 추정의 원칙은 유죄 판결이 확정되기 전까지는 피의자나 피고인을 무죄로 간주해야 한다는 원칙이다. 징계가 확정되기 전부터 학생을 범죄자로 취급하여 수업에서 배제하는 것은 무죄 추정의 원칙의 취지에 어긋난다." },
            { id: 404, type: 'two-step', difficulty: '최상', case: "보안 처분은 형벌과 달리 과거의 불법에 대한 책임에 기초하며, 그 부과에 죄형 법정주의의 소급효 금지 원칙이 예외 없이 적용된다.", q1: 'X', q2_question: "다음 중 보안 처분으로서 사회 복귀 및 교화를 목적으로 하는 시설에 수용되는 사례는?", q2: ["만 17세의 甲이 심각한 범죄로 일반 형사 법원에서 징역형을 선고받고 소년 교도소에 수용된 경우", "만 16세의 乙이 가정 법원 소년부로부터 '장기 소년원 송치' 처분을 받고 소년원에 수용된 경우", "만 20세의 丙이 음주운전으로 집행 유예를 선고받고 사회봉사 명령을 받은 경우", "만 14세의 丁이 심신상실 상태에서 살인죄를 저질러 치료 감호 시설에 수용된 경우"], answerIndex: 1, explanation: "보안 처분은 장래의 위험성을 예방하기 위한 조치로 소급효 금지 원칙이 적용되지 않는다. 소년원은 소년 보호 처분을 받은 소년을 교정 교육을 통해 사회 복귀와 교화를 목적으로 수용하는 시설이다." },
            { id: 405, type: 'two-step', difficulty: '최상', case: "강제 처분은 실체적 진실을 발견하고 형벌권을 실현하기 위해 불가피하더라도, 개인의 기본권을 침해하므로 반드시 법률에 의하여 그 종류 및 요건과 절차가 갖추어져야 한다.", q1: 'O', q2_question: "다음 사례는 형사 절차에서 인권 보장을 위한 어떤 원칙을 위반한 것으로 볼 수 있습니까? <br>\"경찰관 甲은 乙을 체포 후, 권리 고지 없이 심문하여 자백을 받았고, 이 자백이 유일한 유죄 증거로 제시되었다.\"", q2: ["영장주의", "무죄 추정의 원칙", "자백 보강 법칙 및 미란다 원칙(진술 거부권 고지)", "적법 절차의 원칙 및 형사 보상 제도"], answerIndex: 2, explanation: "이 사례에서는 乙에게 진술 거부권 등의 고지(미란다 원칙)가 이루어지지 않아 위법하게 수집된 자백에 해당하며, 또한 자백이 유일한 증거로 제시되었으므로 자백 보강 법칙에 위배된다. 이 두 원칙 위반이 핵심이다." }
        ];

         // 게임 초기화 함수
         function initGame() {
             resetGameState();
             showScreen('story-screen');
         }

         function resetGameState() {
              gameState = {
                  player: { name: '', class: '', gender: '', level: 1, imageKey: '' },
                  difficulty: null, lives: 5, monstersDefeated: 0,
                  currentMonster: null, currentQuiz: null, usedQuizIds: [],
                  clearedStages: { '하': false, '중': false, '상': false },
                  isBossFight: false, bossStage: 0,
                  currentScreen: 'start-screen',
                  animation: { type: null, progress: 0, duration: 0, shake: 0 },
                  questionsAttempted: 0,
                  questionsCorrect: 0,
                  isSkippable: false,
                  onSkip: null,
                  skippableTimeoutId: null,
                  isChallengeUnlocked: false,
                  score: 0
              };
         }

         // 화면 전환
         function showScreen(screenId) {
             screens.forEach(screen => screen.classList.remove('active'));
             document.getElementById(screenId).classList.add('active');
             gameState.currentScreen = screenId;
         }

         // 에셋 로딩
         async function loadAssets() {
             const imageSources = [
                ...Object.values(assets.characters),
                ...Object.values(assets.monsters),
                ...Object.values(assets.misc)
             ];
             const imagePromises = imageSources.map(src => {
                 return new Promise((resolve) => {
                     const img = new Image();
                     img.src = src;
                     img.onload = () => {
                         let keyFound = false;
                         for (const category in assets) {
                             const key = Object.keys(assets[category]).find(k => assets[category][k] === src);
                             if (key) {
                                 loadedImages[key] = img;
                                 keyFound = true;
                                 break;
                             }
                         }
                         resolve();
                     };
                     img.onerror = () => {
                         console.error(`이미지 로딩 실패: ${src}`);
                         resolve();
                     }
                 });
             });
             await Promise.all(imagePromises);
         }
         
         function initAndPlayBGM() {
             if (bgmAudioElement.paused) {
                 const playPromise = bgmAudioElement.play();
                 if (playPromise !== undefined) {
                     playPromise.catch(error => {
                         console.error("오디오 자동재생 실패. 사용자 상호작용이 필요합니다.", error);
                     });
                 }
             }
         }

         // 게임 로직
         function startNewGame() {
             resetGameState();
             showScreen('character-selection-screen');
         }

         function setupDifficultyScreen() {
             const statusEl = document.getElementById('difficulty-char-status');
             statusEl.innerHTML = `
                 <h3>${gameState.player.name}</h3>
                 <p>LV. ${gameState.player.level} | 직업: ${gameState.player.class}</p>
             `;
             
             const optionsContainer = document.getElementById('difficulty-options');
             // 기존 버튼 상태 업데이트
             optionsContainer.querySelectorAll('.difficulty-option:not(.challenge-option)').forEach(opt => {
                const btn = opt.querySelector('.difficulty-btn');
                const diff = btn.dataset.difficulty;
                const isCleared = gameState.clearedStages[diff];
                if(isCleared) {
                    btn.textContent = `${diff} (클리어!)`;
                    btn.style.backgroundColor = 'var(--success-color)';
                } else {
                    btn.textContent = diff;
                    btn.style.backgroundColor = 'var(--primary-color)';
                }
                btn.classList.toggle('disabled', (diff === '중' && !gameState.clearedStages['하']) || (diff === '상' && !gameState.clearedStages['중']));
             });
             
             // 도전자 모드 버튼 추가/제거
             const existingChallengeBtn = optionsContainer.querySelector('.challenge-option');
             if (existingChallengeBtn) existingChallengeBtn.remove();

             if (gameState.isChallengeUnlocked) {
                 const challengeOption = document.createElement('div');
                 challengeOption.className = 'difficulty-option challenge-option';
                 challengeOption.innerHTML = `
                    <button class="btn btn-challenge difficulty-btn" data-difficulty="도전자">도전자</button>
                    <p class="difficulty-desc">최고 점수에 도전하세요!</p>
                 `;
                 optionsContainer.appendChild(challengeOption);
                 challengeOption.querySelector('.difficulty-btn').addEventListener('click', () => startGame('도전자'));
             }

             showScreen('difficulty-selection-screen');
         }

         function startGame(difficulty) {
             gameState.difficulty = difficulty;
             gameState.usedQuizIds = [];
             gameState.isBossFight = false;
             gameState.bossStage = 0;
             gameState.questionsAttempted = 0;
             gameState.questionsCorrect = 0;

             if (difficulty === '도전자') {
                gameState.lives = 3;
                gameState.score = 0;
             } else {
                gameState.lives = 5;
             }

             monsterInfoDisplay.style.display = 'none';
             updateStatus();
             startDungeonAnimation(true);
         }

         function startDungeonAnimation(showInitialMessage = false) {
             showScreen('game-screen');
             dungeonPillars = [];
             for (let i = 0; i < 5; i++) {
                 dungeonPillars.push({
                     x: canvas.width + i * (canvas.width / 4),
                     y: canvas.height * 0.2,
                     width: 30,
                     height: canvas.height * 0.4
                 });
             }
             gameState.animation = { type: 'dungeon-intro', progress: 0, duration: 2000, shake: 0 };
             gameLoop();
             
             const callback = () => {
                 if (gameState.animation.type === 'dungeon-intro') {
                     gameState.animation.type = null;
                     if (showInitialMessage) {
                         showTemporaryMessage("몬스터가 등장했습니다.", 1000, spawnMonster);
                     } else {
                         spawnMonster();
                     }
                 }
             };
             
             makeEventSkippable(callback, 2000);
         }
         
         function makeEventSkippable(callback, duration) {
             if (gameState.skippableTimeoutId) clearTimeout(gameState.skippableTimeoutId);
             
             const onSkipCallback = () => {
                 if(gameState.isSkippable) { 
                     gameState.isSkippable = false;
                     clearTimeout(gameState.skippableTimeoutId);
                     gameState.skippableTimeoutId = null;
                     gameState.onSkip = null;
                     callback();
                 }
             };

             gameState.isSkippable = true;
             gameState.onSkip = onSkipCallback;
             gameState.skippableTimeoutId = setTimeout(onSkipCallback, duration);
         }

         function skipCurrentEvent() {
             if (gameState.isSkippable && typeof gameState.onSkip === 'function') {
                 gameState.onSkip();
             }
         }

         function spawnMonster() {
             const difficulty = gameState.difficulty;
             let monsterType;

             if (gameState.isBossFight) {
                 monsterType = '보스';
             } else if (difficulty === '도전자') {
                const rand = Math.random();
                if (rand < 0.4) monsterType = '중';
                else if (rand < 0.8) monsterType = '상';
                else monsterType = '보스'; // 도전자 모드에서는 일반 몬스터로 보스 등장
             } else {
                 const rand = Math.random() * 100;
                 if (difficulty === '하') {
                     if (rand < 65) monsterType = '하'; else if (rand < 90) monsterType = '중'; else monsterType = '상';
                 } else if (difficulty === '중') {
                     if (rand < 50) monsterType = '하'; else if (rand < 85) monsterType = '중'; else monsterType = '상';
                 } else { // 상
                     if (rand < 40) monsterType = '하'; else if (rand < 70) monsterType = '중'; else monsterType = '상';
                 }
             }
             
             gameState.currentMonster = { type: monsterType, imageKey: monsterType };
             startQuiz();
         }

         function startQuiz() {
             gameState.questionsAttempted++;
             updateStatus();
             let quizDifficulty;

             if (gameState.difficulty === '도전자') {
                const rand = Math.random();
                if (rand < 0.4) quizDifficulty = '중';
                else if (rand < 0.8) quizDifficulty = '상';
                else quizDifficulty = '최상';
             } else if (gameState.isBossFight) {
                if (gameState.difficulty === '하') quizDifficulty = '상';
                else quizDifficulty = '최상';
             } else {
                quizDifficulty = gameState.currentMonster.type;
             }

             monsterInfoDisplay.innerHTML = `몬스터 등급: ${gameState.currentMonster.type}<br>문제 난이도: ${quizDifficulty}`;
             monsterInfoDisplay.style.display = 'block';

             const availableQuizzes = quizzes.filter(q => q.difficulty === quizDifficulty && !gameState.usedQuizIds.includes(q.id));

             if (availableQuizzes.length === 0) {
                 showMessage(`이 난이도의 모든 문제를 정복했습니다!`, prepareNextEncounter);
                 return;
             }

             gameState.currentQuiz = availableQuizzes[Math.floor(Math.random() * availableQuizzes.length)];
             gameState.usedQuizIds.push(gameState.currentQuiz.id);
             
             displayQuiz();
         }

         function displayQuiz() {
             const quiz = gameState.currentQuiz;
             q2OptionsEl.innerHTML = '';
             
             if (quiz.type === 'single') {
                 quizCaseEl.innerHTML = `[문제]<br>${quiz.case}`;
                 q1OptionsEl.style.display = 'none';
                 q2OptionsEl.style.display = 'flex';
                 quiz.q2.forEach((option, index) => {
                     const btn = document.createElement('button');
                     btn.classList.add('btn', 'quiz-btn', 'q2-btn');
                     btn.innerHTML = `${index + 1}. ${option}`;
                     btn.dataset.answerIndex = index;
                     q2OptionsEl.appendChild(btn);
                 });
             } else if (quiz.type === 'two-step') {
                 quizCaseEl.innerHTML = `[O/X 문제]<br>${quiz.case}`;
                 q1OptionsEl.style.display = 'flex';
                 q2OptionsEl.style.display = 'none';
             } else { // 'one-step-ox'
                 quizCaseEl.innerHTML = `[O/X 문제]<br>${quiz.case}`;
                 q1OptionsEl.style.display = 'flex';
                 q2OptionsEl.style.display = 'none';
             }
             quizContainer.style.display = 'flex';
         }
         
         function displayQ2ForTwoStep() {
             const quiz = gameState.currentQuiz;
             const q2Question = quiz.q2_question || "위 O/X 판단에 대한 근거로 가장 적절한 것을 고르시오.";
             quizCaseEl.innerHTML = `<b>[심화 문제] ${q2Question}</b>`;
             q1OptionsEl.style.display = 'none';
             q2OptionsEl.style.display = 'flex';
             
             quiz.q2.forEach((option, index) => {
                 const btn = document.createElement('button');
                 btn.classList.add('btn', 'quiz-btn', 'q2-btn');
                 btn.innerHTML = `${index + 1}. ${option}`;
                 btn.dataset.answerIndex = index;
                 q2OptionsEl.appendChild(btn);
             });
         }

         function handleQ1Answer(answer) {
             const quiz = gameState.currentQuiz;
             if (answer === quiz.q1) {
                 if (quiz.type === 'one-step-ox') {
                     handleCorrectAnswer();
                 } else { // two-step
                     displayQ2ForTwoStep();
                 }
             } else {
                 handleIncorrectAnswer();
             }
         }

         function handleQ2Answer(index) {
             if (index == gameState.currentQuiz.answerIndex) {
                 handleCorrectAnswer();
             } else {
                 handleIncorrectAnswer();
             }
         }

         function handleCorrectAnswer() {
            if (gameState.difficulty === '도전자') {
                const scoreMap = {'하': 10, '중': 20, '상': 30, '보스': 50, '최상': 50};
                gameState.score += scoreMap[gameState.currentMonster.type] || 20;
            }
             gameState.questionsCorrect++;
             updateStatus();
             quizContainer.style.display = 'none';
             monsterInfoDisplay.style.display = 'none';
             gameState.animation = { type: 'attack', progress: 0, duration: 1500, shake: 5 };
             effectParticles = [];

             const nextAction = () => {
                 if (gameState.isBossFight) {
                    if (gameState.difficulty === '상' && gameState.bossStage === 0) {
                        gameState.bossStage = 1;
                        showTemporaryMessage("크윽... 이대로 물러날 수 없다..!", 1500, spawnMonster);
                        return;
                    }
                    handleStageClear();
                 } else {
                     prepareNextEncounter();
                 }
             };

             if (gameState.isBossFight) {
                 setTimeout(nextAction, 1500);
             } else {
                 showTemporaryMessage("몬스터를 물리쳤다!", 1500, nextAction);
             }
         }
         
         function handleIncorrectAnswer() {
             quizContainer.style.display = 'none';
             monsterInfoDisplay.style.display = 'none';
             gameState.animation = { type: 'damage', progress: 0, duration: 1000, shake: 10 };
             gameState.lives--;
             updateStatus();

             const quiz = gameState.currentQuiz;
             let explanationText = `<b>오답입니다!</b><br><br><b>정답 해설:</b><br>${quiz.explanation || "해설 정보가 없습니다."}`;

             const nextAction = () => {
                 if (gameState.lives <= 0) {
                    if (gameState.difficulty === '도전자') {
                        showChallengeResult();
                    } else {
                        gameState.animation = { type: 'game-over', progress: 0, duration: 2500, shake: 0 };
                        setTimeout(() => showMessage("GAME OVER", () => showScreen('start-screen')), 2500);
                    }
                 } else {
                     if (gameState.isBossFight) {
                        showTemporaryMessage("다시 도전!", 1000, spawnMonster);
                     } else {
                        startDungeonAnimation();
                     }
                 }
             };
             
             showMessage(explanationText, nextAction);
         }
         
         function prepareNextEncounter() {
             if (gameState.difficulty !== '도전자' && Math.random() < 0.3) gameState.lives = Math.min(5, gameState.lives + 1);
             updateStatus();

             if (gameState.difficulty === '도전자') {
                startDungeonAnimation();
                return;
             }

             const bossThresholds = { '하': 5, '중': 8, '상': 10 };
             const correctAnswers = gameState.questionsCorrect;
             let bossConditionMet = correctAnswers >= bossThresholds[gameState.difficulty];
             
             if (bossConditionMet) {
                 gameState.isBossFight = true;
                 gameState.bossStage = 0;
                 showTemporaryMessage("보스가 등장했다!", 1000, spawnMonster);
             } else {
                 startDungeonAnimation();
             }
         }
         
         function handleStageClear() {
             gameState.clearedStages[gameState.difficulty] = true;
             gameState.player.level++;
             
             gameState.animation = { type: 'game-clear', progress: 0, duration: 3000, shake: 0 };
             effectParticles = [];
             for (let i = 0; i < 150; i++) {
                 effectParticles.push({
                     type: 'confetti', x: Math.random() * canvas.width, y: Math.random() * -canvas.height,
                     vx: Math.random() * 6 - 3, vy: Math.random() * 5 + 3,
                     size: Math.random() * 10 + 5, color: `hsl(${Math.random() * 360}, 100%, 70%)`,
                     rotation: Math.random() * 360, life: 1
                 });
             }
             
             setTimeout(() => {
                if (gameState.clearedStages['하'] && gameState.clearedStages['중'] && gameState.clearedStages['상']) {
                    gameState.isChallengeUnlocked = true;
                    gameState.player.level = 4;
                    startGrandFinale();
                } else {
                    saveGame(false);
                    showMessage(`난이도 '${gameState.difficulty}' 클리어!<br>레벨 업! (현재 LV.${gameState.player.level})`, setupDifficultyScreen);
                }
             }, 3000);
         }

         function startGrandFinale() {
            gameState.animation = { type: 'grand-finale', progress: 0, duration: 6000, shake: 0 };
            effectParticles = [];
            for (let i = 0; i < 200; i++) {
                effectParticles.push({
                    type: 'confetti', x: Math.random() * canvas.width, y: Math.random() * -canvas.height,
                    vx: Math.random() * 6 - 3, vy: Math.random() * 5 + 3,
                    size: Math.random() * 10 + 5, color: `hsl(${Math.random() * 360}, 100%, 70%)`,
                    rotation: Math.random() * 360, life: 1
                });
            }
            gameLoop();
            
            setTimeout(() => {
                saveGame(false);
                showMessage("지식의 서를 얻고 세상의 모든 지식을 손에 넣었습니다. 축하합니다!", setupDifficultyScreen);
            }, 6000);
         }

         function showChallengeResult() {
            let resultText = `
                <h2>도전 결과</h2>
                <p><b>${gameState.player.name}</b>님의 최종 점수는 <b>${gameState.score}점</b> 입니다!</p>
                <div class="capture-guide">
                    <h4>결과 화면 캡처 안내</h4>
                    <ul>
                        <li><b>📱 아이폰:</b> 측면 버튼 + 음량 높이기 버튼 동시 누르기</li>
                        <li><b>📱 안드로이드:</b> 전원 버튼 + 음량 낮추기 버튼 동시 누르기</li>
                        <li><b>💻 윈도우:</b> 윈도우 키 + Shift + S</li>
                        <li><b>💻 맥:</b> Shift + Command + 4</li>
                    </ul>
                </div>
            `;
            showMessage(resultText, setupDifficultyScreen);
         }


         function updateStatus() {
             document.getElementById('status-name').textContent = gameState.player.name;
             document.getElementById('status-level').textContent = gameState.player.level;
             document.getElementById('status-lives').textContent = '❤️'.repeat(gameState.lives);
             updateProgressDisplay();
         }
         
         function updateProgressDisplay() {
             let progressText = ``;
             if (gameState.difficulty === '도전자') {
                progressText = `점수: ${gameState.score}`;
             } else {
                const bossThresholds = { '하': 5, '중': 8, '상': 10 };
                const needed = bossThresholds[gameState.difficulty];
                const remaining = Math.max(0, needed - gameState.questionsCorrect);
                progressText = `푼 문제: ${gameState.questionsAttempted} | 정답: ${gameState.questionsCorrect}`;
                if (!gameState.isBossFight && !gameState.clearedStages[gameState.difficulty]) {
                    progressText += ` | 보스까지: ${remaining}문제`;
                }
             }
             progressDisplay.textContent = progressText;
         }

         function showMessage(text, callback) {
             messageText.innerHTML = text;
             messageModal.style.display = 'flex';
             
             const newOkBtn = messageOkBtn.cloneNode(true);
             messageOkBtn.parentNode.replaceChild(newOkBtn, messageOkBtn); 
             messageOkBtn = newOkBtn; 

             messageOkBtn.onclick = () => {
                 messageModal.style.display = 'none';
                 if (callback) callback();
             };
         }
         
         function showTemporaryMessage(text, duration, callback) {
             tempMessageOverlay.textContent = text;
             tempMessageOverlay.classList.add('visible');
             
             setTimeout(() => {
                 tempMessageOverlay.classList.remove('visible');
                 if (callback) callback();
             }, duration);
         }

         function saveGame(showAlert = true) {
             localStorage.setItem('crimeQuizRPGSave', JSON.stringify({
                 player: gameState.player,
                 clearedStages: gameState.clearedStages,
                 isChallengeUnlocked: gameState.isChallengeUnlocked
             }));
             if (showAlert) {
                 showMessage("게임이 저장되었습니다.");
             }
         }

         function loadGame() {
             const saveData = localStorage.getItem('crimeQuizRPGSave');
             if (saveData) {
                 const parsedData = JSON.parse(saveData);
                 resetGameState();
                 gameState.player = parsedData.player;
                 gameState.clearedStages = parsedData.clearedStages;
                 gameState.isChallengeUnlocked = parsedData.isChallengeUnlocked || false;
                 document.getElementById('character-name').value = gameState.player.name;
                 showMessage(`'${gameState.player.name}'님의 데이터를 불러왔습니다.`, setupDifficultyScreen);
             } else {
                 showMessage("저장된 게임이 없습니다.");
             }
         }

         function resizeCanvas() {
             const container = document.getElementById('game-screen');
             canvas.width = container.clientWidth;
             canvas.height = container.clientHeight;
         }

         function drawDungeonBackground() {
            const difficulty = gameState.difficulty;
            let grad1 = '#3d3a5e', grad2 = '#5e5a80', wall = '#33304a';

            if (difficulty === '중') { grad1 = '#4a3a3a'; grad2 = '#6b5a5a'; wall = '#403030'; }
            else if (difficulty === '상') { grad1 = '#4a2a4a'; grad2 = '#6b3b6b'; wall = '#402040'; }
            else if (difficulty === '도전자') { grad1 = '#5a2a2a'; grad2 = '#7b3b3b'; wall = '#502020'; }

             ctx.fillStyle = grad1;
             ctx.fillRect(0, 0, canvas.width, canvas.height);
             ctx.fillStyle = grad2;
             ctx.fillRect(0, canvas.height * 0.6, canvas.width, canvas.height * 0.4);
             ctx.strokeStyle = wall;
             ctx.lineWidth = 2;
             for(let y = 0; y < canvas.height * 0.6; y += 40) {
                 for(let x = (y/40 % 2) * -20; x < canvas.width; x += 40) {
                     ctx.strokeRect(x, y, 40, 40);
                 }
             }
         }

         function drawCharacter(bobbing) {
             const img = loadedImages[gameState.player.imageKey];
             if (!img) return;

             let size = Math.min(canvas.width, canvas.height) * 0.25;
             let yOffset = bobbing ? Math.sin(Date.now() / 200) * 5 : 0;
             let xPos = canvas.width * 0.2;
             let yPos = canvas.height * 0.6 - size;
             
             if (gameState.animation.type === 'grand-finale') {
                size = Math.min(canvas.width, canvas.height) * 0.35;
                xPos = canvas.width / 2 - size / 2;
                yPos = canvas.height * 0.4 - size;
                yOffset += Math.abs(Math.sin(Date.now() / 200) * -15);
             }
             
             ctx.drawImage(img, xPos, yPos + yOffset, size, size);
         }

         function drawMonster() {
             if (gameState.currentMonster) {
                 const img = loadedImages[gameState.currentMonster.imageKey];
                 if (img) {
                     const size = Math.min(canvas.width, canvas.height) * 0.3;
                     let x = canvas.width * 0.8 - size;
                     let y = canvas.height * 0.6 - size;
                     if (gameState.animation.type === 'damage') {
                         const progress = gameState.animation.progress / gameState.animation.duration;
                         x += Math.sin(progress * Math.PI * 10) * 10;
                     }
                     ctx.drawImage(img, x, y, size, size);
                 }
             }
         }
         
         function drawEffects(deltaTime) {
             if (gameState.animation.type === 'attack') {
                 const progress = Math.min(1, gameState.animation.progress / gameState.animation.duration);
                 const level = gameState.player.level;
                 const startX = canvas.width * 0.35;
                 const startY = canvas.height * 0.45;
                 const endX = canvas.width * 0.7;
                 
                 if (gameState.player.class === '전사') {
                    const easeOutProgress = 1 - Math.pow(1 - progress, 4);
                    const travelX = startX + (endX - startX) * easeOutProgress;
                    const alpha = Math.sin(progress * Math.PI);

                    if (level <= 1) {
                        drawSharpSlash(travelX, startY, 120, 60, alpha, 'white', 'white', 15, 8);
                    } else if (level === 2) {
                        drawSharpSlash(travelX, startY, 140, 70, alpha, '#ffdd00', '#ffdd00', 25, 10);
                        if(progress > 0.2 && progress < 0.8) {
                           drawSharpSlash(travelX + 10, startY, 100, 50, alpha * 0.5, 'white', 'white', 15, 5);
                        }
                    } else if (level === 3) {
                        const p1 = Math.sin(Math.min(1, progress / 0.7) * Math.PI);
                        const p2 = Math.sin(Math.max(0, (progress - 0.3) / 0.7) * Math.PI);
                        drawSharpSlash(endX, startY - 30, 180, 80, p1, '#ff8800', '#ff4400', 35, 15, -20);
                        drawSharpSlash(endX, startY + 30, 180, 80, p2, '#ff8800', '#ff4400', 35, 15, 20);
                    } else { // Level 4+
                        const p_main = Math.sin(Math.min(1, progress / 0.6) * Math.PI);
                        const p_cross = Math.sin(Math.max(0, (progress-0.4)/0.6) * Math.PI);
                        ctx.save();
                        ctx.translate(endX, startY);
                        drawSharpSlash(0, 0, 300, 150, p_main, 'cyan', 'white', 60, 30, 45);
                        drawSharpSlash(0, 0, 300, 150, p_cross, 'red', 'white', 60, 20, -45);
                        ctx.restore();
                    }
                 } else if (gameState.player.class === '마법사') {
                    const currentX = startX + (endX - startX) * progress;
                    const currentY = startY;
                    if (level <= 1) {
                        ctx.fillStyle = `rgba(173, 216, 230, ${1 - progress})`;
                        ctx.shadowColor = 'cyan'; ctx.shadowBlur = 15;
                        ctx.beginPath(); ctx.arc(currentX, currentY, 20, 0, Math.PI * 2); ctx.fill();
                    } else if (level === 2) {
                        for(let i=0; i<3; i++) {
                            const p = (progress + i*0.1) % 1;
                            const x = startX + (endX - startX) * p;
                            ctx.fillStyle = `rgba(100, 180, 255, ${1 - p})`;
                            ctx.shadowColor = 'blue'; ctx.shadowBlur = 20;
                            ctx.beginPath(); ctx.arc(x, currentY + Math.sin(p * Math.PI) * 30, 25, 0, Math.PI * 2); ctx.fill();
                        }
                    } else if (level === 3) {
                        if (progress > 0.1 && progress < 0.9 && Math.random() > 0.5) {
                            effectParticles.push({ type: 'lightning', x: startX, y: startY, tx: endX, ty: startY, life: 0.5 });
                        }
                    } else { // Level 4+
                        const p_ultimate = Math.sin(progress * Math.PI);
                        ctx.fillStyle = `rgba(255, 215, 0, ${p_ultimate * 0.2})`;
                        ctx.shadowColor = 'gold'; ctx.shadowBlur = 50;
                        ctx.beginPath(); ctx.arc(endX, startY, 200 * p_ultimate, 0, Math.PI * 2); ctx.fill();
                        if (progress > 0.2 && Math.random() > 0.3) {
                            effectParticles.push({ type: 'lightning', x: endX + (Math.random()-0.5)*200, y: startY + (Math.random()-0.5)*200, tx: endX, ty: startY, life: 0.3 });
                        }
                    }
                 }
             } else if (gameState.animation.type === 'grand-finale') {
                drawBowingMonsters();
                drawKnowledgeBook();
             }
             
             // Particle Effects
             effectParticles.forEach((p, index) => {
                p.life -= deltaTime / 1000;
                if (p.life <= 0) { effectParticles.splice(index, 1); return; }
                
                ctx.save();
                ctx.globalAlpha = p.life > 0 ? p.life : 0;
                
                if (p.type === 'lightning') {
                    ctx.strokeStyle = `hsl(${200 + Math.random()*100}, 100%, ${70 + Math.random()*30}%)`;
                    ctx.lineWidth = Math.random() * 5 + 2;
                    ctx.shadowColor = '#9b59b6'; ctx.shadowBlur = 20;
                    ctx.beginPath(); ctx.moveTo(p.x, p.y);
                    for(let i=0; i<5; i++) {
                        const nx = p.x + (p.tx-p.x) * (i/4) + (Math.random()-0.5)*40;
                        const ny = p.y + (p.ty-p.y) * (i/4) + (Math.random()-0.5)*40;
                        ctx.lineTo(nx, ny);
                    }
                    ctx.stroke();
                } else { // Confetti, etc.
                    p.x += p.vx * (deltaTime / 16); p.y += p.vy * (deltaTime / 16);
                    ctx.translate(p.x, p.y);
                    ctx.fillStyle = p.color;
                    ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
                }
                ctx.restore();
             });
         }

         function drawSharpSlash(x, y, height, width, alpha, color, shadowColor, shadowBlur, lineWidth, angle = 0) {
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.shadowColor = shadowColor;
            ctx.shadowBlur = shadowBlur;
            ctx.translate(x, y);
            ctx.rotate(angle * Math.PI / 180);
            ctx.beginPath();
            ctx.moveTo(0, -height / 2);
            ctx.bezierCurveTo(width * 0.8, -height * 0.2, width * 0.8, height * 0.2, 0, height / 2);
            ctx.stroke();
            ctx.restore();
         }

         function drawBowingMonsters() {
            const monsterKeys = ['하', '중', '상', '보스'];
            monsterKeys.forEach((key, index) => {
                const img = loadedImages[key];
                if (!img) return;
                const size = canvas.width * 0.15;
                const x = canvas.width * (0.15 + index * 0.22);
                const y = canvas.height * 0.7 - size;
                ctx.save();
                ctx.translate(x + size / 2, y + size);
                const bowAngle = 0.4 + Math.sin(Date.now() / 500 + index) * 0.1;
                ctx.rotate(bowAngle);
                ctx.drawImage(img, -size / 2, -size, size, size);
                ctx.restore();
            });
         }

         function drawKnowledgeBook() {
            const img = loadedImages['book'];
            if (!img) return;
            const progress = Math.min(1, gameState.animation.progress / 4000);
            const size = canvas.width * 0.25 * progress;
            const x = canvas.width / 2 - size / 2;
            const y = canvas.height * 0.5 - size / 2 + Math.sin(progress * Math.PI * 2) * 10;
            ctx.save();
            ctx.globalAlpha = progress;
            ctx.shadowColor = 'gold';
            ctx.shadowBlur = 30 * progress;
            ctx.drawImage(img, x, y, size, size);
            ctx.restore();
         }


         let lastTime = 0;
         function gameLoop(timestamp) {
             if (gameState.currentScreen !== 'game-screen') return;

             const deltaTime = (timestamp - lastTime) || 0;
             lastTime = timestamp;

             if (gameState.animation.type) {
                 gameState.animation.progress += deltaTime;
                 if (gameState.animation.progress >= gameState.animation.duration) {
                     if(gameState.animation.type !== 'game-over' && gameState.animation.type !== 'game-clear' && gameState.animation.type !== 'grand-finale') {
                        gameState.animation.type = null;
                     }
                 }
             }

             ctx.save();
             if(gameState.animation.shake > 0) {
                 const shakeAmount = gameState.animation.shake * Math.sin(gameState.animation.progress);
                 ctx.translate(Math.random() * shakeAmount - shakeAmount/2, Math.random() * shakeAmount - shakeAmount/2);
                 gameState.animation.shake *= 0.9;
             }

             ctx.clearRect(0, 0, canvas.width, canvas.height);
             drawDungeonBackground();
             
             if (gameState.animation.type === 'dungeon-intro') {
                 drawCharacter(true);
             } else if (gameState.animation.type === 'grand-finale') {
                drawCharacter(true); 
             } else {
                 drawCharacter(false);
                 drawMonster();
             }
             
             drawEffects(deltaTime);
             ctx.restore();

             requestAnimationFrame(gameLoop);
         }

         // 이벤트 리스너 설정
         window.addEventListener('load', async () => {
             await loadAssets();
             initGame();
             resizeCanvas();
         });
         
         window.addEventListener('resize', resizeCanvas);

         canvas.addEventListener('click', skipCurrentEvent);

         document.getElementById('story-screen').addEventListener('click', () => {
             showScreen('start-screen');
         });

         document.getElementById('start-new-game-btn').addEventListener('click', () => {
             initAndPlayBGM();
             startNewGame();
         });
         document.getElementById('load-game-btn').addEventListener('click', () => {
             initAndPlayBGM();
             loadGame();
         });
         document.getElementById('save-game-btn').addEventListener('click', () => saveGame(true));
         
         document.getElementById('change-character-btn').addEventListener('click', () => {
             showScreen('character-selection-screen');
         });

         document.getElementById('back-to-difficulty-btn').addEventListener('click', () => {
             saveGame(false);
             setupDifficultyScreen();
         });

         document.querySelectorAll('.char-card').forEach(card => {
             card.addEventListener('click', () => {
                 document.querySelectorAll('.char-card').forEach(c => c.classList.remove('selected'));
                 card.classList.add('selected');
             });
         });

         document.getElementById('confirm-character-btn').addEventListener('click', () => {
             const name = document.getElementById('character-name').value.trim();
             const selected = document.querySelector('.char-card.selected');
             if (!name) { showMessage("캐릭터 이름을 입력해주세요."); return; }
             if (!selected) { showMessage("캐릭터를 선택해주세요."); return; }
             
             const level = gameState.player.level || 1;
             const clearedStages = gameState.clearedStages || { '하': false, '중': false, '상': false };
             const isChallengeUnlocked = gameState.isChallengeUnlocked || false;

             gameState.player.name = name;
             gameState.player.class = selected.dataset.class;
             gameState.player.gender = selected.dataset.gender;
             gameState.player.imageKey = `${gameState.player.class}_${gameState.player.gender}`;
             gameState.player.level = level;
             gameState.clearedStages = clearedStages;
             gameState.isChallengeUnlocked = isChallengeUnlocked;
             
             setupDifficultyScreen();
         });
         
         document.getElementById('difficulty-options').addEventListener('click', (e) => {
            if (e.target.matches('.difficulty-btn') && !e.target.classList.contains('disabled')) {
                startGame(e.target.dataset.difficulty);
            }
         });

         q1OptionsEl.addEventListener('click', (e) => {
             if (e.target.matches('.quiz-btn')) handleQ1Answer(e.target.dataset.answer);
         });

         q2OptionsEl.addEventListener('click', (e) => {
             const target = e.target.closest('.q2-btn');
             if (target) handleQ2Answer(target.dataset.answerIndex);
         });

         document.getElementById('instructions-btn').addEventListener('click', () => {
             document.getElementById('instructions-modal').style.display = 'flex';
         });
         document.getElementById('instructions-close-btn').addEventListener('click', () => {
             document.getElementById('instructions-modal').style.display = 'none';
         });

     </script>
 </body>
 </html>
