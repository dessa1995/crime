<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>던전 법률 퀴즈 RPG</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&family=Cinzel+Decorative:wght@700&family=MedievalSharp&display=swap');

        :root {
            --bg-color: #0d0c1d;
            --surface-color: #1a1832;
            --primary-color: #9b59b6;
            --secondary-color: #8e44ad;
            --text-color: #ecf0f1;
            --accent-color: #f1c40f;
            --danger-color: #e74c3c;
            --success-color: #2ecc71;
            --challenge-color: #e67e22;
            --ultimate-color: #3498db;
            --font-family: 'Noto Sans KR', sans-serif;
            --title-font: 'Cinzel Decorative', cursive;
            --dungeon-font: 'MedievalSharp', cursive;
        }

        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100dvh;
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--font-family);
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #game-container {
            width: 100%;
            height: 100%;
            max-width: 1000px;
            max-height: 800px;
            position: relative;
            background-color: #000;
            border-radius: 15px;
            box-shadow: 0 0 50px rgba(0,0,0,0.9), inset 0 0 25px rgba(142, 68, 173, 0.4);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            border: 4px solid #333;
            border-image: linear-gradient(145deg, #444, #111) 1;
        }

        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
            background: radial-gradient(ellipse at center, #2c2a4a 0%, #1a1832 100%);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.7s ease, visibility 0.7s ease;
            text-align: center;
            overflow-y: auto;
        }
        
        .screen::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('https://www.transparenttextures.com/patterns/crissxcross.png'), 
                        radial-gradient(ellipse at center, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.8) 100%);
            opacity: 0.1;
            pointer-events: none;
        }


        .screen.active {
            opacity: 1;
            visibility: visible;
        }
        
        #story-screen {
            background: url('https://raw.githubusercontent.com/dessa1995/crime/main/dungeon-gate.png') no-repeat center center;
            background-size: cover;
            cursor: pointer;
        }
        .story-content {
            background: rgba(0,0,0,0.7);
            padding: 25px 45px;
            border-radius: 15px;
            border: 2px solid var(--accent-color);
            max-width: 80%;
            text-align: center;
            box-shadow: 0 0 25px rgba(241, 196, 15, 0.7);
            backdrop-filter: blur(4px);
        }
        .story-content h2 {
            font-family: var(--dungeon-font);
            color: var(--accent-color);
            margin-bottom: 20px;
            font-size: 2.5em;
            text-shadow: 0 0 10px var(--accent-color);
        }
        .story-content h3 {
            margin-top: 20px;
            color: var(--text-color);
            font-family: var(--dungeon-font);
            font-size: 1.5em;
        }
        .story-content p {
            font-size: 1.1em;
            line-height: 1.7;
            margin-bottom: 15px;
        }
        .skip-message {
            margin-top: 30px;
            font-style: italic;
            font-size: 1em;
            color: var(--accent-color);
            animation: pulse 2s infinite;
        }
        @keyframes pulse { 0% { opacity: 0.7; transform: scale(1); } 50% { opacity: 1; transform: scale(1.05);} 100% { opacity: 0.7; transform: scale(1); } }


        #start-screen {
            background: url('https://raw.githubusercontent.com/dessa1995/crime/main/dungeon-hall.png') no-repeat center center;
            background-size: cover;
        }
        #start-screen .title-container {
            border: 4px double var(--accent-color);
            padding: 25px 45px;
            background: rgba(0,0,0,0.6);
            border-radius: 10px;
            backdrop-filter: blur(5px);
        }
        #start-screen h1 {
            font-family: var(--dungeon-font);
            font-size: 4em;
            color: var(--accent-color);
            text-shadow: 0 0 8px var(--accent-color), 0 0 20px #e74c3c, 0 0 35px #000;
            animation: title-glow 4s infinite alternate;
            margin: 0;
        }
        #start-screen p {
            font-size: 1.2em;
            color: var(--text-color);
            text-shadow: 2px 2px 3px #000;
            margin-top: 10px;
        }

        @keyframes title-glow {
            from { text-shadow: 0 0 8px var(--accent-color), 0 0 20px #e74c3c, 0 0 35px #000; }
            to { text-shadow: 0 0 20px var(--accent-color), 0 0 40px #e74c3c, 0 0 60px #000; }
        }

        h2, h3 {
            color: var(--accent-color);
            text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
            font-family: var(--dungeon-font);
        }
        h2 { font-size: 2.2em; }
        h3 { font-size: 1.8em; }

        .button-group {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            padding: 12px 25px;
            border: 2px solid #111;
            border-radius: 8px;
            background: linear-gradient(145deg, #a868c0, #8e44ad);
            color: var(--text-color);
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 0 #6c3483, 0 6px 10px rgba(0,0,0,0.4), inset 0 -2px 5px rgba(0,0,0,0.3);
            transform: translateY(0);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        .btn:hover {
            background: linear-gradient(145deg, #b37cd0, #9b59b6);
            transform: translateY(-3px);
            box-shadow: 0 8px 0 #6c3483, 0 9px 12px rgba(0,0,0,0.3), inset 0 -2px 5px rgba(0,0,0,0.3);
        }

        .btn:active {
            transform: translateY(2px);
            box-shadow: 0 3px 0 #6c3483, 0 4px 5px rgba(0,0,0,0.4), inset 0 2px 5px rgba(0,0,0,0.3);
        }
        
        .btn.disabled {
            background: linear-gradient(145deg, #839192, #616a6b);
            cursor: not-allowed;
            box-shadow: 0 5px 0 #515a5a;
            opacity: 0.6;
        }
        
        .btn-small {
            padding: 8px 15px;
            font-size: 0.9em;
        }
        
        .btn-challenge {
           background: linear-gradient(145deg, #f39c12, #d35400);
           box-shadow: 0 5px 0 #a04000, 0 6px 10px rgba(0,0,0,0.4), inset 0 -2px 5px rgba(0,0,0,0.3);
        }
        .btn-challenge:hover {
           background: linear-gradient(145deg, #f5b041, #e67e22);
           box-shadow: 0 8px 0 #a04000, 0 9px 12px rgba(0,0,0,0.3), inset 0 -2px 5px rgba(0,0,0,0.3);
        }
        
        .btn-danger {
            background: linear-gradient(145deg, #e74c3c, #c0392b);
            box-shadow: 0 5px 0 #922b21, 0 6px 10px rgba(0,0,0,0.4), inset 0 -2px 5px rgba(0,0,0,0.3);
        }
        .btn-danger:hover {
            background: linear-gradient(145deg, #ec7063, #e74c3c);
            box-shadow: 0 8px 0 #922b21, 0 9px 12px rgba(0,0,0,0.3), inset 0 -2px 5px rgba(0,0,0,0.3);
        }
        .btn-success {
            background: linear-gradient(145deg, #2ecc71, #27ae60);
            box-shadow: 0 5px 0 #1e8449;
        }
        
        .btn-ultimate {
            background: linear-gradient(145deg, #5dade2, #3498db);
            box-shadow: 0 5px 0 #2874a6, 0 6px 10px rgba(0,0,0,0.4), inset 0 -2px 5px rgba(0,0,0,0.3);
            animation: ultimate-glow 2s infinite;
        }
        .btn-ultimate:hover {
            background: linear-gradient(145deg, #85c1e9, #5dade2);
            box-shadow: 0 8px 0 #2874a6, 0 9px 12px rgba(0,0,0,0.3), inset 0 -2px 5px rgba(0,0,0,0.3);
        }
        .btn-ultimate.disabled {
            animation: none;
            background: linear-gradient(145deg, #839192, #616a6b);
            cursor: not-allowed;
            box-shadow: 0 5px 0 #515a5a;
            opacity: 0.6;
        }

        @keyframes ultimate-glow {
            0% { box-shadow: 0 5px 0 #2874a6, 0 0 8px var(--ultimate-color), 0 0 15px #fff; }
            50% { box-shadow: 0 5px 0 #2874a6, 0 0 20px var(--ultimate-color), 0 0 30px #fff; }
            100% { box-shadow: 0 5px 0 #2874a6, 0 0 8px var(--ultimate-color), 0 0 15px #fff; }
        }

        #character-selection-screen .char-options, #ingame-char-change-modal .char-options {
            display: flex;
            gap: 20px;
            margin: 20px 0;
        }
        .char-card {
            background-color: var(--surface-color);
            padding: 15px;
            border-radius: 10px;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.3s ease;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
            position: relative;
        }
        .char-card::before {
            content: '';
            position: absolute;
            top: -2px; left: -2px; right: -2px; bottom: -2px;
            background: linear-gradient(45deg, var(--primary-color), var(--accent-color));
            border-radius: 12px;
            z-index: -1;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .char-card.selected {
            transform: scale(1.05);
            box-shadow: 0 0 20px var(--accent-color), inset 0 0 10px rgba(0,0,0,0.5);
        }
        .char-card.selected::before {
            opacity: 1;
        }
        .char-card img {
            width: 100px;
            height: 100px;
            object-fit: contain;
        }
        .char-card p {
            margin: 5px 0 0;
            font-weight: bold;
        }
        #character-name {
            padding: 10px;
            font-size: 1em;
            border-radius: 5px;
            border: 2px solid var(--primary-color);
            background-color: var(--bg-color);
            color: var(--text-color);
            margin-top: 15px;
            width: 80%;
            max-width: 300px;
            text-align: center;
        }

        #difficulty-selection-screen #difficulty-char-status {
            background-color: rgba(0,0,0,0.3);
            padding: 10px 20px;
            border-radius: 10px;
            border: 2px solid var(--primary-color);
            margin-bottom: 20px;
            backdrop-filter: blur(3px);
        }
        #difficulty-selection-screen #difficulty-char-status h3 {
            margin: 0 0 5px 0;
        }
        #difficulty-selection-screen #difficulty-char-status p {
            margin: 0;
            color: #bdc3c7;
        }

        #difficulty-selection-screen .difficulty-option {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .difficulty-desc {
            font-size: 0.9em;
            color: #bdc3c7;
            margin-top: 8px;
            max-width: 200px;
        }

        #game-screen {
            justify-content: flex-start;
            padding: 0;
            overflow: hidden;
            background: #000; /* Canvas will draw over this */
        }
        #status-bar {
            width: 100%;
            padding: 10px 20px;
            background-color: rgba(0,0,0,0.5);
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-sizing: border-box;
            font-size: 1.1em;
            z-index: 10;
            flex-wrap: wrap;
            gap: 10px;
            position: relative;
            border-bottom: 2px solid var(--primary-color);
            backdrop-filter: blur(5px);
        }
        #status-bar > div {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        #progress-display {
            font-size: 0.9em;
            color: #bdc3c7;
            text-align: center;
            width: 100%;
            order: 2;
        }
        @media (min-width: 768px) {
            #progress-display {
                width: auto;
                order: 0;
            }
        }

        #game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            /* 전사 5레벨 스킬 사용 후 화면 틀어짐 버그 방지를 위해 transition 추가 */
            transition: transform 0.1s ease-out;
        }
        
        #quiz-container {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: rgba(13, 12, 29, 0.95);
            padding: 15px;
            box-sizing: border-box;
            border-top: 3px solid var(--accent-color);
            z-index: 10;
            display: none;
            flex-direction: column;
            gap: 10px;
            max-height: 60%;
            box-shadow: 0 -5px 20px rgba(241, 196, 15, 0.4);
            backdrop-filter: blur(5px);
        }
        #quiz-case {
            flex-shrink: 1;
            min-height: 0;
            overflow-y: auto;
            overscroll-behavior: contain;
            padding: 15px;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            font-size: 1.1em;
            line-height: 1.6;
            text-align: left;
            width: 100%;
            box-sizing: border-box;
            -webkit-overflow-scrolling: touch;
            border: 1px solid var(--primary-color);
        }
        #q1-options {
            flex-shrink: 0;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        #q2-options {
            flex-grow: 1;
            min-height: 0;
            overflow-y: auto;
            overscroll-behavior: contain;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-right: 10px;
            box-sizing: border-box;
            -webkit-overflow-scrolling: touch;
        }

        .quiz-btn {
            width: 45%;
            max-width: 300px;
            padding: 12px;
            font-size: 1em;
        }
        .q2-btn {
            width: 98%;
            max-width: 620px;
            text-align: left;
            font-size: 0.9em;
            padding: 10px;
            flex-shrink: 0;
            margin-bottom: 5px;
        }
        
        .modal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 99;
            padding: 15px;
            box-sizing: border-box;
            backdrop-filter: blur(5px);
        }
        .modal-content {
            background-color: var(--surface-color);
            padding: 30px;
            border-radius: 15px;
            border: 3px solid var(--accent-color);
            box-shadow: 0 0 25px rgba(241, 196, 15, 0.5);
            text-align: center;
            max-width: 90%;
            max-height: 90%;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            overscroll-behavior: contain;
        }
        #message-text {
            font-size: 1.2em;
            line-height: 1.7;
            margin-bottom: 20px;
            text-align: left;
        }
        #message-text b {
            color: var(--accent-color);
        }
        #message-text .capture-guide {
           font-size: 0.9em;
           margin-top: 20px;
           padding-top: 15px;
           border-top: 1px solid var(--primary-color);
        }
        #message-text .capture-guide h4 {
           color: var(--accent-color);
           margin-bottom: 10px;
        }
        #message-text .capture-guide ul {
           list-style: none;
           padding: 0;
        }
        #message-text .capture-guide li {
           margin-bottom: 8px;
        }

        #instructions-modal .modal-content {
            text-align: left;
        }
        #instructions-modal h3 {
            margin-top: 0;
        }
        #instructions-modal ul {
            padding-left: 20px;
        }
        #instructions-modal li {
            margin-bottom: 10px;
        }
        
        #monster-info-display {
            position: absolute;
            top: 70px;
            right: 20px;
            background-color: rgba(0,0,0,0.7);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 1.1em;
            text-align: right;
            z-index: 10;
            display: none;
            border-left: 3px solid var(--danger-color);
            backdrop-filter: blur(3px);
        }
        
        #temp-message-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px 40px;
            background-color: rgba(0,0,0,0.8);
            color: var(--accent-color);
            font-family: var(--dungeon-font);
            font-size: 2.5em;
            font-weight: bold;
            border-radius: 10px;
            z-index: 110;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
            text-shadow: 0 0 10px #000;
            white-space: nowrap;
        }
        #temp-message-overlay.visible {
            opacity: 1;
            visibility: visible;
        }
        
        #fixed-buttons-container {
            position: absolute;
            bottom: 15px;
            right: 15px;
            z-index: 20; /* UI 겹침 방지를 위해 z-index 조정 */
            transition: bottom 0.4s ease-in-out;
        }

        #failsafe-container {
            position: absolute;
            bottom: 15px;
            left: 15px;
            z-index: 20; /* UI 겹침 방지를 위해 z-index 조정 */
            display: none;
            transition: bottom 0.4s ease-in-out;
        }


        /* Responsive Design */
        @media (max-width: 600px) {
            #start-screen h1 { font-size: 2.8em; }
            .btn { padding: 10px 20px; font-size: 1em; }
            #character-selection-screen .char-options, #ingame-char-change-modal .char-options { flex-direction: column; align-items: center; }
            .char-card img { width: 80px; height: 80px; }
            #status-bar { font-size: 0.9em; padding: 8px 15px; }
            #monster-info-display { top: 70px; font-size: 0.9em; }
            #quiz-container { max-height: 55%; padding: 10px; }
            #quiz-case { font-size: 0.95em; padding: 10px; }
            .quiz-btn { width: 90%; }
            .q2-btn { font-size: 0.85em; }
            #temp-message-overlay { font-size: 1.8em; }
            .story-content p { font-size: 1em; }
        }

        @media (max-height: 600px) {
             #quiz-container {
                 max-height: 70%;
             }
             #quiz-case {
                 font-size: 0.9em;
             }
             .q2-btn {
                 font-size: 0.8em;
                 padding: 8px;
             }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="story-screen" class="screen">
            <div class="story-content">
                <h2>🕯️ 지식의 서를 찾아서 🕯️</h2>
                <p>옛 전설에 따르면, 이 세상 모든 법과 지혜가 담긴 ‘지식의 서’는 어둠의 던전에 숨겨져 있다고 한다. 그 서를 지키는 건 형법의 수수께끼를 품은 몬스터들.</p>
                <p>그들은 정의와 논리의 검이 아니면 결코 쓰러뜨릴 수 없다!</p>
                <p>지금 당신은 법의 수호자로 선택받았다. 각 던전의 퀴즈를 풀고, 형법의 지식을 무기로 몬스터를 물리쳐라.</p>
                <p>던전마다 기다리는 강력한 시험을 통과하면, 한 걸음씩 지식의 서에 가까워질 것이다.</p>
                <h3>⚔️ 지금, 정의로운 여정을 시작하라! ⚖️</h3>
                <p class="skip-message">(화면을 클릭하여 계속하기)</p>
            </div>
        </div>

        <div id="start-screen" class="screen">
            <div class="title-container">
                <h1>Dungeon & Law</h1>
                <p>범죄의 성립 여부를 퀴즈로 배우는 던전 탐험!</p>
            </div>
            <div class="button-group">
                <button id="start-new-game-btn" class="btn">새 게임 시작</button>
                <button id="load-game-btn" class="btn">불러오기</button>
            </div>
        </div>

        <div id="character-selection-screen" class="screen">
            <h2>캐릭터 선택</h2>
            <p>이름을 정하고, 당신의 분신이 될 용사를 선택하세요.</p>
            <input type="text" id="character-name" placeholder="캐릭터 이름 입력" maxlength="10">
            <div class="char-options">
                <div class="char-card" data-class="전사" data-gender="남">
                    <img src="https://raw.githubusercontent.com/dessa1995/crime/main/mw.png" alt="남자 전사" onerror="this.src='https://placehold.co/100x100/4f4c7a/ecf0f1?text=Warrior'">
                    <p>남자 전사</p>
                </div>
                <div class="char-card" data-class="전사" data-gender="여">
                    <img src="https://raw.githubusercontent.com/dessa1995/crime/main/fw.png" alt="여자 전사" onerror="this.src='https://placehold.co/100x100/4f4c7a/ecf0f1?text=Warrior'">
                    <p>여자 전사</p>
                </div>
                <div class="char-card" data-class="마법사" data-gender="남">
                    <img src="https://raw.githubusercontent.com/dessa1995/crime/main/mm.png" alt="남자 마법사" onerror="this.src='https://placehold.co/100x100/4f4c7a/ecf0f1?text=Mage'">
                    <p>남자 마법사</p>
                </div>
                <div class="char-card" data-class="마법사" data-gender="여">
                    <img src="https://raw.githubusercontent.com/dessa1995/crime/main/fm.png" alt="여자 마법사" onerror="this.src='https://placehold.co/100x100/4f4c7a/ecf0f1?text=Mage'">
                    <p>여자 마법사</p>
                </div>
            </div>
            <button id="confirm-character-btn" class="btn">선택 완료</button>
        </div>
        
        <div id="difficulty-selection-screen" class="screen">
            <div id="difficulty-char-status"></div>
            <h2>난이도 선택</h2>
            <div class="button-group" id="difficulty-options">
                <div class="difficulty-option">
                    <button class="btn difficulty-btn" data-difficulty="하">하</button>
                    <p class="difficulty-desc">5문제 정답 시 보스 등장</p>
                </div>
                <div class="difficulty-option">
                    <button class="btn difficulty-btn" data-difficulty="중">중</button>
                    <p class="difficulty-desc">8문제 정답 시 보스 등장</p>
                </div>
                <div class="difficulty-option">
                    <button class="btn difficulty-btn" data-difficulty="상">상</button>
                    <p class="difficulty-desc">10문제 정답 시 보스 등장</p>
                </div>
            </div>
             <div class="button-group">
                  <button id="save-game-btn" class="btn">게임 저장</button>
                  <button id="change-character-btn" class="btn">캐릭터 변경</button>
                  <button id="restart-from-scratch-btn" class="btn btn-danger">처음부터 다시하기</button>
             </div>
        </div>

        <div id="game-screen" class="screen">
            <div id="status-bar">
                <div id="player-info-left">
                    <span id="status-name"></span> | LV.<span id="status-level"></span>
                </div>
                <div id="progress-display"></div>
                <div id="player-info-right">
                    <span>목숨:</span>
                    <span id="status-lives"></span>
                    <button id="ultimate-skill-btn" class="btn btn-small btn-ultimate">궁극기</button>
                    <button id="ingame-change-char-btn" class="btn btn-small">캐릭터 변경</button>
                    <button id="back-to-difficulty-btn" class="btn btn-small">메인으로</button>
                </div>
            </div>
            <div id="monster-info-display"></div>
            <div id="temp-message-overlay"></div>
            <canvas id="game-canvas"></canvas>
            <div id="quiz-container">
                <div id="quiz-case"></div>
                <div id="q1-options">
                    <button class="btn quiz-btn" data-answer="O">O (맞다)</button>
                    <button class="btn quiz-btn" data-answer="X">X (틀리다)</button>
                </div>
                <div id="q2-options" style="display: none;"></div>
            </div>
        </div>
        
        <div id="message-modal" class="modal-overlay">
            <div class="modal-content">
                <p id="message-text"></p>
                <button id="message-ok-btn" class="btn">확인</button>
            </div>
        </div>
        
        <div id="instructions-modal" class="modal-overlay">
            <div class="modal-content">
                <h3>게임 설명</h3>
                <ul>
                    <li><strong>목표:</strong> 형법 퀴즈를 풀어 몬스터를 물리치고 던전을 클리어하세요!</li>
                    <li><strong>게임 흐름:</strong>
                        <ol>
                            <li>캐릭터 생성 후, 원하는 난이도를 선택하여 게임을 시작합니다.</li>
                            <li>몬스터가 등장하면 퀴즈가 출제됩니다.</li>
                            <li>퀴즈를 맞혀야 몬스터에게 데미지를 줄 수 있습니다.</li>
                            <li>틀리면 목숨이 1개 줄어듭니다. 목숨이 0이 되면 게임 오버!</li>
                            <li>난이도별 정답 수를 채우면 강력한 보스가 등장합니다.</li>
                        </ol>
                    </li>
                    <li><strong>궁극기:</strong>
                        <ul>
                            <li>각 던전마다 한 번, 퀴즈를 풀지 않고 몬스터를 즉시 처치하는 강력한 기술입니다.</li>
                            <li>'궁극기' 버튼으로 사용하며, 사용 시 해당 문제의 정답과 해설이 표시됩니다.</li>
                            <li>궁극기는 정답 횟수에 포함되지 않습니다.</li>
                            <li>주의: '하', '중', '상' 난이도의 보스에게는 사용할 수 없습니다. ('도전자' 모드에서는 가능)</li>
                        </ul>
                    </li>
                    <li><strong>레벨업:</strong>
                        <ul>
                            <li>각 난이도의 보스를 물리칠 때마다 레벨이 오르며, 공격 및 궁극기 이펙트가 화려해집니다.</li>
                            <li>'도전자' 모드에서 200점 이상 획득 시 최종 레벨인 5레벨에 도달할 수 있습니다.</li>
                        </ul>
                    </li>
                    <li><strong>도전자 모드:</strong> 모든 난이도를 클리어하면 '도전자' 모드가 해금됩니다. 이 모드에서는 3개의 목숨으로 최대한 높은 점수를 기록하는 것에 도전합니다!</li>
                    <li><strong>저장/불러오기:</strong> '게임 저장' 또는 '메인으로' 버튼으로 현재 레벨과 클리어 정보를 저장할 수 있습니다. 메인 화면의 '불러오기'로 이어할 수 있습니다.</li>
                </ul>
                <button id="instructions-close-btn" class="btn">닫기</button>
            </div>
        </div>

        <div id="ingame-char-change-modal" class="modal-overlay">
            <div class="modal-content">
                <h3>캐릭터 변경</h3>
                <p>원하는 직업과 성별을 선택하세요.</p>
                <div class="char-options">
                       <div class="char-card" data-class="전사" data-gender="남">
                           <img src="https://raw.githubusercontent.com/dessa1995/crime/main/mw.png" alt="남자 전사" onerror="this.src='https://placehold.co/100x100/4f4c7a/ecf0f1?text=Warrior'">
                           <p>남자 전사</p>
                       </div>
                    <div class="char-card" data-class="전사" data-gender="여">
                        <img src="https://raw.githubusercontent.com/dessa1995/crime/main/fw.png" alt="여자 전사" onerror="this.src='https://placehold.co/100x100/4f4c7a/ecf0f1?text=Warrior'">
                        <p>여자 전사</p>
                    </div>
                    <div class="char-card" data-class="마법사" data-gender="남">
                        <img src="https://raw.githubusercontent.com/dessa1995/crime/main/mm.png" alt="남자 마법사" onerror="this.src='https://placehold.co/100x100/4f4c7a/ecf0f1?text=Mage'">
                        <p>남자 마법사</p>
                    </div>
                    <div class="char-card" data-class="마법사" data-gender="여">
                        <img src="https://raw.githubusercontent.com/dessa1995/crime/main/fm.png" alt="여자 마법사" onerror="this.src='https://placehold.co/100x100/4f4c7a/ecf0f1?text=Mage'">
                        <p>여자 마법사</p>
                    </div>
                </div>
                <div class="button-group">
                    <button id="confirm-ingame-char-change-btn" class="btn">변경 완료</button>
                    <button id="cancel-ingame-char-change-btn" class="btn">취소</button>
                </div>
            </div>
        </div>

        <div id="fixed-buttons-container">
            <button id="instructions-btn" class="btn btn-small">게임 설명</button>
        </div>
        
        <div id="failsafe-container">
            <button id="force-continue-btn" class="btn btn-small btn-danger">게임 멈춤? (클릭)</button>
        </div>

        <audio id="bgm-audio" src="https://raw.githubusercontent.com/dessa1995/crime/main/bbgm.mp3" loop></audio>

    </div>

    <script>
        // ==================================================================
        // 전역 변수 및 DOM 요소
        // ==================================================================
        const gameContainer = document.getElementById('game-container');
        const screens = document.querySelectorAll('.screen');
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        
        const quizContainer = document.getElementById('quiz-container');
        const quizCaseEl = document.getElementById('quiz-case');
        const q1OptionsEl = document.getElementById('q1-options');
        const q2OptionsEl = document.getElementById('q2-options');

        const messageModal = document.getElementById('message-modal');
        const messageText = document.getElementById('message-text');
        let messageOkBtn = document.getElementById('message-ok-btn');
        const monsterInfoDisplay = document.getElementById('monster-info-display');
        const tempMessageOverlay = document.getElementById('temp-message-overlay');
        const bgmAudioElement = document.getElementById('bgm-audio');
        const progressDisplay = document.getElementById('progress-display');
        const ultimateSkillBtn = document.getElementById('ultimate-skill-btn');
        const failsafeContainer = document.getElementById('failsafe-container');
        const instructionsModal = document.getElementById('instructions-modal');
        const fixedButtonsContainer = document.getElementById('fixed-buttons-container');


        const assets = {
            monsters: {
                '하': 'https://raw.githubusercontent.com/dessa1995/crime/main/monster1.png',
                '중': 'https://raw.githubusercontent.com/dessa1995/crime/main/monster2.png',
                '상': 'https://raw.githubusercontent.com/dessa1995/crime/main/monster3.png',
                '보스': 'https://raw.githubusercontent.com/dessa1995/crime/main/monster4.png'
            },
            characters: {
                '전사_남': 'https://raw.githubusercontent.com/dessa1995/crime/main/mw.png',
                '전사_여': 'https://raw.githubusercontent.com/dessa1995/crime/main/fw.png',
                '마법사_남': 'https://raw.githubusercontent.com/dessa1995/crime/main/mm.png',
                '마법사_여': 'https://raw.githubusercontent.com/dessa1995/crime/main/fm.png'
            },
            misc: {
               'book': 'https://raw.githubusercontent.com/dessa1995/crime/main/book.png'
            }
        };
        const loadedImages = {};

        const skillNames = {
            '전사': {
                1: "강타",
                2: "이중 베기",
                3: "검의 춤",
                4: "십자 가르기",
                5: "멸망의 심판"
            },
            '마법사': {
                1: "마력 화살",
                2: "얼음 송곳",
                3: "연쇄 번개",
                4: "화염 운석",
                5: "원소 폭발"
            }
        };

        const ultimateSkillNames = {
            '전사': {
                1: "폭풍 가르기",
                2: "진 폭풍 가르기",
                3: "검의 비",
                4: "병기 폭풍",
                5: "천벌"
            },
            '마법사': {
                1: "얼음의 비",
                2: "휘몰아치는 폭풍",
                3: "연쇄 번개",
                4: "유성우",
                5: "원소의 격류"
            }
        };

        let gameState = {};
        let effectParticles = [];
        let backgroundParticles = [];
        let gameOverDebris = [];
        let isInputLocked = false;
        let animationFrameId;

        // ==================================================================
        // 퀴즈 데이터
        // ==================================================================
        const quizzes = [
            // 기존 '하' 난이도 퀴즈
            { id: 101, type: 'one-step-ox', difficulty: '하', case: "형법은 범죄와 그에 대한 법적 효과로서 형벌과 보안 처분을 규정한 모든 법 규범을 의미한다.", q1: 'O', explanation: "형법은 넓은 의미에서 범죄와 그에 대한 법적 효과로서 형벌과 보안 처분을 규정한 모든 법 규범의 총체를 의미한다." },
            { id: 102, type: 'one-step-ox', difficulty: '하', case: "실질적 의미의 형법은 ‘형법’이라는 명칭이 붙여진 법률만을 의미한다.", q1: 'X', explanation: "단순히 '형법'이라는 이름의 법률을 지칭하는 것은 형식적 의미의 형법이다." },
            { id: 103, type: 'one-step-ox', difficulty: '하', case: "형법의 보장적 기능은 국가 형벌권의 자의적 행사로부터 국민의 자유와 권리를 보장한다.", q1: 'O', explanation: "형법은 형법에 규정되지 아니한 행위는 범죄가 되지 않고 처벌받지 않도록 보장하며, 규정된 형벌의 종류와 양을 넘어서서 처벌받지 않도록 함으로써 국가 형벌권으로부터 국민의 자유와 권리를 보장하는 보장적 기능을 수행한다." },
            { id: 104, type: 'one-step-ox', difficulty: '하', case: "「도로교통법」에 규정된 벌칙 조항은 실질적 의미의 형법에 해당하지 않는다.", q1: 'X', explanation: "「도로교통법」과 같이 법의 명칭이나 형식을 불문하고 범죄와 그에 대한 법적 효과로서 형벌과 보안 처분을 규정한 모든 법 규범은 실질적 의미의 형법에 해당한다." },
            { id: 105, type: 'one-step-ox', difficulty: '하', case: "죄형 법정주의는 미리 성문의 법률에 규정되어 있지 않은 행위에 대해서도 처벌을 가능하게 하는 원칙이다.", q1: 'X', explanation: "죄형 법정주의는 어떠한 행위가 범죄이고 그 범죄를 어떻게 처벌할 것인지 미리 성문의 법률로 규정되어야 한다는 원칙이다." },
            { id: 106, type: 'one-step-ox', difficulty: '하', case: "관습 형법 금지의 원칙에 따라 불문법인 관습법을 근거로 처벌할 수 없다.", q1: 'O', explanation: "관습 형법 금지의 원칙은 의회에서 제정한 성문법이 아닌 불문법인 관습법을 근거로는 처벌할 수 없다는 원칙이다." },
            { id: 107, type: 'one-step-ox', difficulty: '하', case: "소급효 금지의 원칙은 행위자에게 불리한 소급효만 허용하지 않고, 행위자에게 유리한 소급효는 허용한다.", q1: 'O', explanation: "소급효 금지의 원칙은 범죄와 형벌이 행위 당시 법률에 규정되어 있어야 하며, 행위 이후에 제정한 법률로는 소급하여 처벌할 수 없다는 것을 의미하지만, 행위자에게 유리한 소급효는 예외적으로 허용된다." },
            { id: 108, type: 'one-step-ox', difficulty: '하', case: "명확성의 원칙은 범죄의 구성 요건과 형벌이 불명확하게 규정되어도 무방하다고 본다.", q1: 'X', explanation: "명확성의 원칙은 법률이 처벌하고자 하는 행위가 무엇이며 그에 대해 어떤 형벌이 부과되는지를 누구나 예견할 수 있도록 범죄의 구성 요건과 형벌을 명확하게 규정하여야 한다는 원칙이다." },
            { id: 109, type: 'one-step-ox', difficulty: '하', case: "유추 해석 금지의 원칙은 법률에 규정이 없는 사항에 대해 유사한 성질의 법률을 적용하여 행위자에게 불리한 새로운 구성 요건을 만들 수 없다는 원칙이다.", q1: 'O', explanation: "유추 해석 금지의 원칙은 범죄 행위가 형법에 명확히 규정되어 있지 않은 때에 유사한 규정을 적용해서는 행위자에게 불리하게 적용해서는 안 된다는 원칙이다." },
            { id: 110, type: 'one-step-ox', difficulty: '하', case: "적정성의 원칙은 범죄가 되는 행위와 그에 따른 형벌의 질과 양이 비례해야 한다는 원칙이다.", q1: 'O', explanation: "적정성의 원칙은 범죄가 되는 행위와 그에 따른 형벌의 질과 양이 비례하여야 한다는 원칙으로, 비례성의 원칙 또는 과잉 금지의 원칙이라고도 한다." },
            { id: 111, type: 'one-step-ox', difficulty: '하', case: "범죄의 3단계 성립 요건은 구성 요건 해당성, 위법성, 책임이다.", q1: 'O', explanation: "범죄가 성립하기 위해서는 구성 요건 해당성, 위법성, 책임이라는 세 가지 요건이 충족되어야 한다." },
            { id: 112, type: 'one-step-ox', difficulty: '하', case: "위법성 조각 사유는 구성 요건에 해당하는 행위의 위법성을 배제하는 특별한 사유이다.", q1: 'O', explanation: "위법성 조각 사유는 구성 요건에 해당하는 행위의 위법성을 배제하는 특별한 사유이다." },
            { id: 113, type: 'one-step-ox', difficulty: '하', case: "자구행위는 현재의 부당한 법익 침해로부터 자신이나 타인의 법익을 방위하기 위한 상당한 이유가 있는 행위이다.", q1: 'X', explanation: "자기 또는 타인의 법익에 대한 현재의 부당한 침해를 방위하기 위한 상당한 이유가 있는 행위는 정당방위다." },
            { id: 114, type: 'one-step-ox', difficulty: '하', case: "긴급 피난은 자기 또는 타인의 법익에 대한 현재의 위난을 피하기 위한 행위로 상당한 이유가 있는 경우에 해당한다.", q1: 'O', explanation: "긴급 피난은 자기 또는 타인의 법익에 대한 현재의 위난을 피하기 위한 행위로 상당한 이유가 있는 경우이다." },
            { id: 115, type: 'one-step-ox', difficulty: '하', case: "14세 미만인 사람의 행위는 위법성 조각 사유에 해당한다.", q1: 'X', explanation: "14세 미만인 사람의 행위는 책임 조각 사유에 해당하여 범죄가 성립하지 않는다." },
            { id: 116, type: 'one-step-ox', difficulty: '하', case: "형벌은 국가가 범죄 행위를 저지른 사람에게 가하는 법익 박탈로서의 제재이다.", q1: 'O', explanation: "형벌은 국가가 범죄 행위를 저지른 사람에게 가하는 제재로, 법익의 박탈을 내용으로 한다." },
            { id: 117, type: 'one-step-ox', difficulty: '하', case: "사형은 생명을 빼앗는 형벌에 해당한다.", q1: 'O', explanation: "사형은 생명을 빼앗는 생명형에 해당한다." },
            { id: 118, type: 'one-step-ox', difficulty: '하', case: "보호 관찰은 교정 시설에 수용하지 않고 사회생활을 허용하면서 보호 관찰관의 지도·감독을 받는 보안 처분이다.", q1: 'O', explanation: "보호 관찰은 형의 집행 유예나 선고 유예를 받거나 가석방되는 경우 등을 대상으로 교정 시설에 수용하지 않고 사회생활을 허용하면서 보호 관찰관의 지도·감독을 통해 사회 복귀를 촉진하는 제도이다." },
            { id: 119, type: 'one-step-ox', difficulty: '하', case: "형사 절차에서 피의자와 피고인은 자신에게 불리한 진술을 거부할 수 있는 진술 거부권을 가진다.", q1: 'O', explanation: "모든 형사 절차에서 피의자와 피고인은 자신에게 불리한 진술을 거부할 수 있는 진술 거부권을 가진다." },
            { id: 120, type: 'one-step-ox', difficulty: '하', case: "재심 제도는 하급법원의 재판 결과에 불복하여 재판 당사자가 상급 법원에 다시 재판할 것을 청구하는 제도이다.", q1: 'X', explanation: "재심 제도는 유죄의 확정 판결에 중대한 사실 오인이 있는 경우 그 오류를 시정하여 무고한 자의 이익을 구제하여 주는 제도이다." },
            { id: 121, type: 'one-step-ox', difficulty: '하', case: "검사가 공소를 제기하지 않는 처분을 불기소 처분이라고 한다.", q1: 'O', explanation: "수사 결과 피의자의 범죄 혐의가 인정되어도 검사가 공소를 제기하지 않는 처분을 불기소 처분이라고 한다." },
            { id: 122, type: 'one-step-ox', difficulty: '하', case: "피고인이 유죄 판결을 받을 때까지는 무죄로 추정된다는 원칙은 모든 형사 절차에 적용되는 인권 보장 원칙이다.", q1: 'O', explanation: "무죄 추정의 원칙은 모든 형사 절차에서 피고인이 유죄 판결이 확정될 때까지 무죄로 추정되는 인권 보장 원칙이다." },
            { id: 123, type: 'one-step-ox', difficulty: '하', case: "심신상실자의 행위는 책임 조각 사유에 해당한다.", q1: 'O', explanation: "책임 능력이 없다고 보기 때문에 범죄가 성립하지 않음." },
            { id: 124, type: 'one-step-ox', difficulty: '하', case: "형사 미성년자는 만 13세 이하를 의미한다.", q1: 'X', explanation: "우리나라는 14세 미만을 형사 미성년자로 본다." },
            { id: 125, type: 'one-step-ox', difficulty: '하', case: "피해자의 명시적 동의가 있으면 어떤 범죄든 처벌받지 않는다.", q1: 'X', explanation: "동의가 있다고 해도 법률상 허용되지 않는 경우 처벌됨." },
            { id: 126, type: 'one-step-ox', difficulty: '하', case: "심신미약자는 항상 책임이 조각된다.", q1: 'X', explanation: "일부 책임은 인정되며, 형이 감경될 수 있다." },
            { id: 127, type: 'one-step-ox', difficulty: '하', case: "정당방위는 반드시 자기 자신을 보호할 때만 인정된다.", q1: 'X', explanation: "타인의 법익을 방어하는 경우도 포함된다." },
            
            // 기존 '중' 난이도 퀴즈
            { id: 201, type: 'single', difficulty: '중', case: "다음 중 형법의 보충성 원칙을 가장 잘 설명하는 것은?", q2: ["형법은 사회 윤리적 행위 가치를 보호하는 기능을 한다.", "형법은 국가 형벌권 남용으로부터 국민의 자유와 권리를 보장한다.", "법익을 보호하기 위해 다른 수단이 있다면 그것을 먼저 행사하고 형법은 가장 마지막 수단으로 발동되어야 한다.", "형법은 범죄 행위로 인해 얻는 이익과 형벌이라는 불이익을 통해 국민이 자신의 행위를 결정하게 하는 역할을 한다."], answerIndex: 2, explanation: "형법의 보충성 또는 최후 수단성은 형벌이 국가의 가장 강력한 물리력 행사로서, 그러한 법익을 보호하기 위한 다른 수단이 있다면 그것을 먼저 행사하고 형법은 가장 마지막 수단으로 발동되어야 함을 의미한다." },
            { id: 202, type: 'single', difficulty: '중', case: "다음 중 죄형 법정주의의 파생 원칙인 소급효 금지의 원칙에 대한 설명으로 옳지 않은 것은?", q2: ["범죄와 형벌은 행위 당시 법률에 규정되어 있어야 한다.", "행위 이후에 제정된 법률로는 소급하여 처벌할 수 없다.", "행위자에게 불리한 경우에도 소급효가 허용된다.", "재판 시의 법이 행위 시의 법보다 경할 때에는 재판 시의 법을 적용한다."], answerIndex: 2, explanation: "소급효 금지의 원칙은 행위자에게 불리한 소급효를 금지하는 것이 원칙이다. 다만, 행위자에게 유리한 소급효는 예외적으로 허용된다. 따라서 행위자에게 불리한 경우에도 소급효가 허용된다는 설명은 옳지 않다." },
            { id: 203, type: 'single', difficulty: '중', case: "다음 중 유추 해석 금지의 원칙에 위배되는 사례는?", q2: ["법에 규정된 '상해'에 '정신적 고통'을 포함하여 해석하더라도 행위자에게 불리하지 않은 경우", "형법에 명시된 '절도'에 '컴퓨터를 이용한 정보 탈취'를 포함하는 새로운 범죄 유형을 법률로 명확히 규정한 경우", "명확하지 않은 조항을 입법 취지에 맞게 합리적으로 해석하여 적용한 경우", "범죄 행위가 유사하지만 형법에 명확히 규정되어 있지 않은 때에 유사한 규정을 적용하여 행위자에게 불리하게 형을 가중한 경우"], answerIndex: 3, explanation: "유추 해석 금지의 원칙은 법률에 규정이 없는 사항에 대해 유사한 성질의 법률을 적용하여 행위자에게 불리한 새로운 구성 요건을 만들거나 형을 가중할 수 없다는 원칙이다. ①과 ③은 허용될 수 있는 법 해석이며, ②는 새로운 법률 제정의 문제이다." },
            { id: 204, type: 'single', difficulty: '중', case: "다음 중 범죄의 3단계 성립 요건에 해당하지 않는 것은?", q2: ["구성 요건 해당성", "위법성", "책임", "도덕적 비난 가능성"], answerIndex: 3, explanation: "범죄의 3단계 성립 요건은 구성 요건 해당성, 위법성, 책임이다. 도덕적 비난 가능성은 범죄의 성립 요건에 직접 해당하지 않는다." },
            { id: 205, type: 'single', difficulty: '중', case: "甲은 자신의 집 마당에서 삽으로 땅을 파던 중 실수로 이웃집의 수도관을 파손시켰다. 이 경우 甲의 행위에 대한 형법상 처벌 가능성은? (단, 甲에게 고의는 없었으며, 과실에 의한 수도관 파손에 대한 특별한 처벌 규정은 없다고 가정한다.)", q2: ["甲은 재물 손괴죄로 처벌받는다.", "甲은 과실에 의한 재물 손괴죄로 처벌받는다.", "甲은 형법상 재물 손괴죄의 구성 요건에 해당하지 않아 처벌받지 않는다.", "甲은 민사상 손해 배상 책임도 지고 형사 처벌도 받게 된다."], answerIndex: 2, explanation: "형법은 고의범을 처벌하는 것을 원칙으로 하며, 예외적으로 과실범을 처벌하는 규정이 있는 경우에만 처벌한다. 과실에 의한 재물 손괴에 대한 처벌 규정이 없다면, 甲에게 고의가 없으므로 형법상 구성 요건에 해당하지 않아 처벌받지 않는다. (참고: 민사상 손해배상 책임은 별개로 발생할 수 있으나, 이 문제는 형법상 처벌 가능성을 묻고 있다.)" },
            { id: 206, type: 'single', difficulty: '중', case: "다음 중 위법성 조각 사유에 해당하지 않는 것은?", q2: ["정당방위", "긴급 피난", "강요된 행위", "자구 행위"], answerIndex: 2, explanation: "강요된 행위는 책임 조각 사유에 해당한다. 정당방위, 긴급 피난, 자구 행위는 위법성 조각 사유에 해당한다." },
            { id: 207, type: 'single', difficulty: '중', case: "형벌의 종류 중 신체의 자유를 빼앗는 자유형에 해당하지 않는 것은?", q2: ["징역", "금고", "구류", "자격 상실"], answerIndex: 3, explanation: "징역, 금고, 구류는 신체의 자유를 빼앗는 자유형에 해당한다. 자격 상실은 명예형에 해당한다." },
            { id: 208, type: 'single', difficulty: '중', case: "다음 중 보안 처분의 특징으로 옳지 않은 것은?", q2: ["범죄자의 재사회화를 위한 대안적 제재 수단이다.", "과거의 불법에 대한 책임을 전제로 한다.", "장래의 위험성으로부터 행위자를 보호하고 사회를 방위하기 위한 예방적 조치이다.", "부과 요건이나 절차 등에 있어서 적법 절차의 원리가 준수되어야 한다."], answerIndex: 1, explanation: "보안 처분은 과거의 불법에 대한 책임을 전제로 하는 형벌과 달리, 장래의 위험성으로부터 행위자를 보호하고 사회를 방위하기 위한 합목적적인 예방적 조치이다." },
            { id: 209, type: 'single', difficulty: '중', case: "형사 절차의 진행 순서로 가장 적절한 것은?", q2: ["공판 절차 → 수사 절차 → 형 집행 절차", "수사 절차 → 공판 절차 → 형 집행 절차", "형 집행 절차 → 수사 절차 → 공판 절차", "수사 절차 → 형 집행 절차 → 공판 절차"], answerIndex: 1, explanation: "형사 절차는 범죄가 발생하였을 때 이를 수사·심판하고 선고된 형을 집행하는 과정으로, 수사 절차 → 공판 절차 → 형 집행 절차의 순서로 진행된다." },
            { id: 210, type: 'single', difficulty: '중', case: "검사의 불기소 처분 중 피의 사실은 인정되나 피의자의 연령이나 지능, 피해자와의 관계, 범행의 동기나 수단, 범행의 결과 등을 참작하여 소추할 필요가 없는 경우는?", q2: ["기소 유예", "혐의 없음", "죄가 안 됨", "공소권 없음"], answerIndex: 0, explanation: "기소 유예는 피의 사실이 인정되나 피의자의 제반 사정을 참작하여 소추할 필요가 없는 경우 검사가 공소를 제기하지 않는 불기소 처분이다." },
            { id: 211, type: 'single', difficulty: '중', case: "법원이 피고인의 유죄를 인정하면서도 정상을 참작하여 형의 선고를 미루는 것으로, 유예된 날로부터 일정 기간을 경과하면 형의 선고가 없었던 것으로 간주되는 것은?", q2: ["실형", "집행 유예", "선고 유예", "가석방"], answerIndex: 2, explanation: "선고 유예는 형의 선고 자체를 미루었다가 2년이 지나면 형의 선고가 없었던 것으로 간주하는 제도이다." },
            { id: 212, type: 'single', difficulty: '중', case: "우리나라의 국민 참여 재판에 대한 설명으로 옳은 것은?", q2: ["배심원의 평결은 법원을 기속한다.", "모든 형사 재판에 의무적으로 적용된다.", "배심원은 직업 법관과 동등한 권한으로 사실 문제 및 법률 문제를 판단한다.", "배심원은 양형에 관한 의견을 밝힐 수 있으나, 양형 결정에 직접 참여하여 판결하는 것은 아니다."], answerIndex: 3, explanation: "우리나라 국민 참여 재판에서 배심원의 평결은 법원을 기속하지 않고 권고적 효력만을 가지며, 양형에 관하여 의견을 밝힐 수 있으나 표결을 통해 양형 결정에 참여하는 것은 아니다." },
            { id: 213, type: 'single', difficulty: '중', case: "형사 절차상 인권 보장을 위한 원칙 중 '유죄 판결이 확정될 때까지 무죄로 추정한다'는 원칙은?", q2: ["적법 절차의 원칙", "진술 거부권", "변호인의 조력을 받을 권리", "무죄 추정의 원칙"], answerIndex: 3, explanation: "유죄 판결이 확정될 때까지 피의자나 피고인을 무죄로 추정하는 원칙은 무죄 추정의 원칙이다." },
            { id: 214, type: 'single', difficulty: '중', case: "위법 수집 증거 배제 법칙의 내용으로 옳은 것은?", q2: ["고문, 폭행 등으로 임의로 진술한 것이 아니라고 의심되는 자백은 증거 능력이 없다.", "자백이 불이익한 유일한 증거인 때에는 유죄의 증거로 할 수 없다.", "위법한 절차에 의하여 수집된 증거는 증거 능력이 없다.", "경험한 사실을 경험자가 직접 구두로 법원에 보고하지 않은 간접 증거는 원칙적으로 증거 능력이 없다."], answerIndex: 2, explanation: "위법 수집 증거 배제 법칙은 위법한 절차에 의해 수집된 증거는 증거 능력이 없다는 원칙이다. ①은 자백 배제 법칙, ②는 자백 보강 법칙, ④는 전문 법칙에 해당한다." },
            { id: 215, type: 'single', difficulty: '중', case: "범죄 피해자가 가해자에게 신속하고 간편하게 손해 배상을 받을 수 있도록 하는 제도는?", q2: ["범죄 피해자 구조 제도", "배상 명령 제도", "형사 보상 제도", "명예 회복 제도"], answerIndex: 1, explanation: "배상 명령 제도는 범죄 피해자가 가해자에게 신속하고 간편하게 손해 배상을 받을 수 있도록 하는 제도이다." },
            { id: 216, type: 'single', difficulty: '중', case: "다음 중 형벌에 대한 설명으로 옳지 않은 것은?", q2: ["사형은 생명을 빼앗는 생명형에 해당한다.", "징역은 교정 시설에 수용하여 노역에 복무하게 하는 자유형이다.", "벌금은 재산을 빼앗는 재산형에 해당하며, 원칙적으로 5만 원 이상이다.", "자격 정지는 공무원이 되는 자격이나 선거권 등을 영구적으로 박탈하는 명예형이다."], answerIndex: 3, explanation: "자격 정지는 일정 기간 자격을 정지하는 것이며, 영구적으로 박탈하는 것은 자격 상실입니다." },
            { id: 217, type: 'single', difficulty: '중', case: "소년 보호 사건의 처리 절차에 대한 설명으로 옳지 않은 것은?", q2: ["19세 미만의 소년에게는 성인 범죄자와 다른 재판 절차와 형 집행 절차를 거칠 수 있다.", "사건의 경중에 따라 보호 관찰, 소년원 송치 등의 보호 처분을 받을 수 있다.", "가정법원소년부에서 재판을 통해 소년범에게 직접 형벌을 부과할 수 없다.", "소년범은 소년 교도소에 수용될 수 있으나, 소년원에는 수용될 수 없다."], answerIndex: 3, explanation: "소년범은 범죄의 경중에 따라 소년 교도소에 수용될 수도 있고, 가정 법원 소년부에서 소년 보호 처분을 받은 경우 소년원에 수용될 수도 있다. ①, ②, ③은 소년 보호 사건 처리 절차의 특칙에 대한 설명으로 옳다." },
            { id: 218, type: 'single', difficulty: '중', case: "형벌의 종류 중, 교정 시설에 수용하되 노역을 부과하지 않는 형벌은?", q2: ["징역", "금고", "구류", "벌금"], answerIndex: 1, explanation: "금고는 1개월 이상 교정 시설에 수용하여 집행하지만 노역을 부과하지 않는다. 구류도 노역을 부과하지 않으나 기간이 1일 이상 30일 미만으로 제한된다. 징역은 교정 시설에 수용하여 정해진 노역에 복무하게 한다." },
            { id: 219, type: 'single', difficulty: '중', case: "갑은 귀가 도중 모르는 사람이 흉기를 들고 위협하자, 반사적으로 상대방의 손을 가격해 상해를 입혔다. 이 경우 갑의 행위는 위법성이 조각되는지 판단해야 한다. 이 사례에 적용될 수 있는 법적 개념은?", q2: ["자구행위", "정당방위", "긴급피난", "피해자의 승낙"], answerIndex: 1, explanation: "현재의 부당한 침해에 대하여 자기 또는 타인의 법익을 보호하기 위한 상당한 방어행위는 정당방위로서 위법성이 조각된다." },
            { id: 220, type: 'single', difficulty: '중', case: "을은 심한 정신질환으로 인해 현실 판단 능력을 상실한 상태에서 행인을 폭행하였다. 이 경우 법적으로 가장 적절한 판단은?", q2: ["범죄가 성립하며, 형이 감경된다.", "범죄가 성립하며, 위법성이 조각된다.", "범죄가 성립하지 않는다.", "책임이 인정되며, 벌금형이 가능하다."], answerIndex: 2, explanation: "심신상실자의 경우 책임 능력이 인정되지 않으므로 구성요건 해당성과 위법성이 있어도 범죄는 성립하지 않는다." },
            { id: 221, type: 'single', difficulty: '중', case: "병은 자신에게 빌린 돈을 갚지 않고 해외로 도주 중인 범인을 붙잡아 경찰이 오기 전까지 신체를 강제로 구속하였다. 병의 행위에 대한 법적 평가로 가장 적절한 것은?", q2: ["고의 없는 과실범으로 처벌된다.", "자구행위로 위법성이 조각될 수 있다.", "정당방위에 해당한다.", "구성요건 해당성이 없어 처벌 대상이 아니다."], answerIndex: 1, explanation: "자구행위는 청구권의 보전을 위한 불가피한 행위로 인정되며, 일정 요건을 갖춘 경우 위법성이 조각될 수 있다." },
            { id: 222, type: 'single', difficulty: '중', case: "정은 생명을 위협하는 급박한 화재 현장에서 대피하던 중, 다른 사람의 창고 문을 부수고 진입하여 피난하였다. 이 경우 정에게 가장 적절한 법적 평가 기준은?", q2: ["긴급피난", "정당방위", "피해자의 승낙", "심신미약"], answerIndex: 0, explanation: "생명이나 신체에 대한 현재의 위난을 피하기 위한 상당한 행위는 긴급피난에 해당하여 위법성이 조각될 수 있다." },
            { id: 223, type: 'single', difficulty: '중', case: "만 13세인 미성년자 무는 분노를 참지 못하고 친구의 휴대전화를 고의로 파손하였다. 이 경우 무의 법적 책임은?", q2: ["구성요건해당성이 없으므로 범죄가 아니다.", "형사 미성년자이므로 범죄가 성립하지 않는다.", "과실행위이므로 경범죄 처벌이 가능하다.", "위법성이 조각되어 처벌되지 않는다."], answerIndex: 1, explanation: "형법상 만 14세 미만은 형사 미성년자로 규정되며, 책임 능력이 없어 범죄 성립이 부정된다." },
            { id: 224, type: 'single', difficulty: '중', case: "심한 불안장애를 앓고 있는 기는 타인의 위협에 대해 지나치게 과잉 반응하며 폭력을 행사하였다. 조사 결과 기는 사물 변별 능력은 있으나 충동 조절이 어려운 상태였다. 이 경우 기에게 적용될 수 있는 법적 개념은?", q2: ["심신상실", "심신미약", "피해자의 승낙", "고의 없음"], answerIndex: 1, explanation: "사물을 변별할 수는 있으나 의사결정 능력이나 행동 통제력이 떨어지는 경우 심신미약으로 간주하며, 형이 감경될 수 있다." },
            { id: 225, type: 'single', difficulty: '중', case: "A는 폭행을 가한 상대방에게 보복 차원에서 며칠 뒤 찾아가 다시 폭력을 행사하였다. 이 행위에 대한 법적 판단으로 옳은 것은?", q2: ["정당방위에 해당하므로 위법성이 조각된다.", "현재의 위난이 존재하므로 긴급피난이다.", "자구행위에 해당한다.", "위법성이 조각되지 않는다."], answerIndex: 3, explanation: "정당방위, 긴급피난, 자구행위 모두 ‘현재성’이 요건이므로, 사후의 보복 행위는 위법성이 조각되지 않는다." },
            { id: 226, type: 'single', difficulty: '중', case: "A는 타인의 소중한 물건을 고의로 훼손했으나, 피해자가 \"괜찮다\"고 명시적으로 동의한 사실이 확인되었다. 다만 훼손된 물건은 공공 미술재산이었다. A의 행위에 대해 적용될 수 있는 판단은?", q2: ["피해자의 승낙에 의해 위법성이 조각된다.", "피해자의 승낙은 공공재산에 대해 유효하므로 책임이 없다.", "공공의 법익에 대한 동의는 효력이 없으므로 위법하다.", "정당방위로 볼 수 있다."], answerIndex: 2, explanation: "피해자의 승낙은 자기 법익에만 미치며, 공공의 법익에 관한 동의는 원칙적으로 위법성을 조각하지 못한다." },
            { id: 227, type: 'single', difficulty: '중', case: "A는 자신이 구입한 중고차가 고장이 많자 판매자에게 강하게 항의했고, 급기야 판매자의 차량을 발로 찼다. 이후 A는 자신이 차량 하자에 따른 청구권을 가지고 있다고 주장하였다. 법적 평가로 가장 타당한 것은?", q2: ["청구권이 있다면 어떤 방법으로든 실현 가능하다.", "자구행위 요건을 충족하므로 위법하지 않다.", "법적 절차가 가능한 경우 자구행위는 허용되지 않는다.", "형사 미성년자이면 범죄가 되지 않는다."], answerIndex: 2, explanation: "자구행위는 법적 구제가 불가능하거나 매우 곤란한 경우에 한하여 정당화된다." },
            { id: 228, type: 'single', difficulty: '중', case: "B는 자신의 아들을 납치한 납치범의 강요로 인해 어쩔 수 없이 C를 폭행하였다. 이 경우 법적으로 타당한 평가는?", q2: ["심신상실 상태이므로 범죄가 성립하지 않는다.", "강요된 행위로 책임이 조각되어 처벌되지 않는다.", "고의성이 없으므로 처벌되지 않는다.", "긴급피난 상태이므로 위법하지 않다."], answerIndex: 1, explanation: "음주로 인한 판단 능력 저하는 심신미약으로 평가될 수 있으며, 형의 감경 사유에 해당한다." },
            // 기존 '상' 난이도 퀴즈
            { id: 301, type: 'two-step', difficulty: '상', case: "형법의 규범적 기능은 국민에게 행위의 준칙으로 삼도록 하고, 법관에게는 범죄 성립 여부를 판단하는 평가 규범으로서의 역할을 한다.", q1: 'O', q2_question: "다음은 어떤 사람이 법정에서 '범죄인 줄 몰랐다'고 주장했으나 처벌받은 사례입니다. 이 사례를 통해 알 수 있는 형법의 기능으로 가장 적절한 것은?", q2: ["보호적 기능", "보장적 기능", "규범적 기능", "보충적 기능"], answerIndex: 2, explanation: "국민이 준수해야 할 행위 준칙을 제시하고, 법관에게는 판단 기준을 제공하는 규범적 기능에 해당한다." },
            { id: 302, type: 'two-step', difficulty: '상', case: "형법 제243조는 '음란한 문서, 도화, 필름, 그 밖의 물건을 공공연하게 전시한 자'를 처벌하도록 규정하고 있으나, '음란'의 개념이 명확히 정의되어 있지 않다. 이에 따라 A가 성인용 만화를 출판한 사건에서, 법원은 해당 만화가 예술성과 표현의 자유를 고려할 때 명백한 음란물로 단정하기 어렵고, '음란'이라는 용어 자체가 불명확하다는 이유로 무죄를 선고하였다. 법원의 판단은 죄형법정주의 원칙에 어긋나는가?", q1: 'X', q2_question: "이 사례에서 법원의 판단 근거가 된 죄형 법정주의의 원칙은 무엇입니까?", q2: ["관습 형법 금지의 원칙", "소급효 금지의 원칙", "명확성의 원칙", "유추 해석 금지의 원칙"], answerIndex: 2, explanation: "'음란'이라는 용어가 모호하여 법 적용이 어려웠던 사례로, 죄형 법정주의의 명확성 원칙을 보여준다." },
            { id: 303, type: 'two-step', difficulty: '상', case: "범죄가 성립하려면 고의가 요구되며, 과실에 의한 행위는 특별한 규정이 있는 경우에만 처벌된다. 따라서 과실에 의한 행위는 어떤 경우에도 형법상 범죄가 성립하지 않는다.", q1: 'X', q2_question: "다음 중 과실범 처벌 규정이 없어 범죄로 성립하지 않는 사례는?", q2: ["자기의 물건과 비슷한 타인의 물건을 고의로 훔치려 한 경우", "실수로 타인의 물건을 파손했으나 과실범 처벌 규정이 없는 경우", "법률상 금지된 행위임을 알면서 저지른 경우", "금전적 이득을 목적으로 타인을 속여 재산을 편취한 경우"], answerIndex: 1, explanation: "과실에 의한 행위라도 법에 명시된 처벌 규정이 있어야만 범죄로 성립한다." },
            { id: 304, type: 'two-step', difficulty: '상', case: "피해자의 승낙이 있다고 하여 모든 경우에 위법성이 조각되는 것은 아니다. 따라서 피해자의 승낙이 있는 경우 위법성은 항상 조각된다.", q1: 'X', q2_question: "다음 중 피해자의 승낙에도 불구하고 위법성이 조각되지 않아 범죄가 성립하는 사례는?", q2: ["의사의 수술로 상해를 입힌 경우", "채무자가 동의했지만 신체 일부를 취득한 경우", "조난자를 위해 타인의 집에 침입한 경우", "15세 미성년자의 성적 자기결정권 동의가 있는 경우"], answerIndex: 1, explanation: "사회 통념상 용인될 수 없는 경우(예: 신체 일부를 강제로 취득)는 승낙이 있어도 위법성이 조각되지 않는다." },
            { id: 305, type: 'two-step', difficulty: '상', case: "형벌의 종류 중 재산형에는 벌금, 과료, 몰수가 포함된다.", q1: 'O', q2_question: "다음 중 재산형에 해당하지 않는 형벌은?", q2: ["벌금 5,000만 원", "과료 30,000원", "몰수", "자격 정지 1년"], answerIndex: 3, explanation: "자격 정지는 인격이나 자격을 제한하는 명예형이다." },
            { id: 306, type: 'two-step', difficulty: '상', case: "소년 보호 처분에는 보호 관찰, 소년원 송치 등이 포함되며, 이는 형벌이 아닌 보호 처분의 일종이다.", q1: 'O', q2_question: "다음 중 「소년법」상 소년에게 사형 또는 무기형이 선고될 경우 적용되는 특칙은?", q2: ["사형 또는 무기형이 그대로 집행된다.", "사형 또는 무기형 대신 15년의 유기 징역으로 한다.", "23세가 될 때까지 소년 교도소에 수용된다.", "소년 보호 처분으로 소년원에 송치된다."], answerIndex: 1, explanation: "형법상 만 18세 미만인 소년에게는 사형·무기형을 선고할 수 없으며, 유기징역 15년으로 대체된다." },
            { id: 307, type: 'two-step', difficulty: '상', case: "기소 독점주의는 검사만이 공소 제기를 할 수 있도록 하는 제도이다.", q1: 'O', q2_question: "검사의 불기소 처분에 불복하여 재판을 요청할 수 있는 절차는?", q2: ["배상 명령 제도", "재정 신청 제도", "형사 보상 제도", "국민 참여 재판"], answerIndex: 1, explanation: "재정 신청 제도는 검사의 불기소에 대한 피해자의 불복 절차다." },
            { id: 308, type: 'two-step', difficulty: '상', case: "형사 재판에서 법관은 양심에 따라 판단한다. 따라서 형사 재판에서 법관은 증거 없이도 판결을 선고할 수 있다.", q1: 'X', q2_question: "다음 중 형사 절차상 증거 관련 원칙으로 옳지 않은 것은?", q2: ["증거 재판주의: 사실의 인정은 증거에 의하여야 한다.", "자백 배제 법칙: 고문 등으로 자백한 경우에도 증거로 사용 가능하다.", "독수독과의 원칙: 위법하게 수집된 증거에 의한 2차 증거도 무효이다.", "자백 보강 법칙: 자백만으로는 유죄 증거가 될 수 없다."], answerIndex: 1, explanation: "자백은 고문이나 협박에 의해 이끌어졌다면 증거능력을 인정할 수 없다." },
            { id: 309, type: 'two-step', difficulty: '상', case: "피의자나 피고인이 반드시 구속 상태에서 재판을 받는 것은 아니다.", q1: 'O', q2_question: "다음 중 수사 단계에서 피의자 인권 보장을 위한 제도가 아닌 것은?", q2: ["불구속 수사 원칙", "영장주의", "구속 적부심 제도", "보석 제도"], answerIndex: 3, explanation: "보석 제도는 공판 단계에서 피고인에게 적용되는 제도다." },
            { id: 310, type: 'two-step', difficulty: '상', case: "형법에서는 두 개 이상의 같은 종류의 형(예: 징역형)에 대해 형을 정할 때, 가장 무거운 죄의 형에 그 형의 절반까지를 더해 처벌할 수 있도록 하고 있다.", q1: 'O', q2_question: "甲은 특수절도죄(최고 징역 5년)와 사기죄(최고 징역 3년)를 함께 저질렀다. 두 범죄 모두 징역형으로 가능한 같은 종류의 형벌이 부과될 수 있다. 형법 규정에 따라 甲이 받을 수 있는 최대 징역 형량은?", q2: ["5년", "7년 6개월", "8년", "50년"], answerIndex: 1, explanation: "두 범죄가 모두 징역형이므로 같은 종류의 형에 해당한다. 이 경우 형법상 가장 무거운 죄인 특수절도죄(최고 5년)에 그 절반인 2년 6개월을 더해 최대 7년 6개월까지 처벌할 수 있다. 다른 범죄의 형량을 단순히 더하는 것이 아니라, 가장 무거운 죄 기준으로 계산하는 점이 핵심이다." },
            { id: 311, type: 'two-step', difficulty: '상', case: "갑은 밤늦게 귀가하던 중 자신에게 흉기를 휘두르며 금품을 요구하는 강도 을을 만났다. 갑은 을의 공격을 막기 위해 우산으로 반격했고, 이로 인해 을은 골절상을 입었다. 이 경우 갑의 행위는 범죄로 성립한다.", q1: 'X', q2_question: "위 사례에서 갑의 행위에 해당하는 위법성 조각 사유는 무엇인가?", q2: ["긴급 피난", "정당방위", "자구 행위", "정당 행위"], answerIndex: 1, explanation: "현재의 부당한 침해에 대한 자기방어이므로 정당방위에 해당한다." },
            { id: 312, type: 'two-step', difficulty: '상', case: "등산객 갑은 산에서 멧돼지 떼를 만나 위협을 느끼고, 옆에 있던 다른 등산객 을의 텐트 뒤로 몸을 숨겼다. 그 과정에서 텐트가 손상되었다. 이 경우 갑의 행위는 형법상 정당화될 수 있다.", q1: 'O', q2_question: "위 사례에서 갑의 행위에 해당하는 위법성 조각 사유는 무엇인가?", q2: ["정당방위", "긴급 피난", "자구 행위", "정당 행위"], answerIndex: 1, explanation: "자기 법익에 대한 현재의 위난을 피하기 위한 상당한 이유 있는 행위로서 긴급피난에 해당한다." },
            { id: 313, type: 'two-step', difficulty: '상', case: "택배 기사인 갑은 졸음을 이기지 못해 법정 제한 속도를 일시 초과하며 운전했다. 인명 피해는 없었지만 도로교통법 위반으로 단속되었다. 이 경우 갑의 행위는 정당한 사유에 의해 위법성이 조각된다.", q1: 'X', q2_question: "위 사례에서 갑의 행위가 위법성 조각 사유에 해당한다고 보기 어려운 가장 적절한 이유는?", q2: ["정당방위 요건을 충족하지 못했기 때문이다.", "고의가 없었기 때문이다.", "사회 상규에 어긋나는 행위이기 때문이다.", "법률보다 판례가 우선 적용되기 때문이다."], answerIndex: 2, explanation: "정당 행위로 보기 위해서는 사회 상규에 부합해야 하나, 해당 행위는 이에 어긋난다." },
            { id: 314, type: 'two-step', difficulty: '상', case: "채무자 갑은 도망 중이었다. 채권자 을은 우연히 길에서 갑을 마주쳐 도망을 막기 위해 그의 가방을 붙잡았고, 이로 인해 가방이 파손되었다. 이 경우 을의 행위는 위법성이 조각된다.", q1: 'O', q2_question: "위 사례에서 을의 행위에 해당하는 위법성 조각 사유는 무엇인가?", q2: ["정당방위", "긴급 피난", "자구 행위", "정당 행위"], answerIndex: 2, explanation: "국가의 구제를 기대하기 어려운 상황에서 청구권 실현을 위한 불가피한 자구 행위다." },
            { id: 315, type: 'two-step', difficulty: '상', case: "경찰청은 불량 식재료를 유통한 식품 업체에 대한 정보를 수사 후 국민 건강 보호 차원에서 언론에 공표하였다. 이로 인해 업체의 명예는 실추되었다. 이 경우 경찰청의 행위는 위법성이 인정된다.", q1: 'X', q2_question: "위 사례에서 경찰청의 행위에 해당하는 위법성 조각 사유는 무엇인가?", q2: ["정당방위", "긴급 피난", "자구 행위", "정당 행위"], answerIndex: 3, explanation: "공익 목적과 진실성, 필요성이 인정되므로 정당 행위로서 위법성이 조각된다." },
            { id: 316, type: 'two-step', difficulty: '상', case: "야간 근무 중인 경비원 갑은 침입자를 제지하던 중 반격을 받고, 시설 보호를 위해 물리력을 사용해 제압하였다. 침입자는 경미한 상처를 입었다. 이 경우 갑의 행위는 형법상 범죄로 성립한다.", q1: 'X', q2_question: "위 사례에서 갑의 행위에 해당하는 위법성 조각 사유는 무엇인가?", q2: ["긴급 피난", "정당방위", "자구 행위", "정당 행위"], answerIndex: 1, explanation: "현재의 부당한 침해에 대응한 자기방어로서 정당방위에 해당한다." },
            { id: 317, type: 'two-step', difficulty: '상', case: "정당방위는 현재의 부당한 침해가 존재해야만 성립한다.", q1: 'O', q2_question: "다음 중 정당방위가 성립하지 않는 경우는?", q2: ["강도가 칼을 들고 위협하자 밀쳐서 도망친 경우", "만취자가 욕설을 하자 폭행으로 대응한 경우", "낯선 이가 위협적으로 접근하자 제압한 경우", "가족을 해치려는 폭행범을 제압한 경우"], answerIndex: 1, explanation: "언어적 공격에 대해 신체적 폭행으로 대응하는 것은 상당성 요건을 충족하지 못한다." },
            { id: 318, type: 'two-step', difficulty: '상', case: "자구행위는 청구권 보전을 위한 불가피한 수단이 없는 경우에만 허용된다.", q1: 'O', q2_question: "다음 중 자구행위로서 위법성이 조각될 수 있는 사례는?", q2: ["친구가 빌린 돈을 갚지 않아 차량에 낙서를 한 경우", "도망가는 도둑을 붙잡기 위해 방 문을 강제로 잠그고 경찰을 기다린 경우", "과거에 폭행한 상대에게 복수한 경우", "물건값을 받기 위해 상대방에게 손찌검한 경우"], answerIndex: 1, explanation: "현재의 권리 침해 상황에서 불가피하게 청구권을 보전하기 위한 조치로서 인정 가능하다." },
            { id: 319, type: 'two-step', difficulty: '상', case: "긴급피난은 침해자의 존재 여부와 관계없이 자연재해나 동물 등으로부터의 위난에도 적용될 수 있다.", q1: 'O', q2_question: "다음 중 긴급피난이 적용될 수 있는 사례는?", q2: ["술에 취해 다른 사람을 폭행한 경우", "추격 중인 절도를 붙잡기 위해 위험 운전을 한 경우", "갑작스러운 산불에서 탈출하기 위해 담을 넘은 경우", "괴한에게 위협당해 상대를 제압한 경우"], answerIndex: 2, explanation: "자연재해로부터 피난을 위한 행위는 긴급피난으로 위법성이 조각될 수 있다." },
            { id: 320, type: 'two-step', difficulty: '상', case: "피해자의 명시적 승낙이 있더라도 공공의 법익이 관련된 경우 위법성은 조각되지 않는다.", q1: 'O', q2_question: "다음 중 피해자의 승낙이 위법성 조각 사유로 성립하지 않는 것은?", q2: ["의사가 환자의 동의를 얻어 수술을 진행", "사진작가가 모델의 동의 하에 모델의 사진을 미술 전시에 출품", "친구가 허락한 공공시설 파손", "피고인이 피해자의 요청에 의해 의료적 문신 시술"], answerIndex: 2, explanation: "공공시설은 개인이 처분할 수 없는 법익이므로 승낙은 효력이 없다." },
            { id: 321, type: 'two-step', difficulty: '상', case: "만 14세 미만은 형사 미성년자로서 범죄가 성립하지 않는다.", q1: 'O', q2_question: "다음 중 형사 미성년자에게 해당하는 사례는?", q2: ["만 13세가 절도를 저지른 경우", "만 15세가 폭행을 한 경우", "만 18세가 음주운전을 한 경우", "만 20세가 절도를 저지른 경우"], answerIndex: 0, explanation: "형사 미성년자는 만 14세 미만이며, 형사책임을 지지 않는다." },
            { id: 322, type: 'two-step', difficulty: '상', case: "심신상실자는 형법상 범죄가 성립되지 않는다.", q1: 'O', q2_question: "다음 중 심신상실로 인정되어 범죄가 성립하지 않을 수 있는 경우는?", q2: ["약한 우울증 상태에서 고의로 범죄를 저지른 경우", "자발적인 만취 상태에서 고의로 폭행한 경우", "정신병으로 현실 판단능력을 완전히 상실한 경우", "분노를 주체하지 못하여 실수로 범행한 경우"], answerIndex: 2, explanation: "현실 판단능력 상실이 인정되면 심신상실 상태로 책임능력이 부정된다." },
            { id: 323, type: 'two-step', difficulty: '상', case: "심신미약자는 범죄가 성립하지만, 형이 감경될 수 있다.", q1: 'O', q2_question: "다음 중 심신미약으로 형이 감경될 가능성이 가장 높은 경우는?", q2: ["우발적 폭행", "경미한 도박", "정신질환 치료 중 범행", "단순 절도"], answerIndex: 2, explanation: "정신질환 치료 중 범행은 심신미약 상태일 가능성이 있으며 감경 사유로 고려된다." },
            { id: 324, type: 'two-step', difficulty: '상', case: "자구행위는 행위 당시 법적 구제 방법이 있었더라도 정당화될 수 있다.", q1: 'X', q2_question: "다음 중 자구행위로서 인정되기 어려운 사례는?", q2: ["형사절차 없이 금품을 직접 탈취한 경우", "절도범을 붙잡기 위해 문을 잠근 경우", "부정행위를 방지하기 위해 시험지를 압수한 경우", "침입자를 퇴거시키기 위해 밀어낸 경우"], answerIndex: 0, explanation: "법적 절차를 무시한 직접적인 금품 강탈은 자구행위로 정당화될 수 없다." },
            { id: 325, type: 'two-step', difficulty: '상', case: "정당방위는 제3자의 법익을 보호하기 위한 경우에도 적용된다.", q1: 'O', q2_question: "다음 중 타인을 위한 정당방위로 위법성이 조각될 수 있는 사례는?", q2: ["친구의 복수를 위해 상대를 폭행한 경우", "지나가던 사람이 폭행당하는 타인을 구한 경우", "가족이 절도범을 도운 경우", "도발에 응해 먼저 폭행한 경우"], answerIndex: 1, explanation: "타인의 현재의 부당한 침해를 방지하기 위한 상당한 방어행위는 정당방위가 성립된다." },
            { id: 326, type: 'two-step', difficulty: '상', case: "긴급피난은 법익의 침해가 있더라도 보호하려는 법익이 더 클 경우 허용된다.", q1: 'O', q2_question: "다음 중 긴급피난으로 인정되기 어려운 경우는?", q2: ["홍수 중 피난을 위해 상점 유리창을 깬 경우", "추락 위기에서 타인의 차를 타고 피신한 경우", "불만을 이유로 공공시설을 파괴한 경우", "폭설 속에서 버스에 무단 탑승한 경우"], answerIndex: 2, explanation: "단순 불만에 따른 행위는 위난 회피를 위한 행위로 보기 어려우며 긴급피난에 해당하지 않는다." }, 

            // 기존 '최상' 난이도 퀴즈
            { id: 401, type: 'two-step', difficulty: '최상', case: "오늘날 강조되는 실질적 죄형 법정주의는 입법자가 부당한 법률을 제정하는 것까지도 제한하여 국민의 자유와 권리를 보호하고자 한다.", q1: 'O', q2_question: "다음은 조선시대 형벌에 대한 설명입니다. 이를 통해 알 수 있는 현대적 죄형 법정주의 원칙의 중요성은 무엇입니까? <br>\"조선시대에는 성문법 외에 정령이나 사회 통념에 따라 형벌이 부과되기도 했다.\"", q2: ["예측 가능하고 명확한 법률의 중요성", "형벌과 범죄의 비례성 원칙의 중요성", "행위 당시의 법률을 적용하는 행위시법주의의 중요성", "국가 형벌권 남용을 막기 위한 적법 절차의 원칙의 중요성"], answerIndex: 0, explanation: "조선시대의 사례는 성문법 외의 기준으로 형벌이 부과될 수 있었음을 보여준다. 이는 국민이 어떤 행위가 처벌 대상이 되는지 예측할 수 있도록 법률이 명확해야 한다는 현대의 명확성의 원칙과 관습 형법 금지의 원칙의 중요성을 부각시킨다." },
            { id: 402, type: 'two-step', difficulty: '최상', case: "보안처분도 형사 제재이므로 형벌과 같이 부과 요건 등에 있어서 적법절차의 원리가 준수되어야 한다.", q1: 'O', q2_question: "다음 중 형벌과 보안처분에 대한 설명으로 옳은 것을 고르시오.", q2: ["징역형은 재산형에 해당한다.", "벌금형은 일정 기간 신체의 자유를 박탈하는 형벌이다.", "보안 처분은 범죄자의 사회적 위험성을 전제로 특별 예방의 관점에서 부과된다.", "사형은 무기 징역형보다 범죄자에 대한 법익 침해의 정도가 작다."], answerIndex: 2, explanation: "보안 처분은 행위자의 사회적 위험성과 재범의 우려를 전제로 특별 예방의 관점에서 부과된다. ① 징역형은 자유형, ② 벌금형은 재산형, ④ 사형은 가장 큰 법익 침해를 가하는 형벌이다." },
            { id: 403, type: 'two-step', difficulty: '최상', case: "형사 절차에서 유죄 판결이 확정되기 전까지는 피의자와 피고인을 무죄로 추정하는 것이 원칙이다.", q1: 'O', q2_question: "다음 중 무죄 추정의 원칙이 적용된 것으로 볼 수 없는 상황은?", q2: ["언론이 피의자에 대해 '범죄자'라는 표현을 사용하지 않고 '피의자' 또는 '혐의자'로 보도하는 것", "경찰 수사가 진행 중인 공무원에 대해 유죄 판결이 나기 전에 직위 해제하고 언론에 실명과 사진을 공개한 경우", "피고인이 범죄 혐의로 수사를 받더라도 불구속으로 수사하는 것을 원칙으로 하는 것", "피고인이 재판 중에도 변호인의 조력을 받을 권리를 보장받는 것"], answerIndex: 1, explanation: "무죄 추정의 원칙은 유죄 판결이 확정되기 전까지는 피의자나 피고인을 무죄로 간주해야 한다는 원칙이다. 유죄가 확정되기 전부터 공무원을 범죄자로 취급하여 언론에 보도하는 것은 무죄 추정의 원칙의 취지에 어긋난다." },
            { id: 404, type: 'two-step', difficulty: '최상', case: "보안 처분은 형벌과 달리 과거의 불법에 대한 책임에 기초하며, 그 부과에 죄형 법정주의의 소급효 금지 원칙이 예외 없이 적용된다.", q1: 'X', q2_question: "다음 중 소년법상 보호처분으로서 소년의 사회 복귀 및 교화를 목적으로 하는 시설에 수용되는 사례는?", q2: ["만 17세의 甲이 심각한 범죄로 일반 형사 법원에서 징역형을 선고받고 소년 교도소에 수용된 경우", "만 16세의 乙이 가정 법원 소년부로부터 '장기 소년원 송치' 처분을 받고 소년원에 수용된 경우", "만 20세의 丙이 음주운전으로 집행 유예를 선고받고 사회봉사 명령을 받은 경우", "만 14세의 丁이 심신상실 상태에서 살인죄를 저질러 치료 감호 시설에 수용된 경우"], answerIndex: 1, explanation: "보안 처분은 장래의 위험성을 예방하기 위한 조치로 소급효 금지 원칙이 적용되지 않는다. 소년원은 소년 보호 처분을 받은 소년을 교정 교육을 통해 사회 복귀와 교화를 목적으로 수용하는 시설이다." },
            { id: 405, type: 'two-step', difficulty: '최상', case: "강제 처분은 실체적 진실을 발견하고 형벌권을 실현하기 위해 불가피하더라도, 개인의 기본권을 침해하므로 반드시 법률에 의하여 그 종류 및 요건과 절차가 갖추어져야 한다.", q1: 'O', q2_question: "다음 사례는 형사 절차에서 인권 보장을 위한 어떤 원칙을 위반한 것으로 볼 수 있습니까? <br>\"경찰관 甲은 乙을 체포 후, 권리 고지 없이 심문하여 자백을 받았고, 이 자백이 유일한 유죄 증거로 제시되었다.\"", q2: ["영장주의", "무죄 추정의 원칙", "자백 보강 법칙 및 미란다 원칙(진술 거부권 고지)", "적법 절차의 원칙 및 형사 보상 제도"], answerIndex: 2, explanation: "이 사례에서는 乙에게 진술 거부권 등의 고지(미란다 원칙)가 이루어지지 않아 위법하게 수집된 자백에 해당하며, 또한 자백이 유일한 증거로 제시되었으므로 자백 보강 법칙에 위배된다. 이 두 원칙 위반이 핵심이다." },
            { id: 406, type: 'two-step', difficulty: '최상', case: "학생 갑은 학교 폭력 가해자로 지목되어 징계가 확정되기 전에 전면 등교 금지 조치를 받았다. 이러한 학교의 조치는 우리 헌법상 형사사법 절차에 적용되는 기본권 보호 원칙에 비추어 정당하다고 볼 수 있는가?", q1: 'X', q2_question: "위 상황에서 갑이 보장받지 못한 형사 절차에서의 인권 보장 원칙은 무엇인가?", q2: ["진술 거부권", "변호인의 조력을 받을 권리", "무죄 추정의 원칙", "증거재판주의"], answerIndex: 2, explanation: "형사 절차에서 유죄 확정 전까지는 무죄로 추정해야 하며, 징계 확정 전 불이익 조치는 위 원칙에 반한다." },
            { id: 407, type: 'two-step', difficulty: '최상', case: "갑은 2022년 12월 31일 범죄를 저질렀고, 2023년 1월 1일부터 형량이 감경된 개정 법률이 시행되었다. 법원은 갑에게 개정법을 적용했다. 이 경우 법원의 판단은 법적으로 타당하다.", q1: 'O', q2_question: "이 경우 법원의 판단을 뒷받침하는 법 원칙은 무엇인가?", q2: ["죄형 법정주의의 예외", "피고에게 유리한 소급 적용 허용", "적법 절차 원칙", "법관 재량주의"], answerIndex: 1, explanation: "피고에게 유리한 경우에는 소급하여 법을 적용할 수 있다. 형벌 불소급 원칙의 예외이다." },
            { id: 408, type: 'two-step', difficulty: '최상', case: "정당방위가 인정되기 위해서는 침해에 대한 방어행위가 ‘상당성’을 갖추어야 한다.", q1: 'O', q2_question: "갑은 택시기사와 요금 시비 중 얼굴에 침을 맞자 화가 나 주먹으로 기사의 턱을 가격해 골절상을 입혔다. 갑의 행위에 대한 판단으로 옳은 것은?", q2: ["정당방위가 인정된다.", "정당방위이나 과잉방위로 감경된다.", "위법성 조각 사유가 없다.", "책임 조각 사유에 해당한다."], answerIndex: 2, explanation: "침을 맞은 것이 폭행이긴 하나 생명·신체의 실질적 침해로 보기 어려우며, 주먹으로 턱을 골절시킨 것은 상당성을 초과하여 정당방위가 부정된다." },
            { id: 409, type: 'two-step', difficulty: '최상', case: "긴급피난은 회피를 위한 수단이 사회상규에 위배되어도 적용된다.", q1: 'X', q2_question: "홍수로 인해 탈출이 필요한 상황에서 갑이 타인의 차량을 무단 점유하여 대피하였다. 이후 차량 파손이 발생하였다. 다음 중 옳은 설명은?", q2: ["긴급피난이므로 책임이 조각된다.", "긴급피난이므로 위법성은 조각되나 손해배상 책임은 존재한다.", "위법성이 조각되지 않는다.", "불법행위로 형사처벌 가능하다."], answerIndex: 1, explanation: "긴급피난으로 위법성은 조각되나 민사상 불법행위책임은 여전히 인정된다." },
            { id: 410, type: 'two-step', difficulty: '최상', case: "자구행위는 청구권 보전 외 보복이나 감정적 목적을 가지면 인정되지 않는다.", q1: 'O', q2_question: "병은 친구가 빌려간 고가의 노트북을 돌려주지 않자 친구가 없는 틈을 타 자택에 무단침입하여 노트북을 가져왔다. 병의 행위는?", q2: ["정당한 자구행위이다.", "주거침입죄로 위법하다.", "사회상규에 따른 행위이다.", "피해자의 승낙이 있었던 것으로 본다."], answerIndex: 1, explanation: "자구행위로 인정되기 위해선 급박성과 비례성, 불가피성이 충족되어야 하며, 본 사례는 불법침입 및 절도에 해당한다." },
            { id: 411, type: 'two-step', difficulty: '최상', case: "피해자의 승낙이 있어도 건전한 사회상규를 현저히 위반한 경우 위법성은 조각되지 않는다.", q1: 'O', q2_question: "을은 방송 콘텐츠를 위해 타인의 동의를 받고 심각한 폭력을 행사하여 영상을 촬영하였다. 해당 영상은 유튜브에 업로드되었고, 다수의 신고가 접수되었다. 이 경우 판단은?", q2: ["피해자의 승낙이 있어 위법성 없음", "공공질서 위반으로 위법성 있음", "단순한 동영상으로 형사처벌 불가", "쌍방합의된 사안은 형사처벌 대상 아님"], answerIndex: 1, explanation: "피해자의 승낙이 있다 하더라도 사회통념상 용인되지 않는 경우 위법성이 조각되지 않는다." },
            { id: 412, type: 'two-step', difficulty: '최상', case: "형법상 심신미약자는 그 책임이 조각되는 것은 아니며 형을 감경할 수 있다.", q1: 'O', q2_question: "정신질환을 앓고 있던 정은 치료 도중 환각 상태에서 타인을 폭행했다. 법원은 정에게 조현병이 있었고 판단력이 저하되어 있었으므로 심신미약 상태였다고 판단했다. 이 경우 법원이 결정할 처분으로 가장 가능성이 높은 것은?", q2: ["무죄 선고", "책임 조각", "형의 감경", "위법성 조각"], answerIndex: 2, explanation: "심신미약 상태로 판단된 경우 범죄는 성립하나 형의 감경이 가능하다." },
            { id: 413, type: 'two-step', difficulty: '최상', case: "형사 미성년자는 범죄를 저질러도 형벌을 부과할 수 없다.", q1: 'O', q2_question: "만 13세인 김은 무단으로 차량을 운전하다 사고를 냈다. 이 경우의 조치는?", q2: ["자동차등불법사용죄로 형사처벌", "형사책임 감경", "보호처분", "소년교도소 수용"], answerIndex: 2, explanation: "형사 미성년자에게는 형벌 대신 보호처분이 내려질 수 있다." },
            { id: 414, type: 'two-step', difficulty: '최상', case: "형법상 정당방위는 법익 침해가 우발적으로 발생한 경우에도 적용될 수 있다.", q1: 'O', q2_question: "A는 시장에서 절도범을 제압하려다 범인의 팔을 꺾어 골절시켰다. 범인은 도망 중이었고 저항은 하지 않았다. 이 경우 판단은?", q2: ["정당방위", "과잉방위", "위법성 조각", "책임 조각"], answerIndex: 1, explanation: "실제로 물리적 저항이 없는 상황에서의 공격은 방어의 정도를 초과한 것으로 판단될 수 있다." },
            { id: 415, type: 'two-step', difficulty: '최상', case: "자구행위는 법정 절차를 밟을 시간적 여유가 전혀 없는 경우에만 인정된다.", q1: 'O', q2_question: "병은 도망치는 절도범을 뒤쫓아 건물 안으로 몰고, 밖에서 문을 잠가 경찰을 기다렸다. 이 행위는?", q2: ["감금죄 성립", "과잉방위", "자구행위로 위법성 조각", "긴급피난"], answerIndex: 2, explanation: "청구권의 실현 및 보호를 위한 불가피한 조치로 자구행위로 인정될 수 있다." }, 
        ];
        
        // ==================================================================
        // 게임 초기화 및 상태 관리
        // ==================================================================
        function initGame() {
            resetGameState();
            showScreen('story-screen');
        }

        function resetGameState() {
             gameState = {
                  player: { name: '', class: '', gender: '', level: 1, imageKey: '' },
                  difficulty: null, lives: 5, monstersDefeated: 0,
                  currentMonster: { type: null, imageKey: null, x: 0, y: 0, hitProgress: 0, alpha: 1 },
                  currentQuiz: null, usedQuizIds: [],
                  clearedStages: { '하': false, '중': false, '상': false },
                  isBossFight: false, bossStage: 0,
                  currentScreen: 'start-screen',
                  animation: { type: null, progress: 0, duration: 0, onEnd: null, data: {} },
                  questionsAttempted: 0,
                  questionsCorrect: 0,
                  isSkippable: false,
                  onSkip: null,
                  skippableTimeoutId: null,
                  isChallengeUnlocked: false,
                  score: 0,
                  hasUsedUltimate: false
             };
             gameOverDebris = [];
             backgroundParticles = [];
             effectParticles = [];
        }

        function showScreen(screenId) {
            screens.forEach(screen => screen.classList.remove('active'));
            document.getElementById(screenId).classList.add('active');
            gameState.currentScreen = screenId;

            const isGameScreen = screenId === 'game-screen';
            failsafeContainer.style.display = isGameScreen ? 'block' : 'none';
            instructionsModal.style.display = 'none'; // 다른 화면으로 전환 시 설명 모달 닫기
            fixedButtonsContainer.style.display = isGameScreen ? 'block' : 'none';


            if (!isGameScreen && animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
        }
        // ==================================================================
        // 에셋 로딩 및 BGM
        // ==================================================================
        async function loadAssets() {
            const imageSources = [
                ...Object.values(assets.characters),
                ...Object.values(assets.monsters),
                ...Object.values(assets.misc)
            ];
            const imagePromises = imageSources.map(src => {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.src = src;
                    img.onload = () => {
                        let keyFound = false;
                        for (const category in assets) {
                            const key = Object.keys(assets[category]).find(k => assets[category][k] === src);
                            if (key) {
                                loadedImages[key] = img;
                                keyFound = true;
                                break;
                            }
                        }
                        resolve();
                    };
                    img.onerror = () => {
                        console.error(`이미지 로딩 실패: ${src}`);
                        resolve(); 
                    }
                });
            });
            await Promise.all(imagePromises);
        }
        
        function initAndPlayBGM() {
            if (bgmAudioElement.paused) {
                const playPromise = bgmAudioElement.play();
                if (playPromise !== undefined) {
                    playPromise.catch(error => {
                        console.error("오디오 자동재생 실패. 사용자 상호작용이 필요합니다.", error);
                    });
                }
            }
        }
        
        // ==================================================================
        // 애니메이션 및 상태 관리
        // ==================================================================
        function startAnimation(type, duration, onEnd, data = {}) {
            gameState.animation = { type, duration, progress: 0, onEnd, data };
        }

        function clearAnimation() {
            if (gameState.animation && typeof gameState.animation.onEnd === 'function') {
                gameState.animation.onEnd();
            }
            gameState.animation = { type: null, duration: 0, progress: 0, onEnd: null, data: {} };
        }
        
        // ==================================================================
        // 게임 로직 (수정됨)
        // ==================================================================
        function startNewGame() {
            resetGameState();
            showScreen('character-selection-screen');
        }

        function setupDifficultyScreen() {
            const statusEl = document.getElementById('difficulty-char-status');
            statusEl.innerHTML = `
                <h3>${gameState.player.name}</h3>
                <p>LV. ${gameState.player.level} | 직업: ${gameState.player.class}</p>
            `;
            
            const optionsContainer = document.getElementById('difficulty-options');
            optionsContainer.querySelectorAll('.difficulty-option:not(.challenge-option)').forEach(opt => {
               const btn = opt.querySelector('.difficulty-btn');
               const diff = btn.dataset.difficulty;
               const isCleared = gameState.clearedStages[diff];
               if(isCleared) {
                   btn.textContent = `${diff} (클리어!)`;
                   btn.classList.add('btn-success');
               } else {
                   btn.textContent = diff;
                   btn.classList.remove('btn-success');
               }
               btn.classList.toggle('disabled', (diff === '중' && !gameState.clearedStages['하']) || (diff === '상' && !gameState.clearedStages['중']));
            });
            
            const existingChallengeBtn = optionsContainer.querySelector('.challenge-option');
            if (existingChallengeBtn) existingChallengeBtn.remove();

            if (gameState.isChallengeUnlocked) {
                const challengeOption = document.createElement('div');
                challengeOption.className = 'difficulty-option challenge-option';
                challengeOption.innerHTML = `
                  <button class="btn btn-challenge difficulty-btn" data-difficulty="도전자">도전자</button>
                  <p class="difficulty-desc">최고 점수에 도전하세요!</p>
                `;
                optionsContainer.appendChild(challengeOption);
                challengeOption.querySelector('.difficulty-btn').addEventListener('click', () => startGame('도전자'));
            }

            showScreen('difficulty-selection-screen');
        }

        function startGame(difficulty) {
            gameState.difficulty = difficulty;
            gameState.usedQuizIds = [];
            gameState.isBossFight = false;
            gameState.bossStage = 0;
            gameState.questionsAttempted = 0;
            gameState.questionsCorrect = 0;
            gameState.hasUsedUltimate = false;

            if (difficulty === '상') {
                gameState.lives = 3;
            } else if (difficulty === '도전자') {
                gameState.lives = 3;
                gameState.score = 0;
            } else {
                gameState.lives = 5;
            }

            monsterInfoDisplay.style.display = 'none';
            updateStatus();
            startDungeonAnimation();
        }

        function startDungeonAnimation() {
            showScreen('game-screen');
            if (!animationFrameId) {
                gameLoop();
            }
            backgroundParticles = [];
            
            const onIntroEnd = () => {
                const message = gameState.isBossFight ? "보스가 등장했다!" : "몬스터가 등장했습니다.";
                showTemporaryMessage(message, 1000, spawnMonster);
            };
            
            startAnimation('dungeon-intro', 2000, onIntroEnd);
            
            makeEventSkippable(onIntroEnd, 2000);
        }
        
        function makeEventSkippable(callback, duration) {
            if (gameState.skippableTimeoutId) clearTimeout(gameState.skippableTimeoutId);
            
            const onSkipCallback = () => {
                if(gameState.isSkippable) { 
                    gameState.isSkippable = false;
                    clearTimeout(gameState.skippableTimeoutId);
                    gameState.skippableTimeoutId = null;
                    gameState.onSkip = null;
                    clearAnimation();
                    callback();
                }
            };

            gameState.isSkippable = true;
            gameState.onSkip = onSkipCallback;
            gameState.skippableTimeoutId = setTimeout(onSkipCallback, duration);
        }

        function skipCurrentEvent() {
            if (isInputLocked) return;
            if (gameState.isSkippable && typeof gameState.onSkip === 'function') {
                gameState.onSkip();
            }
        }

        function spawnMonster() {
            const difficulty = gameState.difficulty;
            let monsterType;

            if (gameState.isBossFight) {
                monsterType = '보스';
            } else if (difficulty === '도전자') {
                const rand = Math.random();
                if (rand < 0.4) monsterType = '중';
                else if (rand < 0.8) monsterType = '상';
                else monsterType = '보스';
            } else {
                const rand = Math.random() * 100;
                if (difficulty === '하') {
                    if (rand < 65) monsterType = '하'; else if (rand < 90) monsterType = '중'; else monsterType = '상';
                } else if (difficulty === '중') {
                    if (rand < 50) monsterType = '하'; else if (rand < 85) monsterType = '중'; else monsterType = '상';
                } else { 
                    if (rand < 40) monsterType = '하'; else if (rand < 70) monsterType = '중'; else monsterType = '상';
                }
            }
            
            gameState.currentMonster = { type: monsterType, imageKey: monsterType, hitProgress: 0, alpha: 1 };
            startQuiz();
        }

        function startQuiz() {
            gameState.questionsAttempted++;
            updateStatus();
            let
                quizDifficulty;

            if (gameState.difficulty === '도전자') {
                const rand = Math.random();
                if (rand < 0.4) quizDifficulty = '중';
                else if (rand < 0.8) quizDifficulty = '상';
                else quizDifficulty = '최상';
            } else if (gameState.isBossFight) {
                if (gameState.difficulty === '하') quizDifficulty = '상';
                else quizDifficulty = '최상';
            } else {
                quizDifficulty = gameState.currentMonster.type;
            }

            monsterInfoDisplay.innerHTML = `몬스터 등급: ${gameState.currentMonster.type}<br>문제 난이도: ${quizDifficulty}`;
            monsterInfoDisplay.style.display = 'block';

            const availableQuizzes = quizzes.filter(q => q.difficulty === quizDifficulty && !gameState.usedQuizIds.includes(q.id));

            if (availableQuizzes.length === 0) {
                const quizzesOfDifficulty = quizzes.filter(q => q.difficulty === quizDifficulty).map(q => q.id);
                gameState.usedQuizIds = gameState.usedQuizIds.filter(id => !quizzesOfDifficulty.includes(id));
                const newAvailableQuizzes = quizzes.filter(q => q.difficulty === quizDifficulty && !gameState.usedQuizIds.includes(q.id));
                if(newAvailableQuizzes.length === 0) {
                    showMessage(`이 난이도의 모든 문제를 정복했습니다!`, prepareNextEncounter);
                    return;
                }
                gameState.currentQuiz = newAvailableQuizzes[Math.floor(Math.random() * newAvailableQuizzes.length)];
            } else {
                gameState.currentQuiz = availableQuizzes[Math.floor(Math.random() * availableQuizzes.length)];
            }
            
            gameState.usedQuizIds.push(gameState.currentQuiz.id);
            displayQuiz();
        }

        function displayQuiz() {
            const quiz = gameState.currentQuiz;
            q2OptionsEl.innerHTML = '';
            
            if (quiz.type === 'single') {
                quizCaseEl.innerHTML = `[문제]<br>${quiz.case}`;
                q1OptionsEl.style.display = 'none';
                q2OptionsEl.style.display = 'flex';
                quiz.q2.forEach((option, index) => {
                    const btn = document.createElement('button');
                    btn.classList.add('btn', 'quiz-btn', 'q2-btn');
                    btn.innerHTML = `${index + 1}. ${option}`;
                    btn.dataset.answerIndex = index;
                    q2OptionsEl.appendChild(btn);
                });
            } else if (quiz.type === 'two-step') {
                quizCaseEl.innerHTML = `[O/X 문제]<br>${quiz.case}`;
                q1OptionsEl.style.display = 'flex';
                q2OptionsEl.style.display = 'none';
            } else { 
                quizCaseEl.innerHTML = `[O/X 문제]<br>${quiz.case}`;
                q1OptionsEl.style.display = 'flex';
                q2OptionsEl.style.display = 'none';
            }
            showQuizContainer(true);
            unlockInput();
        }
        
        function displayQ2ForTwoStep() {
            const quiz = gameState.currentQuiz;
            const q2Question = quiz.q2_question || "위 O/X 판단에 대한 근거로 가장 적절한 것을 고르시오.";
            quizCaseEl.innerHTML = `<b>[심화 문제]</b><br>${q2Question}`;
            q1OptionsEl.style.display = 'none';
            q2OptionsEl.style.display = 'flex';
            
            quiz.q2.forEach((option, index) => {
                const btn = document.createElement('button');
                btn.classList.add('btn', 'quiz-btn', 'q2-btn');
                btn.innerHTML = `${index + 1}. ${option}`;
                btn.dataset.answerIndex = index;
                q2OptionsEl.appendChild(btn);
            });
            unlockInput();
        }

        function handleQ1Answer(answer) {
            if (isInputLocked) return;
            lockInput();

            const quiz = gameState.currentQuiz;
            if (answer === quiz.q1) {
                if (quiz.type === 'one-step-ox') {
                    handleCorrectAnswer();
                } else { 
                    displayQ2ForTwoStep();
                }
            } else {
                handleIncorrectAnswer();
            }
        }

        function handleQ2Answer(index) {
            if (isInputLocked) return;
            lockInput();

            if (index == gameState.currentQuiz.answerIndex) {
                handleCorrectAnswer();
            } else {
                handleIncorrectAnswer();
            }
        }
        
        async function handleUltimateSkill() {
    if (isInputLocked || gameState.hasUsedUltimate) return;

    if (gameState.isBossFight && gameState.difficulty !== '도전자') {
        showMessage("보스에게는 궁극기를 사용할 수 없습니다.");
        return;
    }

    lockInput();
    gameState.hasUsedUltimate = true;
    // 궁극기 사용 시에는 '푼 문제' 카운트를 올리지 않기 위해 1 감소
    gameState.questionsAttempted--; 
    updateStatus();
    showQuizContainer(false);
    monsterInfoDisplay.style.display = 'none';

    const skillName = ultimateSkillNames[gameState.player.class][gameState.player.level];
    await showTemporaryMessage(skillName, 1500);

    startAnimation('ultimate-attack', 4000, () => {
        showTemporaryMessage("궁극의 기술로 몬스터를 물리쳤다!", 1500, () => {
            const quiz = gameState.currentQuiz;
            const explanationText = `<b>[문제: ${quiz.case}]</b><br><br><b>정답 해설:</b><br>${quiz.explanation || "해설 정보가 없습니다."}`;
            // 궁극기 후에는 다음 몬스터 등장 애니메이션만 호출
            showMessage(explanationText, startDungeonAnimation);
        });
    });
}

        function handleCorrectAnswer() {
           if (gameState.difficulty === '도전자') {
               const scoreMap = {'하': 10, '중': 20, '상': 30, '보스': 50, '최상': 50};
               gameState.score += scoreMap[gameState.currentQuiz.difficulty] || 20;
               if (gameState.score >= 200 && gameState.player.level < 5) {
                   gameState.player.level = 5;
                   showTemporaryMessage("레벨 5 달성! 파멸적인 힘이 느껴진다!", 2000);
               }
           }
            gameState.questionsCorrect++;
            updateStatus();
            showQuizContainer(false);
            monsterInfoDisplay.style.display = 'none';
            
            startAnimation('attack', 1500, () => {
                let message = "몬스터를 물리쳤다!";
                if(gameState.isBossFight) {
                    if (gameState.difficulty === '하' || gameState.difficulty === '중') {
                        message = "대단하군 용사여.. 두고보자!";
                    } else if (gameState.difficulty === '상') {
                        if (gameState.bossStage === 0) {
                            gameState.bossStage = 1;
                            showTemporaryMessage("아직 쓰러지지 않는다. 다시 덤비거라 용사여!", 1500, spawnMonster);
                            return;
                        } else {
                            message = "정말 대단하구나... 나의 패배를 인정한다...";
                        }
                    }
                }
                showTemporaryMessage(message, 1500, () => {
                    if (gameState.isBossFight) {
                        handleStageClear();
                    } else {
                        prepareNextEncounter();
                    }
                });
            });
        }
        
        function handleIncorrectAnswer() {
    showQuizContainer(false);
    monsterInfoDisplay.style.display = 'none';
    gameState.lives--;
    // 오답 시에는 '푼 문제'를 다시 1 감소시켜 원상복구
    gameState.questionsAttempted--; 
    updateStatus();

    startAnimation('monster-attack', 1200, () => {
        showTemporaryMessage("몬스터의 공격을 막지 못했다!", 1200, () => {
            const quiz = gameState.currentQuiz;
            let explanationText = `<b>오답입니다!</b><br><br><b>정답 해설:</b><br>${quiz.explanation || "해설 정보가 없습니다."}`;

            const nextAction = () => {
                if (gameState.lives <= 0) {
                    if (gameState.difficulty === '도전자') {
                        showChallengeResult();
                    } else {
                        startGameOverAnimation();
                    }
                } else {
                    // 같은 퀴즈를 다시 보여주기
                    displayQuiz(); 
                }
            };
            showMessage(explanationText, nextAction);
        });
    });
}    

        function startGameOverAnimation() {
            gameOverDebris = [];
            for(let i=0; i<50; i++) {
                gameOverDebris.push({
                    x: Math.random() * canvas.width, y: -Math.random() * canvas.height,
                    width: Math.random() * 40 + 20, height: Math.random() * 30 + 15,
                    vx: (Math.random() - 0.5) * 5, vy: Math.random() * 5 + 2,
                    rotation: 0, vr: (Math.random() - 0.5) * 0.1,
                    color: `rgb(${100 + Math.random()*30}, ${90 + Math.random()*30}, ${90 + Math.random()*30})`
                });
            }
            startAnimation('game-over', 2500, () => {
                showMessage("GAME OVER", setupDifficultyScreen);
            });
        }
        
        function prepareNextEncounter() {
            // Ensure no lingering animations or locks
            clearAnimation();
            unlockInput();

            if (gameState.difficulty !== '도전자' && Math.random() < 0.3) {
                if (gameState.difficulty === '상') gameState.lives = Math.min(3, gameState.lives + 1);
                else gameState.lives = Math.min(5, gameState.lives + 1);
            }
            updateStatus();

            if (gameState.difficulty === '도전자') {
               startDungeonAnimation();
               return;
            }

            const bossThresholds = { '하': 5, '중': 8, '상': 10 };
            const correctAnswers = gameState.questionsCorrect;
            let bossConditionMet = correctAnswers >= bossThresholds[gameState.difficulty];
            
            if (bossConditionMet) {
                gameState.isBossFight = true;
                gameState.bossStage = 0;
                startDungeonAnimation();
            } else {
                startDungeonAnimation();
            }
        }
        
        function handleStageClear() {
            gameState.clearedStages[gameState.difficulty] = true;
            if (gameState.player.level < 4) {
               gameState.player.level++;
            }
            
            effectParticles = [];
            for (let i = 0; i < 150; i++) {
                effectParticles.push({
                    type: 'confetti', x: Math.random() * canvas.width, y: Math.random() * -canvas.height,
                    vx: Math.random() * 6 - 3, vy: Math.random() * 5 + 3,
                    size: Math.random() * 10 + 5, color: `hsl(${Math.random() * 360}, 100%, 70%)`,
                    rotation: Math.random() * 360, life: 1
                });
            }
            
            startAnimation('game-clear', 3000, () => {
                if (gameState.clearedStages['하'] && gameState.clearedStages['중'] && gameState.clearedStages['상']) {
                    gameState.isChallengeUnlocked = true;
                    gameState.player.level = 4;
                    startGrandFinale();
                } else {
                    saveGame(false);
                    showMessage(`난이도 '${gameState.difficulty}' 클리어!<br>레벨 업! (현재 LV.${gameState.player.level})`, setupDifficultyScreen);
                }
            });
        }

        function startGrandFinale() {
            effectParticles = [];
            for (let i = 0; i < 200; i++) {
                effectParticles.push({
                    type: 'confetti', x: Math.random() * canvas.width, y: Math.random() * -canvas.height,
                    vx: Math.random() * 6 - 3, vy: Math.random() * 5 + 3,
                    size: Math.random() * 10 + 5, color: `hsl(${Math.random() * 360}, 100%, 70%)`,
                    rotation: Math.random() * 360, life: 1
                });
            }
            startAnimation('grand-finale', 6000, () => {
                saveGame(false);
                showMessage("지식의 서를 얻고 세상의 모든 지식을 손에 넣었습니다. 축하합니다!", setupDifficultyScreen);
            });
        }

        function showChallengeResult() {
           let resultText = `
               <h2>도전 결과</h2>
               <p><b>${gameState.player.name}</b>님의 최종 점수는 <b>${gameState.score}점</b> 입니다!</p>
               <div class="capture-guide">
                   <h4>결과 화면 캡처 안내</h4>
                   <ul>
                       <li><b>📱 아이폰:</b> 측면 버튼 + 음량 높이기 버튼 동시 누르기</li>
                       <li><b>📱 안드로이드:</b> 전원 버튼 + 음량 낮추기 버튼 동시 누르기</li>
                       <li><b>💻 윈도우:</b> 윈도우 키 + Shift + S</li>
                       <li><b>💻 맥:</b> Shift + Command + 4</li>
                   </ul>
               </div>
           `;
           showMessage(resultText, setupDifficultyScreen);
        }

        // ==================================================================
        // UI 업데이트 및 유틸리티
        // ==================================================================
        function updateStatus() {
            document.getElementById('status-name').textContent = gameState.player.name;
            document.getElementById('status-level').textContent = gameState.player.level;
            document.getElementById('status-lives').textContent = '❤️'.repeat(gameState.lives);
            
            ultimateSkillBtn.classList.toggle('disabled', gameState.hasUsedUltimate);
            
            updateProgressDisplay();
        }
        
        function updateProgressDisplay() {
            let progressText = ``;
            if (gameState.difficulty === '도전자') {
                progressText = `점수: ${gameState.score}`;
            } else {
                const bossThresholds = { '하': 5, '중': 8, '상': 10 };
                const needed = bossThresholds[gameState.difficulty];
                const remaining = Math.max(0, needed - gameState.questionsCorrect);
                progressText = `푼 문제: ${gameState.questionsAttempted} | 정답: ${gameState.questionsCorrect}`;
                if (!gameState.isBossFight && !gameState.clearedStages[gameState.difficulty]) {
                    progressText += ` | 보스까지: ${remaining}문제`;
                }
            }
            progressDisplay.textContent = progressText;
        }

        function lockInput() { isInputLocked = true; }
        function unlockInput() { isInputLocked = false; }

        function showMessage(text, callback) {
            lockInput();
            messageText.innerHTML = text;
            messageModal.style.display = 'flex';
            
            const newOkBtn = messageOkBtn.cloneNode(true);
            messageOkBtn.parentNode.replaceChild(newOkBtn, messageOkBtn); 
            messageOkBtn = newOkBtn; 

            messageOkBtn.onclick = () => {
                messageModal.style.display = 'none';
                unlockInput();
                if (callback) callback();
            };
        }
        
        function showTemporaryMessage(text, duration, callback) {
            return new Promise(resolve => {
                lockInput();
                tempMessageOverlay.textContent = text;
                tempMessageOverlay.classList.add('visible');
                
                setTimeout(() => {
                    tempMessageOverlay.classList.remove('visible');
                    unlockInput();
                    if (callback) callback();
                    resolve();
                }, duration);
            });
        }

        function saveGame(showAlert = true) {
            try {
                localStorage.setItem('crimeQuizRPGSave', JSON.stringify({
                    player: gameState.player,
                    clearedStages: gameState.clearedStages,
                    isChallengeUnlocked: gameState.isChallengeUnlocked
                }));
                if (showAlert) {
                    showMessage("게임이 저장되었습니다.");
                }
            } catch (e) {
                console.error("로컬 스토리지 저장 실패:", e);
                if (showAlert) {
                    showMessage("게임을 저장하는 데 실패했습니다. 브라우저 설정을 확인해주세요.");
                }
            }
        }

        function loadGame() {
            try {
                const saveData = localStorage.getItem('crimeQuizRPGSave');
                if (saveData) {
                    const parsedData = JSON.parse(saveData);
                    resetGameState();
                    gameState.player = parsedData.player;
                    gameState.clearedStages = parsedData.clearedStages;
                    gameState.isChallengeUnlocked = parsedData.isChallengeUnlocked || false;
                    document.getElementById('character-name').value = gameState.player.name;
                    showMessage(`'${gameState.player.name}'님의 데이터를 불러왔습니다.`, setupDifficultyScreen);
                } else {
                    showMessage("저장된 게임이 없습니다.");
                }
            } catch(e) {
               console.error("로컬 스토리지 불러오기 실패:", e);
               showMessage("저장된 게임을 불러오는 데 실패했습니다.");
            }
        }

        function resizeCanvas() {
            const container = document.getElementById('game-screen');
            if(container) {
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
            }
        }
        
        // ==================================================================
        // 렌더링 (그리기) 함수
        // ==================================================================
        function drawDungeonBackground(deltaTime) {
            const difficulty = gameState.difficulty;
            const isBoss = gameState.isBossFight;
            let grad1 = '#2c2a4a', grad2 = '#1a1832', wall = '#33304a';

            if (isBoss || difficulty === '도전자') {
                grad1 = '#4d1a1a'; grad2 = '#2e0e0e'; wall = '#3d1a1a';
            } else if (difficulty === '상') {
                grad1 = '#4a2a4a'; grad2 = '#3b1b3b'; wall = '#402040';
            } else if (difficulty === '중') {
                grad1 = '#3a3a4a'; grad2 = '#2a2a3b'; wall = '#303040';
            }
            
            const bgGrad = ctx.createLinearGradient(0, 0, 0, canvas.height);
            bgGrad.addColorStop(0, grad1);
            bgGrad.addColorStop(0.6, grad2);
            bgGrad.addColorStop(1, '#000');
            ctx.fillStyle = bgGrad;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            if (difficulty === '중' || difficulty === '상' || isBoss || difficulty === '도전자') {
                 if (Math.random() < 0.05) {
                   backgroundParticles.push({ type: 'dust', x: Math.random() * canvas.width, y: 0, vx: (Math.random() - 0.5) * 0.5, vy: Math.random() * 0.5 + 0.2, life: 1, size: Math.random() * 2 + 1 });
                 }
            }
            if (difficulty === '상' || isBoss || difficulty === '도전자') {
                 if (Math.random() < 0.03) {
                   backgroundParticles.push({ type: 'ghost', x: Math.random() * canvas.width, y: Math.random() * canvas.height * 0.6, life: 1, opacity: 0, maxOpacity: Math.random() * 0.2 + 0.1 });
                 }
            }
            if (isBoss || difficulty === '도전자') {
                 if (Math.random() < 0.3) {
                   backgroundParticles.push({ type: 'lava_bubble', x: Math.random() * canvas.width, y: canvas.height, radius: Math.random() * 20 + 5, life: 1, speed: Math.random() * 1 + 0.5 });
                 }
                 if (Math.random() < 0.1) {
                   backgroundParticles.push({ type: 'ember', x: Math.random() * canvas.width, y: canvas.height, vx: (Math.random() - 0.5), vy: -(Math.random() * 3 + 2), life: 1, size: Math.random() * 3 + 1 });
                 }
            }

            updateAndDrawBackgroundParticles(deltaTime);

            ctx.strokeStyle = wall;
            ctx.lineWidth = 2;
            ctx.globalAlpha = 0.3;
            for(let y = 0; y < canvas.height; y += 40) {
                for(let x = (y/40 % 2) * -20; x < canvas.width; x += 40) {
                    ctx.strokeRect(x, y, 40, 40);
                }
            }
            ctx.globalAlpha = 1.0;
            
            drawPlatforms();

            if (isBoss || difficulty === '도전자') {
                drawLava(deltaTime);
            }
        }
        
        function drawPlatforms() {
            const platformHeight = canvas.height * 0.8;
            const platformThickness = 40;
            
            // Draw Player Platform
            const pPlatformWidth = canvas.width * 0.4;
            const pPlatformX = canvas.width * 0.1;
            drawStonePlatform(pPlatformX, platformHeight, pPlatformWidth, platformThickness);

            // Draw Monster Platform
            const mPlatformWidth = canvas.width * 0.4;
            const mPlatformX = canvas.width * 0.9 - mPlatformWidth;
            drawStonePlatform(mPlatformX, platformHeight, mPlatformWidth, platformThickness);
        }

        function drawStonePlatform(x, y, width, height) {
            // Main platform color
            ctx.fillStyle = '#4a4a5a';
            ctx.fillRect(x, y, width, height);
            
            // Top highlight
            ctx.fillStyle = '#6b6b7b';
            ctx.fillRect(x, y, width, 5);

            // Front face with cracks
            ctx.fillStyle = '#3a3a4a';
            ctx.fillRect(x, y + 5, width, height - 5);
            
            ctx.strokeStyle = '#2a2a3a';
            ctx.lineWidth = 2;
            for(let i = 0; i < width / 50; i++) {
                const crackX = x + Math.random() * width;
                const crackY = y + 5 + Math.random() * (height - 10);
                ctx.beginPath();
                ctx.moveTo(crackX, crackY);
                ctx.lineTo(crackX + (Math.random() - 0.5) * 20, crackY + (Math.random() - 0.5) * 20);
                ctx.stroke();
            }
        }


        function updateAndDrawBackgroundParticles(deltaTime) {
            backgroundParticles.forEach((p, i) => {
                p.life -= 0.0005 * deltaTime;
                if (p.life <= 0) { backgroundParticles.splice(i, 1); return; }

                ctx.save();
                if (p.type === 'dust') {
                    p.x += p.vx; p.y += p.vy;
                    ctx.fillStyle = `rgba(200, 200, 200, ${p.life * 0.5})`;
                    ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill();
                } else if (p.type === 'ghost') {
                    p.x += Math.sin(p.life * 5) * 0.5;
                    p.y += Math.cos(p.life * 3) * 0.5;
                    if (p.life > 0.5) p.opacity = Math.min(p.maxOpacity, p.opacity + 0.01);
                    else p.opacity = Math.max(0, p.opacity - 0.01);
                    ctx.fillStyle = `rgba(230, 230, 255, ${p.opacity})`;
                    ctx.font = "40px 'MedievalSharp'";
                    ctx.fillText('👻', p.x, p.y);
                } else if (p.type === 'lava_bubble') {
                    p.y -= p.speed;
                    p.radius *= 0.99;
                    if (p.y < canvas.height * 0.8) p.life = 0;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 255, 0, ${p.life * 0.7})`;
                    ctx.fill();
                } else if (p.type === 'ember') {
                    p.x += p.vx; p.y += p.vy;
                    p.vy += 0.05; // gravity
                    ctx.fillStyle = `rgba(255, 100, 0, ${p.life})`;
                    ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill();
                }
                ctx.restore();
            });
        }

        function drawLava(deltaTime) {
            const lavaY = canvas.height * 0.8;
            const grad = ctx.createLinearGradient(0, lavaY, 0, canvas.height);
            grad.addColorStop(0, '#ff8c00');
            grad.addColorStop(0.5, '#ff4500');
            grad.addColorStop(1, '#8b0000');
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.moveTo(0, lavaY);
            for (let x = 0; x <= canvas.width; x += 20) {
                const yOffset = Math.sin(x / 50 + Date.now() / 500) * 10;
                ctx.lineTo(x, lavaY + yOffset);
            }
            ctx.lineTo(canvas.width, canvas.height);
            ctx.lineTo(0, canvas.height);
            ctx.closePath();
            ctx.fill();
        }

        function drawCharacter(bobbing) {
            const img = loadedImages[gameState.player.imageKey];
            if (!img) return;

            const anim = gameState.animation;
            let size = Math.min(canvas.width, canvas.height) * 0.25;
            let yOffset = bobbing ? Math.sin(Date.now() / 200) * 5 : 0;
            let xPos = canvas.width * 0.25 - size / 2;
            let yPos = canvas.height * 0.8 - size;
            let alpha = 1.0;
            
            if (anim.type === 'monster-attack') {
                const progress = anim.progress / anim.duration;
                if (progress > 0.4 && progress < 0.7) { // Impact window
                    const shakeProgress = Math.sin((progress - 0.4) / 0.3 * Math.PI);
                    xPos += (Math.random() - 0.5) * 20 * shakeProgress;
                    yPos += (Math.random() - 0.5) * 10 * shakeProgress;
                }
            } else if (anim.type === 'grand-finale') {
               size = Math.min(canvas.width, canvas.height) * 0.35;
               xPos = canvas.width / 2 - size / 2;
               yPos = canvas.height * 0.5 - size;
               yOffset += Math.abs(Math.sin(Date.now() / 200) * -15);
            }
            
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.drawImage(img, xPos, yPos + yOffset, size, size);
            ctx.restore();
        }

        function drawMonster() {
            if (gameState.currentMonster && gameState.currentMonster.imageKey) {
                const img = loadedImages[gameState.currentMonster.imageKey];
                if (img) {
                    const anim = gameState.animation;
                    const monster = gameState.currentMonster;
                    const size = Math.min(canvas.width, canvas.height) * 0.3;
                    let x = canvas.width * 0.75 - size / 2;
                    let y = canvas.height * 0.8 - size;
                    
                    if (anim.type === 'attack' || anim.type === 'ultimate-attack') {
                        const progress = anim.progress / anim.duration;
                        const shakeProgress = Math.sin(progress * Math.PI);
                        x += (Math.random() - 0.5) * 15 * shakeProgress;
                        y += (Math.random() - 0.5) * 15 * shakeProgress;
                    } else if (anim.type === 'monster-attack') {
                        const progress = anim.progress / anim.duration;
                        // Lunge forward and back
                        const lungeProgress = Math.sin(progress * Math.PI);
                        x -= lungeProgress * 100;
                    }
                    
                    ctx.save();
                    ctx.globalAlpha = monster.alpha;
                    ctx.drawImage(img, x, y, size, size);
                    ctx.restore();
                }
            }
        }
        
        function drawEffects(deltaTime) {
            if (gameState.animation.type === 'attack') {
                drawNormalAttack();
            }
            else if (gameState.animation.type === 'ultimate-attack') {
                drawUltimateAttack();
            }
            else if (gameState.animation.type === 'monster-attack') {
                const progress = gameState.animation.progress / gameState.animation.duration;
                if (progress > 0.4 && progress < 0.7) {
                    const playerX = canvas.width * 0.25;
                    const playerY = canvas.height * 0.8 - (Math.min(canvas.width, canvas.height) * 0.25) / 2;
                    drawImpactEffect(playerX, playerY, progress);
                }
            }
            else if (gameState.animation.type === 'grand-finale' || gameState.animation.type === 'game-clear') {
                drawConfetti(deltaTime);
                if(gameState.animation.type === 'grand-finale') {
                    drawBowingMonsters();
                    drawKnowledgeBook();
                }
            }
            
            updateAndDrawMiscParticles(deltaTime);
        }

        function drawImpactEffect(x, y, progress) {
            const p = Math.sin((progress - 0.4) / 0.3 * Math.PI);
            const size = 150 * p;
            ctx.save();
            ctx.translate(x, y);
            ctx.strokeStyle = `rgba(255, 220, 0, ${1-p})`;
            ctx.lineWidth = 10 * (1-p);
            for(let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(Math.cos(angle) * size, Math.sin(angle) * size);
                ctx.stroke();
            }
            ctx.restore();
        }
        
        // ==================================================================
        // 스킬 이펙트 함수 (수정된 부분)
        // ==================================================================
        function drawNormalAttack() {
            const progress = Math.min(1, gameState.animation.progress / gameState.animation.duration);
            const level = gameState.player.level;
            const startX = canvas.width * 0.35;
            const startY = canvas.height * 0.65;
            const endX = canvas.width * 0.7;
            const endY = canvas.height * 0.65;
            
            if (gameState.player.class === '전사') {
                 // ... (기존 전사 공격 코드)
                 const easeOutProgress = 1 - Math.pow(1 - progress, 4);
                 const travelX = startX + (endX - startX) * easeOutProgress;
                 const alpha = Math.sin(progress * Math.PI);

                 if (level <= 1) {
                     drawSharpSlash(travelX, startY, 120, 60, alpha, 'white', 'white', 15, 8);
                 } else if (level === 2) {
                     drawSharpSlash(travelX, startY, 140, 70, alpha, '#ffdd00', '#ffdd00', 25, 10);
                 } else if (level === 3) {
                     const p1 = Math.sin(Math.min(1, progress / 0.7) * Math.PI);
                     const p2 = Math.sin(Math.max(0, (progress - 0.3) / 0.7) * Math.PI);
                     drawSharpSlash(endX, startY - 30, 180, 80, p1, '#ff8800', '#ff4400', 35, 15, -20);
                     drawSharpSlash(endX, startY + 30, 180, 80, p2, '#ff8800', '#ff4400', 35, 15, 20);
                 } else if (level === 4) {
                     const p_main = Math.sin(Math.min(1, progress / 0.6) * Math.PI);
                     const p_cross = Math.sin(Math.max(0, (progress-0.4)/0.6) * Math.PI);
                     ctx.save();
                     ctx.translate(endX, startY);
                     drawSharpSlash(0, 0, 300, 150, p_main, 'cyan', 'white', 60, 30, 45);
                     drawSharpSlash(0, 0, 300, 150, p_cross, 'red', 'white', 60, 20, -45);
                     ctx.restore();
                 } else { // Level 5
                     const p = Math.sin(progress * Math.PI);
                     ctx.save();
                     ctx.translate(endX, startY);
                     ctx.shadowColor = '#e74c3c';
                     ctx.shadowBlur = 40 * p;
                     drawSharpSlash(0, 0, 400 * p, 200 * p, 1, '#2c3e50', '#e74c3c', 20, 25, 15);
                     drawSharpSlash(0, 0, 350 * p, 180 * p, 1, '#bdc3c7', '#e74c3c', 10, 15, 15);
                     ctx.restore();
                     if(progress > 0.2 && progress < 0.8) {
                         const shake = 20 * p;
                         canvas.style.transform = `translate(${Math.random() * shake - shake/2}px, ${Math.random() * shake - shake/2}px)`;
                     } else {
                         canvas.style.transform = 'none';
                     }
                 }
            } else if (gameState.player.class === '마법사') {
                const p = Math.pow(progress, 2);
                const chargeProgress = Math.min(1, progress / 0.5);
                const travelProgress = Math.max(0, (progress - 0.5) / 0.5);
                const impactProgress = Math.max(0, (progress - 0.9) / 0.1);

                const projectileX = startX + (endX - startX) * travelProgress;
                const projectileY = startY;

                if (level <= 3) { // 기존 1-3레벨 마법사 공격
                    const currentX = startX + (endX - startX) * progress;
                    const currentY = startY;
                    if (level <= 1) { // Magic Missile
                        ctx.fillStyle = `rgba(173, 216, 230, ${1 - progress})`;
                        ctx.shadowColor = 'cyan'; ctx.shadowBlur = 15;
                        ctx.beginPath(); ctx.arc(currentX, currentY, 20, 0, Math.PI * 2); ctx.fill();
                    } else if (level === 2) { // Ice Bolt
                        if (Math.random() > 0.3) {
                            effectParticles.push({ type: 'ice_shard', x: currentX, y: currentY, vx: 20, vy: (Math.random()-0.5)*5, life: 0.5, size: 25 });
                        }
                    } else { // Chain Lightning
                        if (progress > 0.1 && progress < 0.9 && Math.random() > 0.5) {
                            effectParticles.push({ type: 'lightning', x: startX, y: startY, tx: endX, ty: endY, life: 0.5, color: '#f1c40f' });
                        }
                    }
                } else if (level === 4) { // Lv 4: 화염 운석 (요청사항 3 반영)
                    drawMagicCircle(startX, startY, 70 * chargeProgress, '#e74c3c', `rgba(255, 100, 0, ${0.5 * chargeProgress})`);
                    if (progress > 0.5) {
                        drawMeteorProjectile(projectileX, projectileY, 45); // 크기 증가
                    }
                    if (impactProgress > 0) {
                        drawExplosion(endX, endY, 250 * impactProgress, '#ff4500', 'red'); // 폭발 크기 증가
                    }
                } else { // Lv 5: 원소 폭발 (요청사항 3 반영)
                    const colors = ['#e74c3c', '#3498db', '#f1c40f', '#2ecc71'];
                    drawMagicCircle(startX, startY, 80 * chargeProgress, 'white', `rgba(255, 255, 255, ${0.3 * chargeProgress})`, colors);
                    if (progress > 0.5) {
                        colors.forEach((color, i) => {
                            const angle = (i / colors.length) * Math.PI * 2 + progress * 10;
                            const orbitX = projectileX + Math.cos(angle) * 40; // 궤도 증가
                            const orbitY = projectileY + Math.sin(angle) * 40; // 궤도 증가
                            drawElementProjectile(orbitX, orbitY, 25, color); // 크기 증가
                        });
                    }
                    if (impactProgress > 0) {
                        colors.forEach(color => {
                            const offsetX = (Math.random() - 0.5) * 120; // 폭발 범위 증가
                            const offsetY = (Math.random() - 0.5) * 120; // 폭발 범위 증가
                            drawExplosion(endX + offsetX, endY + offsetY, 180 * impactProgress, color, color); // 폭발 크기 증가
                        });
                    }
                }
            }
            ctx.shadowBlur = 0;
            if (progress >= 1) canvas.style.transform = 'none'; // Reset screenshake
        }
        
        function drawUltimateAttack() {
            const progress = Math.min(1, gameState.animation.progress / gameState.animation.duration);
            const level = gameState.player.level;

            ctx.fillStyle = `rgba(0,0,0, ${0.8 * Math.sin(progress * Math.PI)})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (gameState.player.class === '전사') {
                // ... (기존 전사 궁극기 코드)
                if (level <= 2) { // Lv 1, 2
                    if (progress > 0.1 && progress < 0.8) drawRandomSlash(level + 1, 180 + level * 40, level === 2 ? '#ffdd00' : 'white');
                    if (progress > 0.8) drawFinalSlash(progress, level === 2 ? '#ffdd00' : '#aaa', 200 + level * 50);
                } else if (level === 3) { // Lv 3: 검의 비 + 종단 참격
                    if (Math.random() < progress * 5) {
                        const sx = Math.random() * canvas.width;
                        const ex = sx + (Math.random() - 0.5) * 50;
                        const ey = canvas.height * 0.8;
                        effectParticles.push({ type: 'falling_weapon', sx: sx, sy: -50, ex: ex, ey: ey, life: 1, maxLife: 1, weapon: 'sword' });
                    }
                    if (progress > 0.1 && progress < 0.9) drawRandomSlash(5, 250, '#aaa');
                    if (progress > 0.7) drawFinalSlash(progress, '#ff4400', 350, false, true); // 종단 참격
                } else if (level === 4) { // Lv 4: 병기 폭풍 + 종/횡단 참격
                    if (Math.random() < progress * 7) {
                        const weaponTypes = ['sword', 'spear', 'arrow'];
                        const weapon = weaponTypes[Math.floor(Math.random() * weaponTypes.length)];
                        const sx = Math.random() * canvas.width;
                        const ex = sx + (Math.random() - 0.5) * 100;
                        const ey = canvas.height * 0.8;
                        effectParticles.push({ type: 'falling_weapon', sx: sx, sy: -50, ex: ex, ey: ey, life: 1, maxLife: 1, weapon: weapon });
                    }
                    if (progress > 0.1 && progress < 0.9) drawRandomSlash(7, 300, 'cyan');
                    if (progress > 0.6) drawFinalSlash(progress, 'cyan', 450, true, true); // 종/횡단 참격
                } else { // Lv 5: 천벌
                    if (Math.random() < progress * 10) {
                        const weaponTypes = ['sword', 'spear', 'arrow', 'shield', 'mace', 'axe'];
                        const weapon = weaponTypes[Math.floor(Math.random() * weaponTypes.length)];
                        const sx = Math.random() * canvas.width;
                        const ex = sx + (Math.random() - 0.5) * 150;
                        const ey = canvas.height * 0.8;
                        effectParticles.push({ type: 'falling_weapon', sx: sx, sy: -50, ex: ex, ey: ey, life: 1, maxLife: 1, weapon: weapon });
                    }
                    if (progress > 0.1 && progress < 0.95) drawRandomSlash(10, 400, '#e74c3c');
                    if (progress > 0.5) drawJudgmentSword(progress);
                }
            } else if (gameState.player.class === '마법사') {
                if (level <= 3) { // 기존 1-3레벨 궁극기
                    const effects = [drawIceRain, drawTornado, drawMultiLightning];
                    effects[level - 1](progress);
                } else if (level === 4) { // Lv 4: 유성우 (개선)
                    drawMeteorShower(progress);
                } else { // Lv 5: 원소의 격류 (개선)
                    drawGrandElemental(progress);
                }
            }
            
            // 전사 5레벨 궁극기 후 화면 틀어짐 버그 수정
            if (progress >= 1) {
                canvas.style.transform = 'none';
            }
        }

        function drawRandomSlash(count, length = 200, color = 'white') {
            for (let i = 0; i < count; i++) {
                if (Math.random() > 0.7) {
                    const x = Math.random() * canvas.width;
                    const y = Math.random() * canvas.height;
                    const angle = Math.random() * 360;
                    const l = Math.random() * (length * 0.5) + (length * 0.5);
                    drawSharpSlash(x, y, l, l/2, 1, color, color, 20, 10, angle);
                }
            }
        }

        function drawFinalSlash(progress, color, size, hasAura = false, isVertical = false) {
            const p = (progress - (hasAura ? 0.6 : 0.8)) / (hasAura ? 0.4 : 0.2);
            const alpha = Math.sin(p * Math.PI);
            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            if (hasAura) {
                const auraSize = size * 1.2 * alpha;
                const grad = ctx.createRadialGradient(0, 0, auraSize * 0.2, 0, 0, auraSize);
                grad.addColorStop(0, `rgba(255, 255, 255, ${alpha * 0.8})`);
                grad.addColorStop(0.5, `rgba(255, 255, 200, ${alpha * 0.5})`);
                grad.addColorStop(1, `rgba(255, 100, 100, 0)`);
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(0, 0, auraSize, 0, Math.PI * 2);
                ctx.fill();
            }
            const finalSlashSize = size * Math.min(1, p * 2);

            if (isVertical) {
                // 종단
                drawSharpSlash(0, 0, finalSlashSize * 1.5, finalSlashSize * 0.2, alpha, color, 'white', 50, 40, 90);
                if (hasAura) { // 횡단 추가
                    drawSharpSlash(0, 0, finalSlashSize * 1.5, finalSlashSize * 0.2, alpha, 'white', color, 50, 25, 0);
                }
            } else {
                drawSharpSlash(0, 0, finalSlashSize * 1.5, finalSlashSize * 0.75, alpha, color, 'white', 50, 40, 45);
                if (hasAura) {
                    drawSharpSlash(0, 0, finalSlashSize * 1.5, finalSlashSize * 0.75, alpha, 'white', color, 50, 25, -45);
                }
            }
            ctx.restore();
        }

        function drawJudgmentSword(progress) {
            const p = (progress - 0.5) / 0.5; // Starts at 50% progress
            if (p < 0) return;

            const fallProgress = Math.min(1, p / 0.7);
            const impactProgress = Math.max(0, (p - 0.7) / 0.3);

            const swordSize = canvas.width * 0.8;
            const startY = -swordSize;
            const endY = canvas.height / 2 - swordSize * 0.3;
            const currentY = startY + (endY - startY) * (1 - Math.pow(1 - fallProgress, 4)); // EaseOutQuad

            // Draw Sword
            ctx.save();
            ctx.translate(canvas.width / 2, currentY);
            ctx.fillStyle = `rgba(220, 220, 255, ${Math.sin(fallProgress * Math.PI)})`;
            ctx.shadowColor = 'cyan';
            ctx.shadowBlur = 50;
            // Blade
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-swordSize * 0.1, swordSize * 0.7);
            ctx.lineTo(0, swordSize);
            ctx.lineTo(swordSize * 0.1, swordSize * 0.7);
            ctx.closePath();
            ctx.fill();
            // Hilt
            ctx.fillStyle = 'gold';
            ctx.fillRect(-swordSize * 0.2, swordSize * 0.65, swordSize * 0.4, swordSize * 0.05);
            ctx.restore();

            // Impact
         if (impactProgress > 0) {
    const shockwaveAlpha = Math.sin(impactProgress * Math.PI);
    ctx.strokeStyle = `rgba(255, 255, 255, ${shockwaveAlpha})`;
    ctx.lineWidth = 20 * (1 - impactProgress);
    ctx.beginPath();
    ctx.arc(canvas.width / 2, endY + swordSize, canvas.width * impactProgress, 0, Math.PI * 2);
    ctx.stroke();

    // Final massive slash
    drawFinalSlash(impactProgress, '#e74c3c', canvas.width * 1.2, true, true);

    // Screen shake
    const shake = 30 * shockwaveAlpha;
    // 흔들림 효과가 있을 때만 transform을 적용합니다.
    if (shake > 0) {
        canvas.style.transform = `translate(${Math.random() * shake - shake/2}px, ${Math.random() * shake - shake/2}px)`;
    } else {
        canvas.style.transform = 'none';
    }
} else {
    // 효과 범위가 아닐 때는 항상 화면을 원래대로 되돌립니다.
    canvas.style.transform = 'none';
}
                } else {
                    canvas.style.transform = 'none';
                }
            }
        }

        function drawIceRain(progress) {
            if (Math.random() < progress * 2) {
                const x = Math.random() * canvas.width;
                const life = Math.random() * 0.5 + 0.5;
                effectParticles.push({ type: 'ice_rain', x: x, y: -40, life: life, speed: Math.random() * 15 + 15, size: Math.random() * 30 + 20 });
            }
        }

        function drawTornado(progress) {
            const centerX = canvas.width / 2 + Math.sin(progress * Math.PI * 4) * 80;
            const p = Math.sin(progress * Math.PI);
            for(let i=0; i<120; i++) {
                const angle = (Date.now() / 8 + i * 25) * 0.1;
                const radius = (1 - (i/120)) * canvas.width * 0.5 * p * (1 + Math.sin(progress * Math.PI * 2) * 0.1);
                const x = centerX + Math.cos(angle) * radius;
                const y = canvas.height - (i/120) * canvas.height * 1.3;
                ctx.fillStyle = `rgba(200, 220, 230, ${Math.random() * 0.4 * p})`;
                ctx.beginPath();
                ctx.arc(x, y, i/1.5, 0, Math.PI*2);
                ctx.fill();
            }
            if (Math.random() < p) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * canvas.width * 0.7 + canvas.width * 0.3;
                effectParticles.push({ type: 'sucked_particle', x: centerX + Math.cos(angle) * radius, y: Math.random() * canvas.height, life: 1, targetX: centerX, targetY: canvas.height / 2 });
            }
        }

        function drawMultiLightning(progress) {
            if (Math.random() < progress * 3) {
                const startX = Math.random() * canvas.width;
                const endX = canvas.width * 0.75 - 100 + Math.random() * 200;
                const endY = canvas.height * 0.8 - 100 + Math.random() * 100;
                effectParticles.push({ type: 'lightning', x: startX, y: 0, tx: endX, ty: endY, life: 0.4, color: '#f1c40f' });
            }
        }
        
        // --- 신규/수정된 마법사 스킬 이펙트 함수 ---

        function drawMagicCircle(x, y, radius, color, glowColor, segmentColors = []) {
            ctx.save();
            ctx.translate(x, y);
            
            // Glow
            ctx.shadowColor = glowColor;
            ctx.shadowBlur = radius * 0.8;
            
            // Outer rings
            ctx.strokeStyle = color;
            ctx.lineWidth = radius * 0.05;
            ctx.beginPath();
            ctx.arc(0, 0, radius, 0, Math.PI * 2);
            ctx.stroke();

            ctx.lineWidth = radius * 0.02;
            ctx.beginPath();
            ctx.arc(0, 0, radius * 0.8, 0, Math.PI * 2);
            ctx.stroke();

            // Rotating segments
            const time = Date.now() / 1000;
            if (segmentColors.length > 0) {
                segmentColors.forEach((segColor, i) => {
                    ctx.strokeStyle = segColor;
                    ctx.beginPath();
                    ctx.arc(0, 0, radius * 0.9, time + i * Math.PI * 2 / segmentColors.length, time + (i + 0.5) * Math.PI * 2 / segmentColors.length);
                    ctx.stroke();
                });
            }

            // Runes
            ctx.fillStyle = color;
            ctx.font = `${radius * 0.2}px 'Cinzel Decorative'`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            for (let i = 0; i < 6; i++) {
                const angle = i * (Math.PI / 3) + time;
                const runeX = Math.cos(angle) * radius * 0.6;
                const runeY = Math.sin(angle) * radius * 0.6;
                ctx.save();
                ctx.translate(runeX, runeY);
                ctx.rotate(angle + Math.PI / 2);
                ctx.fillText('※', 0, 0);
                ctx.restore();
            }
            
            ctx.restore();
        }

        function drawMeteorProjectile(x, y, size) {
            ctx.save();
            // Core
            const grad = ctx.createRadialGradient(x, y, 0, x, y, size);
            grad.addColorStop(0, 'white');
            grad.addColorStop(0.3, '#ffcc00');
            grad.addColorStop(0.8, '#e74c3c');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();

            // Rocky texture
            ctx.fillStyle = 'rgba(50, 30, 20, 0.7)';
            for (let i = 0; i < 5; i++) {
                const angle = Math.random() * Math.PI * 2;
                const r = Math.random() * size * 0.8;
                const patchSize = Math.random() * size * 0.3 + size * 0.1;
                ctx.beginPath();
                ctx.arc(x + Math.cos(angle) * r, y + Math.sin(angle) * r, patchSize, 0, Math.PI * 2);
                ctx.fill();
            }

            // Fire trail
            if (Math.random() > 0.2) {
                effectParticles.push({ type: 'ember', x: x, y: y, vx: (Math.random()-0.5)*4, vy: (Math.random()-0.5)*4, life: 0.4, size: Math.random() * 5 + 2 });
            }
            ctx.restore();
        }

        function drawElementProjectile(x, y, size, color) {
            ctx.save();
            ctx.fillStyle = color;
            ctx.shadowColor = 'white';
            ctx.shadowBlur = 15;
            
            switch(color) {
                case '#e74c3c': // Fire
                    drawMeteorProjectile(x, y, size);
                    break;
                case '#3498db': // Ice
                    ctx.beginPath();
                    for(let i=0; i<5; i++){
                        const angle = i * (Math.PI * 2 / 5);
                        ctx.lineTo(x + Math.cos(angle) * size, y + Math.sin(angle) * size);
                        ctx.lineTo(x + Math.cos(angle + Math.PI / 5) * size * 0.5, y + Math.sin(angle + Math.PI / 5) * size * 0.5);
                    }
                    ctx.closePath();
                    ctx.fill();
                    break;
                case '#f1c40f': // Lightning
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    for(let i=0; i<8; i++){
                        const angle = i * (Math.PI / 4);
                        ctx.moveTo(x, y);
                        ctx.lineTo(x + Math.cos(angle) * size, y + Math.sin(angle) * size);
                    }
                    ctx.stroke();
                    break;
                case '#2ecc71': // Wind
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 1.5, false);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(x, y, size * 0.6, Math.PI, Math.PI * 2.5, false);
                    ctx.stroke();
                    break;
            }
            ctx.restore();
        }

        function drawExplosion(x, y, radius, color, glowColor) {
            ctx.save();
            const grad = ctx.createRadialGradient(x, y, 0, x, y, radius);
            grad.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
            grad.addColorStop(0.5, color);
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            
            ctx.fillStyle = grad;
            ctx.shadowColor = glowColor;
            ctx.shadowBlur = radius * 0.5;
            
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        function drawMeteorShower(progress) {
            const chargeProgress = Math.min(1, progress / 0.4);
            const rainProgress = Math.max(0, (progress - 0.3) / 0.7);

            // 1. 화면을 꽉 채우는 붉은 마법진
            drawMagicCircle(canvas.width / 2, canvas.height / 2, canvas.width * 0.6 * chargeProgress, '#e74c3c', `rgba(255, 0, 0, ${0.5 * chargeProgress})`);

            // 2. 메테오 낙하
            if (rainProgress > 0 && Math.random() < rainProgress * 5) {
                const startX = Math.random() * canvas.width * 1.5 - canvas.width * 0.25;
                const endX = Math.random() * canvas.width;
                const duration = Math.random() * 0.5 + 0.3;
                effectParticles.push({ type: 'meteor', sx: startX, sy: -100, ex: endX, ey: canvas.height * 0.8, life: duration, maxLife: duration, size: Math.random() * 40 + 20 });
            }
        }

        function drawGrandElemental(progress) {
            const chargeProgress = Math.min(1, progress / 0.5);
            const rainProgress = Math.max(0, (progress - 0.4) / 0.6);
            const impactProgress = Math.max(0, (progress - 0.85) / 0.15);
            const colors = ['#e74c3c', '#3498db', '#f1c40f', '#2ecc71']; // 불, 냉기, 번개, 바람

            // 1. 모든 원소 색의 마법진
            drawMagicCircle(canvas.width / 2, canvas.height / 2, canvas.width * 0.7 * chargeProgress, 'white', `rgba(255, 255, 255, ${0.3 * chargeProgress})`, colors);
            
            // 2. 모든 원소 공격 낙하 및 폭발
            if (rainProgress > 0 && Math.random() < rainProgress * 8) {
                const type = colors[Math.floor(Math.random() * colors.length)];
                const startX = Math.random() * canvas.width;
                const endX = Math.random() * canvas.width;
                const duration = Math.random() * 0.4 + 0.2;
                effectParticles.push({ type: 'elemental_rain', elementType: type, sx: startX, sy: -100, ex: endX, ey: canvas.height * 0.8, life: duration, maxLife: duration, size: Math.random() * 30 + 20 });
            }

            // 3. 최종 거대 폭발 (요청사항 4 반영)
            if(impactProgress > 0) {
                const finalExplosionRadius = canvas.width * 1.5 * impactProgress;
                const grad = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, canvas.width/2, canvas.height/2, finalExplosionRadius);
                grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
                grad.addColorStop(0.1, 'rgba(255, 255, 255, 0.8)');
                grad.addColorStop(0.4, 'rgba(155, 89, 182, 0.5)');
                grad.addColorStop(1, 'rgba(155, 89, 182, 0)');
                ctx.fillStyle = grad;
                ctx.fillRect(0,0, canvas.width, canvas.height);
            }
        }

        // --- 기타 이펙트 함수 ---
        
        function drawConfetti(deltaTime) {
             effectParticles.forEach((p, index) => {
                 p.life -= deltaTime / 3000;
                 if (p.life <= 0) { effectParticles.splice(index, 1); return; }
                 
                 p.x += p.vx * (deltaTime / 16); p.y += p.vy * (deltaTime / 16);
                 p.vy += 0.1 * (deltaTime / 16);
                 
                 ctx.save();
                 ctx.globalAlpha = p.life > 0 ? p.life : 0;
                 ctx.translate(p.x, p.y);
                 ctx.fillStyle = p.color;
                 ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
                 ctx.restore();
               });
        }
        
        function updateAndDrawMiscParticles(deltaTime) {
            effectParticles.forEach((p, index) => {
                p.life -= deltaTime / 1000;
                if (p.life <= 0) { effectParticles.splice(index, 1); return; }
                
                ctx.save();
                ctx.globalAlpha = p.life > 0 ? p.life : 0;
                
                if (p.type === 'lightning') {
                    ctx.strokeStyle = p.color || `hsl(${200 + Math.random()*100}, 100%, ${70 + Math.random()*30}%)`;
                    ctx.lineWidth = Math.random() * 5 + 2;
                    ctx.shadowColor = p.color || '#9b59b6'; ctx.shadowBlur = 20;
                    ctx.beginPath(); ctx.moveTo(p.x, p.y);
                    for(let i=1; i<=5; i++) {
                        const nx = p.x + (p.tx-p.x) * (i/5) + (Math.random()-0.5)*40;
                        const ny = p.y + (p.ty-p.y) * (i/5) + (Math.random()-0.5)*40;
                        ctx.lineTo(nx, ny);
                    }
                    ctx.stroke();
                } else if (p.type === 'ice_shard' || p.type === 'ice_rain') {
                    p.x += (p.vx || 0) * (deltaTime/16); p.y += (p.vy || p.speed) * (deltaTime/16);
                    if (p.type === 'ice_rain' && p.y > canvas.height * 0.8) {
                        p.life = 0;
                        for(let i=0; i<8; i++) effectParticles.push({ type: 'frost', x: p.x, y: p.y, life: 0.8, vx: (Math.random()-0.5)*4, vy: (Math.random()-0.5)*4 });
                    }
                    ctx.fillStyle = 'rgba(173, 216, 230, 0.9)';
                    ctx.strokeStyle = 'white'; ctx.lineWidth = 3;
                    ctx.shadowColor = 'cyan'; ctx.shadowBlur = 15;
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y); ctx.lineTo(p.x - p.size/2, p.y + p.size); ctx.lineTo(p.x + p.size/2, p.y + p.size);
                    ctx.closePath();
                    ctx.fill(); ctx.stroke();
                } else if (p.type === 'frost') {
                    p.x += p.vx; p.y += p.vy;
                    ctx.fillStyle = `rgba(200, 230, 255, ${p.life * 0.7})`;
                    ctx.beginPath(); ctx.arc(p.x, p.y, 5, 0, Math.PI*2); ctx.fill();
                } else if (p.type === 'dark_energy') {
                    p.x += p.vx; p.y += p.vy;
                    ctx.fillStyle = `hsl(${280 + Math.random()*40}, 100%, 50%)`;
                    ctx.beginPath(); ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2); ctx.fill();
                } else if (p.type === 'sucked_particle') {
                    p.x += (p.targetX - p.x) * 0.15;
                    p.y += (p.targetY - p.y) * 0.15;
                    const dist = Math.hypot(p.x - p.targetX, p.y - p.targetY);
                    if (dist < 20) p.life = 0;
                    ctx.fillStyle = `rgba(200, 180, 255, ${p.life * 0.7})`;
                    ctx.beginPath(); ctx.arc(p.x, p.y, 3, 0, Math.PI*2); ctx.fill();
                } else if (p.type === 'meteor') {
                    const p_life = 1 - (p.life / p.maxLife);
                    p.x = p.sx + (p.ex - p.sx) * p_life;
                    p.y = p.sy + (p.ey - p.sy) * p_life;
                    if (p.life < 0.1) {
                        p.life = 0;
                        drawExplosion(p.x, p.y, 250, '#ff4500', 'red'); // 크기 증가
                    }
                    drawMeteorProjectile(p.x, p.y, p.size);
                } else if (p.type === 'elemental_rain') {
                    const p_life = 1 - (p.life / p.maxLife);
                    p.x = p.sx + (p.ex - p.sx) * p_life;
                    p.y = p.sy + (p.ey - p.sy) * p_life;
                    if (p.life < 0.1) {
                        p.life = 0;
                        drawExplosion(p.x, p.y, 180, p.elementType, p.elementType); // 크기 증가
                    }
                    drawElementProjectile(p.x, p.y, p.size, p.elementType);
                } else if (p.type === 'falling_weapon') {
                    const p_life = 1 - (p.life / p.maxLife);
                    p.x = p.sx + (p.ex - p.sx) * p_life;
                    p.y = p.sy + (p.ey - p.sy) * p_life;
                    if (p.life < 0.1) {
                        p.life = 0;
                        for(let i=0; i<3; i++) effectParticles.push({ type: 'dust_puff', x: p.x, y: p.y, life: 0.5 });
                    }
                    drawWeapon(p.x, p.y, p.weapon, 50, 90 + p_life * 90);
                } else if (p.type === 'dust_puff') {
                    ctx.fillStyle = `rgba(150, 130, 110, ${p.life * 0.5})`;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 30 * (1-p.life), 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            });
            ctx.shadowBlur = 0;
        }
        
        function drawWeapon(x, y, type, size, angle) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle * Math.PI / 180);
            ctx.fillStyle = '#aaa';
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 2;
            switch (type) {
                case 'sword':
                    ctx.fillRect(-size * 0.1, -size * 0.8, size * 0.2, size); // blade
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(-size * 0.2, -size * 0.1, size * 0.4, size * 0.1); // hilt
                    break;
                case 'spear':
                    ctx.fillRect(-size * 0.05, -size, size * 0.1, size * 1.2); // shaft
                    ctx.beginPath(); // head
                    ctx.moveTo(0, -size); ctx.lineTo(-size * 0.15, -size * 0.8); ctx.lineTo(size * 0.15, -size * 0.8);
                    ctx.closePath(); ctx.fill();
                    break;
                case 'arrow':
                    ctx.fillRect(-size * 0.03, -size * 0.8, size * 0.06, size); // shaft
                    ctx.beginPath(); // head
                    ctx.moveTo(0, -size * 0.8); ctx.lineTo(-size * 0.1, -size * 0.7); ctx.lineTo(size * 0.1, -size * 0.7);
                    ctx.closePath(); ctx.fill();
                    break;
                case 'shield':
                    ctx.beginPath();
                    ctx.arc(0, 0, size / 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    break;
                case 'mace':
                    ctx.fillRect(-size * 0.1, -size * 0.5, size * 0.2, size * 0.6); // handle
                    ctx.beginPath();
                    ctx.arc(0, -size * 0.5, size / 4, 0, Math.PI * 2); // head
                    ctx.fill();
                    break;
                case 'axe':
                    ctx.fillRect(-size * 0.1, -size * 0.5, size * 0.2, size); // handle
                    ctx.beginPath();
                    ctx.arc(-size * 0.1, -size * 0.5, size/2, -Math.PI/2, Math.PI/2);
                    ctx.closePath();
                    ctx.fill();
                    break;
            }
            ctx.restore();
        }

        function drawSharpSlash(x, y, height, width, alpha, color, shadowColor, shadowBlur, lineWidth, angle = 0) {
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.shadowColor = shadowColor;
            ctx.shadowBlur = shadowBlur;
            ctx.translate(x, y);
            ctx.rotate(angle * Math.PI / 180);
            ctx.beginPath();
            ctx.moveTo(0, -height / 2);
            ctx.bezierCurveTo(width * 0.8, -height * 0.2, width * 0.8, height * 0.2, 0, height / 2);
            ctx.stroke();
            ctx.restore();
        }

        function drawBowingMonsters() {
            const monsterKeys = ['하', '중', '상', '보스'];
            monsterKeys.forEach((key, index) => {
                const img = loadedImages[key];
                if (!img) return;
                const size = canvas.width * 0.15;
                const x = canvas.width * (0.15 + index * 0.22);
                const y = canvas.height * 0.85 - size;
                ctx.save();
                ctx.translate(x + size / 2, y + size);
                const bowAngle = 0.4 + Math.sin(Date.now() / 500 + index) * 0.1;
                ctx.rotate(bowAngle);
                ctx.drawImage(img, -size / 2, -size, size, size);
                ctx.restore();
            });
        }

        function drawKnowledgeBook() {
            const img = loadedImages['book'];
            if (!img) return;
            const progress = Math.min(1, gameState.animation.progress / 4000);
            const size = canvas.width * 0.25 * progress;
            const x = canvas.width / 2 - size / 2;
            const y = canvas.height * 0.5 - size / 2 + Math.sin(progress * Math.PI * 2) * 10;
            ctx.save();
            ctx.globalAlpha = progress;
            ctx.shadowColor = 'gold';
            ctx.shadowBlur = 30 * progress;
            ctx.drawImage(img, x, y, size, size);
            ctx.restore();
        }

        function drawGameOverAnimation(deltaTime) {
            const gravity = 0.5;
            gameOverDebris.forEach(p => {
                p.vy += gravity * (deltaTime / 16);
                p.x += p.vx * (deltaTime / 16);
                p.y += p.vy * (deltaTime / 16);
                p.rotation += p.vr * (deltaTime / 16);
                
                ctx.save();
                ctx.translate(p.x + p.width/2, p.y + p.height/2);
                ctx.rotate(p.rotation);
                ctx.fillStyle = p.color;
                ctx.fillRect(-p.width/2, -p.height/2, p.width, p.height);
                ctx.strokeStyle = '#2c2a4a';
                ctx.strokeRect(-p.width/2, -p.height/2, p.width, p.height);
                ctx.restore();
            });
        }
        
        // ==================================================================
        // 메인 게임 루프 (수정됨)
        // ==================================================================
        let lastTime = 0;
        function gameLoop(timestamp) {
            if (!gameState || gameState.currentScreen !== 'game-screen') {
                animationFrameId = null;
                return;
            }
            animationFrameId = requestAnimationFrame(gameLoop);

            const deltaTime = (timestamp - lastTime) || 16.6;
            lastTime = timestamp;

            if (gameState.animation.type) {
                gameState.animation.progress += deltaTime;
                if (gameState.animation.progress >= gameState.animation.duration) {
                    const onEndCallback = gameState.animation.onEnd;
                    // 버그 수정 1: 애니메이션이 끝나면 항상 transform을 리셋
                    canvas.style.transform = 'none'; 
                    gameState.animation = { type: null, duration: 0, progress: 0, onEnd: null, data: {} };
                    if (onEndCallback) onEndCallback();
                }
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawDungeonBackground(deltaTime);
            
            if (gameState.animation.type === 'dungeon-intro' || gameState.animation.type === 'grand-finale') {
                drawCharacter(true);
            } else {
                drawCharacter(false);
                if (gameState.animation.type !== 'game-over' && gameState.animation.type !== 'grand-finale') {
                    drawMonster();
                }
            }
            
            drawEffects(deltaTime);

            if (gameState.animation.type === 'game-over') {
                drawGameOverAnimation(deltaTime);
            }
        }

        // ==================================================================
        // UI 및 이벤트 리스너
        // ==================================================================
        function showQuizContainer(show) {
            const quizHeight = quizContainer.offsetHeight;
            if (show) {
                quizContainer.style.display = 'flex';
                // 퀴즈 컨테이너가 나타날 때 버튼 위치 조정
                fixedButtonsContainer.style.bottom = `${quizHeight + 15}px`;
                failsafeContainer.style.bottom = `${quizHeight + 15}px`;
            } else {
                quizContainer.style.display = 'none';
                // 퀴즈 컨테이너가 사라질 때 버튼 위치 원상복구
                fixedButtonsContainer.style.bottom = '15px';
                failsafeContainer.style.bottom = '15px';
            }
        }

        window.addEventListener('load', async () => {
            await loadAssets();
            initGame();
            resizeCanvas();
        });
        
        window.addEventListener('resize', resizeCanvas);

        document.getElementById('game-screen').addEventListener('click', (e) => {
            if (e.target.id === 'game-canvas') {
                skipCurrentEvent();
            }
        });

        document.getElementById('story-screen').addEventListener('click', () => {
            showScreen('start-screen');
        });

        document.getElementById('start-new-game-btn').addEventListener('click', () => {
            initAndPlayBGM();
            startNewGame();
        });
        document.getElementById('load-game-btn').addEventListener('click', () => {
            initAndPlayBGM();
            loadGame();
        });
        document.getElementById('save-game-btn').addEventListener('click', () => saveGame(true));
        
        document.getElementById('change-character-btn').addEventListener('click', () => {
            showScreen('character-selection-screen');
        });
        
        document.getElementById('restart-from-scratch-btn').addEventListener('click', () => {
            localStorage.removeItem('crimeQuizRPGSave');
            startNewGame();
        });

        document.getElementById('back-to-difficulty-btn').addEventListener('click', () => {
            saveGame(false);
            setupDifficultyScreen();
        });

        document.querySelectorAll('#character-selection-screen .char-card').forEach(card => {
            card.addEventListener('click', () => {
                document.querySelectorAll('#character-selection-screen .char-card').forEach(c => c.classList.remove('selected'));
                card.classList.add('selected');
            });
        });

        document.getElementById('confirm-character-btn').addEventListener('click', () => {
            const name = document.getElementById('character-name').value.trim();
            const selected = document.querySelector('#character-selection-screen .char-card.selected');
            if (!name) { showMessage("캐릭터 이름을 입력해주세요."); return; }
            if (!selected) { showMessage("캐릭터를 선택해주세요."); return; }
            
            const level = gameState.player.level || 1;
            const clearedStages = gameState.clearedStages || { '하': false, '중': false, '상': false };
            const isChallengeUnlocked = gameState.isChallengeUnlocked || false;

            gameState.player.name = name;
            gameState.player.class = selected.dataset.class;
            gameState.player.gender = selected.dataset.gender;
            gameState.player.imageKey = `${gameState.player.class}_${gameState.player.gender}`;
            gameState.player.level = level;
            gameState.clearedStages = clearedStages;
            gameState.isChallengeUnlocked = isChallengeUnlocked;
            
            setupDifficultyScreen();
        });
        
        document.getElementById('difficulty-options').addEventListener('click', (e) => {
           if (e.target.matches('.difficulty-btn') && !e.target.classList.contains('disabled')) {
               startGame(e.target.dataset.difficulty);
           }
        });
        
        ultimateSkillBtn.addEventListener('click', handleUltimateSkill);

        q1OptionsEl.addEventListener('click', (e) => {
            if (e.target.matches('.quiz-btn')) handleQ1Answer(e.target.dataset.answer);
        });

        q2OptionsEl.addEventListener('click', (e) => {
            const target = e.target.closest('.q2-btn');
            if (target) handleQ2Answer(target.dataset.answerIndex);
        });

        document.getElementById('instructions-btn').addEventListener('click', () => {
            instructionsModal.style.display = 'flex';
        });
        document.getElementById('instructions-close-btn').addEventListener('click', () => {
            instructionsModal.style.display = 'none';
        });

        const ingameCharChangeModal = document.getElementById('ingame-char-change-modal');
        document.getElementById('ingame-change-char-btn').addEventListener('click', () => {
            ingameCharChangeModal.style.display = 'flex';
        });
        document.getElementById('cancel-ingame-char-change-btn').addEventListener('click', () => {
            ingameCharChangeModal.style.display = 'none';
        });
        ingameCharChangeModal.querySelectorAll('.char-card').forEach(card => {
            card.addEventListener('click', () => {
                ingameCharChangeModal.querySelectorAll('.char-card').forEach(c => c.classList.remove('selected'));
                card.classList.add('selected');
            });
        });
        document.getElementById('confirm-ingame-char-change-btn').addEventListener('click', () => {
            const selected = ingameCharChangeModal.querySelector('.char-card.selected');
            if(selected) {
                gameState.player.class = selected.dataset.class;
                gameState.player.gender = selected.dataset.gender;
                gameState.player.imageKey = `${gameState.player.class}_${gameState.player.gender}`;
                ingameCharChangeModal.style.display = 'none';
                updateStatus();
                unlockInput();
            } else {
                showMessage("변경할 캐릭터를 선택해주세요.");
            }
        });
        
        document.getElementById('force-continue-btn').addEventListener('click', () => {
            console.warn("강제 진행 버튼 클릭됨.");
            if (gameState.animation && typeof gameState.animation.onEnd === 'function') {
                console.log("진행 중인 애니메이션의 콜백을 강제로 실행합니다.");
                clearAnimation();
            } else {
                console.log("진행할 애니메이션 콜백이 없습니다. 다음 몬스터를 준비합니다.");
                showQuizContainer(false);
                monsterInfoDisplay.style.display = 'none';
                if (gameState.lives > 0) {
                    prepareNextEncounter();
                } else {
                    startGameOverAnimation();
                }
            }
            unlockInput();
        });

    </script>
</body>
</html>
