<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>던전 법률 퀴즈 RPG</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&family=Cinzel+Decorative:wght@700&display=swap');

        :root {
            --bg-color: #2c2a4a;
            --surface-color: #4f4c7a;
            --primary-color: #9b59b6;
            --secondary-color: #8e44ad;
            --text-color: #ecf0f1;
            --accent-color: #f1c40f;
            --danger-color: #e74c3c;
            --success-color: #2ecc71;
            --font-family: 'Noto Sans KR', sans-serif;
            --title-font: 'Cinzel Decorative', cursive;
        }

        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--font-family);
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #game-container {
            width: 100%;
            height: 100%;
            max-width: 1000px;
            max-height: 800px;
            position: relative;
            background-color: #1e1c3a;
            border-radius: 15px;
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
            background: linear-gradient(135deg, var(--bg-color), #3e3b6b);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease, visibility 0.5s ease;
            text-align: center;
        }

        .screen.active {
            opacity: 1;
            visibility: visible;
        }
        
        #start-screen {
            background: radial-gradient(ellipse at center, #4a477a 0%, #2c2a4a 70%),
                        repeating-linear-gradient(-45deg, rgba(255,255,255,0.02), rgba(255,255,255,0.02) 2px, transparent 2px, transparent 6px);
        }
        #start-screen .title-container {
            border: 4px double var(--accent-color);
            padding: 20px 40px;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
        }
        #start-screen h1 {
            font-family: var(--title-font);
            font-size: 3em;
            color: var(--accent-color);
            text-shadow: 0 0 5px var(--accent-color), 0 0 15px #000, 0 0 25px #000;
            animation: title-glow 4s infinite alternate;
            margin: 0;
        }
        #start-screen p {
            font-size: 1.1em;
            color: var(--text-color);
            text-shadow: 1px 1px 2px #000;
            margin-top: 10px;
        }

        @keyframes title-glow {
            from { text-shadow: 0 0 5px var(--accent-color), 0 0 15px #000, 0 0 25px #000; }
            to { text-shadow: 0 0 15px var(--accent-color), 0 0 35px #000, 0 0 50px #000; }
        }

        h2, h3 {
            color: var(--accent-color);
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .button-group {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            background-color: var(--primary-color);
            color: var(--text-color);
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px var(--secondary-color);
            transform: translateY(0);
        }

        .btn:hover {
            background-color: #a569bd;
            transform: translateY(-2px);
            box-shadow: 0 6px var(--secondary-color);
        }

        .btn:active {
            transform: translateY(2px);
            box-shadow: 0 2px var(--secondary-color);
        }
        
        .btn.disabled {
            background-color: #7f8c8d;
            cursor: not-allowed;
            box-shadow: 0 4px #616a6b;
        }

        #character-selection-screen .char-options {
            display: flex;
            gap: 20px;
            margin: 20px 0;
        }
        .char-card {
            background-color: var(--surface-color);
            padding: 15px;
            border-radius: 10px;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.3s ease;
        }
        .char-card.selected {
            border-color: var(--accent-color);
            transform: scale(1.05);
        }
        .char-card img {
            width: 100px;
            height: 100px;
            object-fit: contain;
        }
        .char-card p {
            margin: 5px 0 0;
            font-weight: bold;
        }
        #character-name {
            padding: 10px;
            font-size: 1em;
            border-radius: 5px;
            border: 2px solid var(--primary-color);
            background-color: var(--bg-color);
            color: var(--text-color);
            margin-top: 15px;
            width: 80%;
            max-width: 300px;
            text-align: center;
        }

        #game-screen {
            justify-content: flex-start;
            padding: 0;
        }
        #status-bar {
            width: 100%;
            padding: 10px 20px;
            background-color: rgba(0,0,0,0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-sizing: border-box;
            font-size: 1.1em;
            z-index: 10;
        }
        #status-bar #player-info, #status-bar #lives-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        #game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }
        #quiz-container {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: rgba(44, 42, 74, 0.9);
            padding: 20px;
            box-sizing: border-box;
            border-top: 3px solid var(--primary-color);
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            z-index: 10;
        }
        #quiz-case {
            font-size: 1.2em;
            text-align: center;
            max-height: 120px;
            overflow-y: auto;
        }
        #q1-options, #q2-options {
            display: flex;
            justify-content: center;
            gap: 20px;
            width: 100%;
        }
        #q2-options {
            flex-direction: column;
            align-items: center;
        }
        .quiz-btn {
            width: 45%;
            max-width: 300px;
            padding: 15px;
            font-size: 1em;
        }
        .q2-btn {
             width: 90%;
             max-width: 600px;
             text-align: left;
        }
        
        #message-modal {
            position: absolute;
            top: 30%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--surface-color);
            padding: 30px;
            border-radius: 15px;
            border: 3px solid var(--accent-color);
            box-shadow: 0 0 20px rgba(0,0,0,0.7);
            z-index: 100;
            text-align: center;
            display: none;
        }
        #message-text {
            font-size: 1.5em;
            margin-bottom: 20px;
        }
        
        #monster-info-display {
            position: absolute;
            top: 60px;
            right: 20px;
            background-color: rgba(0,0,0,0.6);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 1.1em;
            text-align: right;
            z-index: 10;
            display: none;
            border-left: 3px solid var(--danger-color);
        }
        
        #temp-message-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px 40px;
            background-color: rgba(0,0,0,0.75);
            color: var(--accent-color);
            font-size: 2em;
            font-weight: bold;
            border-radius: 10px;
            z-index: 110;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        #temp-message-overlay.visible {
            opacity: 1;
            visibility: visible;
        }


        /* Responsive Design */
        @media (max-width: 600px) {
            #start-screen h1 { font-size: 2.2em; }
            .btn { padding: 10px 20px; font-size: 1em; }
            #character-selection-screen .char-options { flex-direction: column; }
            .char-card img { width: 80px; height: 80px; }
            #status-bar { font-size: 0.9em; padding: 8px 15px; }
            #monster-info-display { top: 50px; font-size: 0.9em; }
            #quiz-case { font-size: 1em; }
            .quiz-btn { width: 80%; }
            #temp-message-overlay { font-size: 1.5em; }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- 시작 화면 -->
        <div id="start-screen" class="screen active">
            <div class="title-container">
                <h1>Dungeon & Law</h1>
                <p>범죄의 성립 여부를 퀴즈로 배우는 던전 탐험!</p>
            </div>
            <div class="button-group">
                <button id="start-new-game-btn" class="btn">새 게임 시작</button>
                <button id="load-game-btn" class="btn">불러오기</button>
            </div>
        </div>

        <!-- 캐릭터 선택 화면 -->
        <div id="character-selection-screen" class="screen">
            <h2>캐릭터 선택</h2>
            <p>이름을 정하고, 당신의 분신이 될 용사를 선택하세요.</p>
            <input type="text" id="character-name" placeholder="캐릭터 이름 입력" maxlength="10">
            <div class="char-options">
                <div class="char-card" data-class="전사" data-gender="남">
                    <img src="https://raw.githubusercontent.com/dessa1995/crime/main/mw.png" alt="남자 전사">
                    <p>남자 전사</p>
                </div>
                <div class="char-card" data-class="전사" data-gender="여">
                    <img src="https://raw.githubusercontent.com/dessa1995/crime/main/fw.png" alt="여자 전사">
                    <p>여자 전사</p>
                </div>
                <div class="char-card" data-class="마법사" data-gender="남">
                    <img src="https://raw.githubusercontent.com/dessa1995/crime/main/mm.png" alt="남자 마법사">
                    <p>남자 마법사</p>
                </div>
                <div class="char-card" data-class="마법사" data-gender="여">
                    <img src="https://raw.githubusercontent.com/dessa1995/crime/main/fm.png" alt="여자 마법사">
                    <p>여자 마법사</p>
                </div>
            </div>
            <button id="confirm-character-btn" class="btn">선택 완료</button>
        </div>
        
        <!-- 난이도 선택 화면 -->
        <div id="difficulty-selection-screen" class="screen">
            <h2>난이도 선택</h2>
            <div class="button-group">
                <button class="btn difficulty-btn" data-difficulty="하">하</button>
                <button class="btn difficulty-btn" data-difficulty="중">중</button>
                <button class="btn difficulty-btn" data-difficulty="상">상</button>
            </div>
             <div class="button-group">
                 <button id="save-game-btn" class="btn">게임 저장</button>
            </div>
        </div>

        <!-- 메인 게임 화면 -->
        <div id="game-screen" class="screen">
            <div id="status-bar">
                <div id="player-info">
                    <span id="status-name"></span> | LV.<span id="status-level"></span>
                </div>
                <div id="lives-info">
                    <span>목숨:</span>
                    <span id="status-lives"></span>
                </div>
            </div>
            <div id="monster-info-display"></div>
            <div id="temp-message-overlay"></div>
            <canvas id="game-canvas"></canvas>
            <div id="quiz-container">
                <div id="quiz-case"></div>
                <div id="q1-options">
                    <button class="btn quiz-btn" data-answer="O">O (성립한다)</button>
                    <button class="btn quiz-btn" data-answer="X">X (성립하지 않는다)</button>
                </div>
                <div id="q2-options" style="display: none;">
                    <!-- 4지선다 버튼은 동적으로 생성됩니다. -->
                </div>
            </div>
        </div>
        
        <!-- 메시지 모달 -->
        <div id="message-modal">
            <p id="message-text"></p>
            <button id="message-ok-btn" class="btn">확인</button>
        </div>
        
        <!-- 오디오 태그 (CORS 문제로 재생되지 않을 수 있음) -->
        <audio id="bgm-audio" src="https://raw.githubusercontent.com/dessa1995/crime/main/bbgm.mp3" loop></audio>

    </div>

    <script>
        // 전역 변수 및 DOM 요소
        const gameContainer = document.getElementById('game-container');
        const screens = document.querySelectorAll('.screen');
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        
        const quizContainer = document.getElementById('quiz-container');
        const quizCaseEl = document.getElementById('quiz-case');
        const q1OptionsEl = document.getElementById('q1-options');
        const q2OptionsEl = document.getElementById('q2-options');

        const messageModal = document.getElementById('message-modal');
        const messageText = document.getElementById('message-text');
        const messageOkBtn = document.getElementById('message-ok-btn');
        const monsterInfoDisplay = document.getElementById('monster-info-display');
        const tempMessageOverlay = document.getElementById('temp-message-overlay');
        const bgmAudioElement = document.getElementById('bgm-audio');

        let audioContext;
        let bgmSource;
        let bgmBuffer;
        let isAudioReady = false;

        const assets = {
            bgm: 'https://raw.githubusercontent.com/dessa1995/crime/main/bbgm.mp3',
            monsters: {
                '하': 'https://raw.githubusercontent.com/dessa1995/crime/main/monster1.png',
                '중': 'https://raw.githubusercontent.com/dessa1995/crime/main/monster2.png',
                '상': 'https://raw.githubusercontent.com/dessa1995/crime/main/monster3.png',
                '보스': 'https://raw.githubusercontent.com/dessa1995/crime/main/monster4.png'
            },
            characters: {
                '전사_남': 'https://raw.githubusercontent.com/dessa1995/crime/main/mw.png',
                '전사_여': 'https://raw.githubusercontent.com/dessa1995/crime/main/fw.png',
                '마법사_남': 'https://raw.githubusercontent.com/dessa1995/crime/main/mm.png',
                '마법사_여': 'https://raw.githubusercontent.com/dessa1995/crime/main/fm.png'
            }
        };
        const loadedImages = {};

        let gameState = {};
        let dungeonPillars = [];
        let effectParticles = [];

        // 퀴즈 데이터 (이전과 동일)
        const quizzes = [
            { id: 1, difficulty: '하', case: "갑은 잃어버린 자신의 스마트폰인 줄 알고 길가에 떨어진 스마트폰을 주워갔습니다. 그러나 그 스마트폰은 을의 스마트폰이었습니다.", q1: 'X', q2: ["갑에게 절도의 고의가 없었기 때문이다.", "을에게 피해자의 승낙이 있었기 때문이다.", "갑이 14세 미만이었기 때문이다.", "갑의 행위는 사회상규에 위배되지 않기 때문이다."], answerIndex: 0 },
            { id: 2, difficulty: '하', case: "13세인 갑이 친구의 가방에서 몰래 지갑을 훔쳤습니다.", q1: 'X', q2: ["절도죄의 구성 요건에 해당하지 않기 때문이다.", "갑이 심신 상실 상태였기 때문이다.", "갑이 14세 미만의 형사 미성년자이므로 책임이 조각되기 때문이다.", "피해자의 승낙이 있었기 때문이다."], answerIndex: 2 },
            { id: 3, difficulty: '하', case: "갑은 자신에게 주먹을 휘두르려는 을의 공격을 막기 위해 을의 팔을 붙잡아 저지했습니다.", q1: 'X', q2: ["갑의 행위가 현재의 부당한 침해로부터 자신을 방위하기 위한 정당방위에 해당하여 위법성이 조각되기 때문이다.", "갑이 심신 미약 상태였기 때문이다.", "폭행죄의 구성 요건에 해당하지 않기 때문이다.", "피해자가 상해를 입지 않았기 때문이다."], answerIndex: 0 },
            { id: 4, difficulty: '하', case: "갑은 인터넷에서 불법 도박 사이트를 운영하여 많은 사람으로부터 돈을 가로챘습니다.", q1: 'O', q2: ["갑의 행위는 사회적 유해성이 없기 때문이다.", "법률에 명확하게 규정된 범죄 행위가 아니기 때문이다.", "갑의 행위가 형법에 규정된 구성 요건에 해당하고, 위법성 및 책임 조각 사유가 없으므로 범죄가 성립하기 때문이다.", "도박 행위는 형벌이 부과되지 않는 행위이기 때문이다."], answerIndex: 2 },
            { id: 5, difficulty: '하', case: "갑이 실수로 옆에 있던 친구의 스마트폰을 떨어뜨려 액정을 깨뜨렸습니다.", q1: 'X', q2: ["재물손괴죄의 구성 요건에 해당하지만 위법성이 조각되기 때문이다.", "고의가 없었지만 과실로 인한 행위는 처벌 대상이기 때문이다.", "형법은 고의범을 원칙으로 하고, 과실에 의한 재물손괴에 대한 처벌 규정이 없기 때문에 재물손괴죄가 성립하지 않는다.", "친구의 재산이므로 재물손괴죄가 성립하지 않는다."], answerIndex: 2 },
            { id: 6, difficulty: '하', case: "구조대원 갑이 화재 현장에서 불이 붙은 건물을 부수고 들어가 인명을 구조하는 과정에서 건물 일부가 파손되었습니다.", q1: 'X', q2: ["갑의 행위는 공공의 이익을 위한 행위로, 사회상규에 위배되지 않는 정당행위에 해당하여 위법성이 조각되기 때문이다.", "갑에게 재물손괴의 고의가 없었기 때문이다.", "피해자의 승낙이 있었기 때문이다.", "갑의 행위가 긴급 피난에 해당하기 때문이다."], answerIndex: 0 },
            { id: 7, difficulty: '하', case: "갑이 친구의 지갑을 훔칠 목적으로 주머니에서 지갑을 꺼내 자신의 가방에 넣었습니다.", q1: 'O', q2: ["갑의 행위가 절도죄의 구성 요건에 해당하고 위법성 및 책임이 인정되기 때문이다.", "아직 지갑을 사용하지 않았기 때문에 범죄가 성립하지 않는다.", "친구의 재산이므로 절도죄가 성립하지 않는다.", "피해자가 지갑을 돌려받았기 때문이다."], answerIndex: 0 },
            { id: 8, difficulty: '하', case: "은행원 갑은 강도가 칼로 가족을 해치겠다고 협박하여 어쩔 수 없이 금고문을 열어주었습니다.", q1: 'X', q2: ["갑의 행위는 긴급 피난에 해당하여 위법성이 조각되기 때문이다.", "갑이 강도의 협박에 의해 강요된 행위를 한 것이므로 책임이 조각되어 범죄가 성립하지 않기 때문이다.", "강도 행위는 갑이 아닌 강도의 책임이므로 범죄가 성립하지 않는다.", "금고문 개방이 은행원의 직무에 해당하기 때문이다."], answerIndex: 1 },
            { id: 9, difficulty: '하', case: "갑은 맹렬히 자신을 공격하려는 맹견을 피하기 위해 부득이하게 돌을 던져 맹견에게 상처를 입혔습니다.", q1: 'X', q2: ["갑에게 맹견을 해치려는 고의가 없었기 때문이다.", "갑의 행위는 자기의 법익에 대한 현재의 위난을 피하기 위한 긴급 피난에 해당하여 위법성이 조각되기 때문이다.", "동물은 재물이 아니므로 재물손괴죄가 성립하지 않는다.", "갑의 행위는 사회상규에 위배되지 않는 정당행위이기 때문이다."], answerIndex: 1 },
            { id: 10, difficulty: '하', case: "운전자 갑은 주차된 차를 손괴하고도 피해자에게 연락처를 제공하지 않고 도주했습니다.", q1: 'O', q2: ["도로교통법에 따라 교통사고 발생 시 필요한 조치를 하지 않은 경우 처벌하도록 규정되어 있고, 이는 실질적 의미의 형법에 해당하기 때문이다.", "갑의 행위는 형법에 규정된 구성 요건에 해당하지 않기 때문이다.", "재물손괴죄만 성립하고 다른 범죄는 성립하지 않는다.", "경미한 사고이므로 범죄로 볼 수 없다."], answerIndex: 0 },
            { id: 11, difficulty: '중', case: "만취 상태로 심신 상실에 이른 갑이 지나가던 을을 폭행하여 상해를 입혔습니다.", q1: 'X', q2: ["갑의 행위는 고의에 의한 것이 아니기 때문이다.", "갑은 심신 상실 상태였으므로 사물을 변별하거나 의사를 결정할 능력이 없어 책임이 조각되어 범죄가 성립하지 않기 때문이다.", "갑은 심신 미약 상태였으므로 책임이 감경될 뿐 범죄는 성립한다.", "피해자의 승낙이 있었기 때문이다."], answerIndex: 1 },
            { id: 12, difficulty: '중', case: "「경범죄 처벌법」에 '지나친 노출로 타인에게 부끄러운 느낌이나 불쾌감을 준 사람'을 처벌하는 조항이 있었습니다. 헌법재판소는 이 조항이 위헌이라고 결정했습니다.", q1: 'X', q2: ["이 조항이 관습 형법에 해당하기 때문이다.", "이 조항에 명시된 구성 요건의 의미가 추상적이고 불명확하여 죄형 법정주의의 명확성의 원칙에 위배되어 위헌 결정되었기 때문에 처벌할 수 없다.", "이 조항은 소급효 금지의 원칙에 위배되기 때문이다.", "이 조항은 비례성의 원칙에 어긋나기 때문이다."], answerIndex: 1 },
            { id: 13, difficulty: '중', case: "심신 미약 상태인 갑이 길을 가다 우발적으로 을을 폭행하여 상해를 입혔습니다.", q1: 'O', q2: ["갑의 심신 미약 상태로 인해 책임이 완전히 조각되기 때문이다.", "상해의 구성 요건에 해당하지 않기 때문이다.", "위법성 조각 사유에 해당하기 때문이다.", "갑이 심신 미약 상태이더라도 상해죄는 성립하며, 다만 형이 감경될 수 있기 때문이다."], answerIndex: 3 },
            { id: 14, difficulty: '중', case: "갑은 죽고 싶다는 을의 간곡한 부탁을 받고 을을 살해했습니다.", q1: 'O', q2: ["을의 승낙이 있었으므로 갑의 행위는 위법성이 조각된다.", "갑에게 살인의 고의가 없었기 때문이다.", "피해자의 승낙이 있더라도 형법 제252조에 따라 법률에 특별한 규정이 있는 경우 위법성이 조각되지 않으므로 살인죄(촉탁살인죄)가 성립하기 때문이다.", "갑의 행위는 윤리적으로 비난받을 만하지만 법적으로는 처벌되지 않는다."], answerIndex: 2 },
            { id: 15, difficulty: '중', case: "갑이 범죄를 저지른 뒤, 형벌 법규가 개정되어 갑의 행위에 대한 형벌이 이전보다 가벼워졌습니다. 재판은 개정된 법률 시행 이후에 진행되었습니다.", q1: 'X', q2: ["범죄 행위 시의 법률을 적용하는 것이 원칙이기 때문이다.", "소급효 금지의 원칙에 따라 행위 시의 법을 적용해야 하기 때문이다.", "행위자에게 유리한 경우에는 개정된 법률을 소급하여 적용하는 것이 허용되기 때문이다.", "재판 시의 법률을 적용하는 것이 법적 안정성을 해치지 않기 때문이다."], answerIndex: 2 },
            { id: 16, difficulty: '중', case: "갑이 범죄를 저지른 후, 새로 '치료 감호'라는 보안 처분에 관한 법률이 제정되었습니다. 재판부는 갑의 재범 위험성을 고려하여 치료 감호를 명령할 수 있다고 판단했습니다.", q1: 'O', q2: ["치료 감호는 형벌이 아니라 보안 처분으로서 장래의 위험성 방지를 목적으로 하므로 소급효 금지의 원칙이 적용되지 않기 때문이다.", "새로운 법률은 범죄 행위 이후에 제정되었으므로 소급하여 적용할 수 없기 때문이다.", "보안 처분은 항상 범죄자와 함께 적용되어야 하기 때문이다.", "갑이 치료 감호를 거부할 권리가 있기 때문이다."], answerIndex: 0 },
            { id: 17, difficulty: '중', case: "갑은 길을 걷다가 발에 채인 물건이 자신의 것이라고 착각하고 주머니에 넣었습니다. 알고 보니 그것은 을의 지갑이었습니다.", q1: 'X', q2: ["갑의 행위가 구성 요건에 해당하지만 위법성이 조각되기 때문이다.", "절도죄는 타인의 재물을 불법하게 취득하려는 고의(영득의 고의)를 필요로 하는데, 갑에게는 그러한 고의가 없었기 때문이다.", "갑의 과실로 인한 행위는 처벌 대상이 아니기 때문이다.", "길에 떨어진 물건은 소유자가 없으므로 절도죄가 성립하지 않는다."], answerIndex: 1 },
            { id: 18, difficulty: '중', case: "갑은 잃어버린 자신의 시계를 훔쳐간 범인이 을이라는 사실을 알고, 경찰에 신고할 시간이 없어 즉시 을의 집으로 찾아가 을을 제압하고 시계를 되찾아왔습니다. 나중에 확인 결과 을이 범인이 맞았습니다.", q1: 'X', q2: ["갑의 행위는 자신의 재산을 보호하기 위한 정당방위에 해당하기 때문이다.", "국가의 구제를 기대하기 어려운 상황에서 자신의 청구권을 보전하기 위한 자구행위에 해당하여 위법성이 조각되기 때문이다.", "갑이 폭행과 절도를 고의로 행했으므로 범죄가 성립한다.", "을이 범인이었으므로 갑의 행위는 법적으로 아무 문제가 없다."], answerIndex: 1 },
            { id: 19, difficulty: '상', case: "듣거나 말하는 데 모두 장애가 있는 농아자 갑이 고의로 을을 폭행하여 상해를 입혔습니다.", q1: 'O', q2: ["농아자의 행위는 심신상실과 유사하여 책임이 조각되기 때문이다.", "농아자의 행위는 형법상 책임 감경 사유에 해당할 뿐, 범죄는 여전히 성립하기 때문이다.", "상해의 고의가 없었기 때문이다.", "농아자는 의사소통에 어려움이 있어 자신의 행위에 대한 책임을 물을 수 없기 때문이다."], answerIndex: 1 },
            { id: 20, difficulty: '상', case: "형법상 '컴퓨터 등 사용 사기죄'는 재산상의 이익만을 객체로 규정하고 있습니다. 검사 갑은 피고인 을이 컴퓨터를 사용하여 '재물'을 편취한 사건에 대해 유사한 형법 조항을 유추 해석하여 '컴퓨터 등 사용 사기죄'로 기소하였습니다.", q1: 'X', q2: ["유추 해석은 항상 금지되므로 정당하지 않다.", "죄형 법정주의의 유추 해석 금지의 원칙은 행위자에게 불리한 유추 해석을 금지하므로, 검사의 유추 해석은 정당하지 않다.", "행위자에게 유리한 유추 해석은 허용되므로 정당하다.", "유사한 성질의 범죄에 대해서는 유추 해석이 허용되기 때문이다."], answerIndex: 1 },
            { id: 21, difficulty: '상', case: "경찰관 갑은 불법 만두소를 제조하여 납품한 업체를 직무상 알게 되어 즉시 이 사실을 언론에 공표하였습니다. 이로 인해 만두 업체의 명예와 신용이 크게 훼손되었지만, 공표 내용은 국민의 보건·위생에 중대한 영향을 미치는 공익성이 인정되었습니다 (대법원 판례).", q1: 'X', q2: ["경찰관의 직무상 행위이므로 명예훼손죄는 성립하지 않는다.", "공익성이 인정되더라도 명예훼손의 구성 요건에 해당하기 때문이다.", "국민의 보건·위생을 위한 행위로서 공익성과 진실성이 인정되어 사회상규에 위배되지 않는 정당행위에 해당하므로 위법성이 조각되기 때문이다.", "피해자의 동의가 없었으므로 명예훼손죄가 성립한다."], answerIndex: 2 },
            { id: 22, difficulty: '상', case: "갑은 을을 살해할 의도로 총을 쏘았으나, 빗나가 옆에 있던 병이 맞아 사망했습니다.", q1: 'O', q2: ["갑은 병을 살해할 의도가 없었으므로 살인죄가 성립하지 않는다.", "피해자가 의도했던 을이 아니므로 살인죄가 성립하지 않는다.", "갑에게 사람을 살해하려는 고의가 있었고, 그 고의에 의해 사망이라는 결과가 발생했으므로 객체의 착오에도 불구하고 살인죄의 구성 요건을 충족하여 살인죄가 성립한다.", "과실치사죄만 성립할 뿐 살인죄는 성립하지 않는다."], answerIndex: 2 },
            { id: 23, difficulty: '상', case: "갑과 을이 서로 싸우는 상황에서 을이 일방적으로 갑을 공격하였고, 갑은 자신을 보호하기 위해 을에게 저항하며 유형력을 행사했습니다. 갑의 저항 행위는 새로운 적극적 공격으로 평가되지 않는 수준이었습니다.", q1: 'X', q2: ["서로 싸우는 상황에서는 쌍방 폭행이므로 갑의 행위도 범죄가 성립한다.", "갑의 행위가 정당방위에 해당하지만, 그 정도를 초과했으므로 범죄가 성립한다.", "을의 일방적 공격으로부터 자신을 보호하기 위한 저항 수단으로서 사회 관념상 허용될 수 있는 상당성이 인정되어 위법성이 조각되기 때문이다.", "갑에게 폭행의 고의가 없었으므로 범죄가 성립하지 않는다."], answerIndex: 2 },
            { id: 24, difficulty: '최상', case: "제2차 세계 대전 당시 나치 독일은 '독일인의 피와 명예를 지키기 위한 법'과 '제국 시민법' 등의 뉘른베르크법을 제정하여 유대인에 대한 학살의 법적 근거로 삼았습니다. 이 법은 당시 독일의 법률 제정 절차를 준수하여 제정되었습니다.", q1: 'X', q2: ["당시 합법적인 절차에 의해 제정된 법률이므로 정당한 처벌로 볼 수 있다.", "죄형 법정주의는 '형식적 의미의 형법'만을 요구하므로 정당하다.", "법률 제정 절차를 준수한 형식적 죄형 법정주의에는 충실했지만, 그 내용이 정의롭지 못하고 인간의 존엄과 가치를 침해하는 '실질적 죄형 법정주의'에 반하므로 정당한 처벌로 볼 수 없다.", "뉘른베르크법은 소급효 금지의 원칙에 위배되므로 정당하지 않다."], answerIndex: 2 },
            { id: 25, difficulty: '최상', case: "'청소년 보호법'상 청소년에게 유해한 약물을 판매한 종업원 갑은 처벌되었습니다. 그런데 '양벌규정'에 따라 갑이 일하는 법인(회사) 을도 함께 벌금형을 선고받게 되었습니다. 법인 을은 종업원 관리에 최선을 다했다고 주장했습니다.", q1: 'X', q2: ["법인은 자연인이 아니므로 범죄 능력이 없어 처벌받지 않는다.", "법인은 종업원 관리에 최선을 다했다고 주장하더라도 책임이 조각되어 처벌받지 않는다.", "양벌규정은 종업원의 범죄 행위에 대해 법인 자체에게도 벌금형 등 형사 처벌을 과하도록 규정하며, 법인의 선임 및 감독상의 주의 의무 위반이 인정되면 책임주의 원칙에 따라 처벌되므로 처벌받는다.", "오직 종업원 갑만이 범죄를 저질렀으므로 법인은 처벌받을 수 없다."], answerIndex: 2 }
        ];

        // 게임 초기화 함수
        function initGame() {
            resetGameState();
            showScreen('start-screen');
        }

        function resetGameState() {
             gameState = {
                player: { name: '', class: '', gender: '', level: 1, imageKey: '' },
                difficulty: null, lives: 5, monstersDefeated: 0,
                currentMonster: null, currentQuiz: null, usedQuizIds: [],
                clearedStages: { '하': false, '중': false, '상': false },
                isBossFight: false, bossStage: 0,
                currentScreen: 'start-screen',
                animation: { type: null, progress: 0, duration: 0 }
            };
        }

        // 화면 전환
        function showScreen(screenId) {
            screens.forEach(screen => screen.classList.remove('active'));
            document.getElementById(screenId).classList.add('active');
            gameState.currentScreen = screenId;
        }

        // 에셋 로딩
        async function loadAssets() {
            const imagePromises = Object.values(assets.characters).concat(Object.values(assets.monsters)).map(src => {
                return new Promise(resolve => {
                    const img = new Image();
                    img.src = src;
                    img.onload = () => {
                        const key = Object.keys(assets.characters).find(k => assets.characters[k] === src) ||
                                    Object.keys(assets.monsters).find(k => assets.monsters[k] === src);
                        if (key) loadedImages[key] = img;
                        resolve();
                    };
                    img.onerror = () => {
                        console.error(`이미지 로딩 실패: ${src}`);
                        resolve();
                    }
                });
            });
            await Promise.all(imagePromises);
        }
        
        function initAndPlayBGM() {
            if (bgmAudioElement.paused) {
                const playPromise = bgmAudioElement.play();
                if (playPromise !== undefined) {
                    playPromise.catch(error => {
                        console.error("오디오 자동재생 실패. 사용자 상호작용이 필요합니다.", error);
                        // Web Audio API로 재시도 (이것도 실패할 수 있음)
                        initAndPlayBGMWithWebAudio();
                    });
                }
            }
        }
        
        async function initAndPlayBGMWithWebAudio() {
            if (isAudioReady) return;
            try {
                window.AudioContext = window.AudioContext || window.webkitAudioContext;
                audioContext = new AudioContext();
                if (audioContext.state === 'suspended') await audioContext.resume();
                const response = await fetch(assets.bgm);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const arrayBuffer = await response.arrayBuffer();
                bgmBuffer = await audioContext.decodeAudioData(arrayBuffer);
                isAudioReady = true;
                
                const source = audioContext.createBufferSource();
                source.buffer = bgmBuffer;
                source.loop = true;
                source.connect(audioContext.destination);
                source.start(0);
                bgmSource = source;
            } catch (e) {
                console.error("Web Audio API를 통한 오디오 초기화/재생 오류:", e);
            }
        }

        // 게임 로직
        function startNewGame() {
            resetGameState();
            showScreen('character-selection-screen');
        }

        function setupDifficultyScreen() {
            document.querySelectorAll('.difficulty-btn').forEach(btn => {
                const diff = btn.dataset.difficulty;
                btn.classList.toggle('disabled', (diff === '중' && !gameState.clearedStages['하']) || (diff === '상' && !gameState.clearedStages['중']));
            });
            showScreen('difficulty-selection-screen');
        }

        function startGame(difficulty) {
            gameState.difficulty = difficulty;
            gameState.lives = 5;
            gameState.monstersDefeated = 0;
            gameState.usedQuizIds = [];
            gameState.isBossFight = false;
            monsterInfoDisplay.style.display = 'none';
            updateStatus();
            startDungeonAnimation(true);
        }

        function startDungeonAnimation(showInitialMessage = false) {
            showScreen('game-screen');
            dungeonPillars = [];
            for (let i = 0; i < 5; i++) {
                dungeonPillars.push({
                    x: canvas.width + i * (canvas.width / 4),
                    y: canvas.height * 0.2,
                    width: 30,
                    height: canvas.height * 0.4
                });
            }
            gameState.animation = { type: 'dungeon-intro', progress: 0, duration: 2000 };
            gameLoop();
            
            setTimeout(() => {
                if (gameState.animation.type === 'dungeon-intro') {
                    gameState.animation.type = null;
                    if (showInitialMessage) {
                        showTemporaryMessage("몬스터가 등장했습니다.", 1000, spawnMonster);
                    } else {
                        spawnMonster();
                    }
                }
            }, 2000);
        }
        
        canvas.addEventListener('click', () => {
            if (gameState.animation.type === 'dungeon-intro') {
                gameState.animation.type = null;
                 showTemporaryMessage("몬스터가 등장했습니다.", 1000, spawnMonster);
            }
        });

        function spawnMonster() {
            const difficulty = gameState.difficulty;
            let monsterType;

            if (gameState.isBossFight) {
                monsterType = '보스';
            } else {
                 const rand = Math.random() * 100;
                if (difficulty === '하') monsterType = rand < 60 ? '하' : (rand < 85 ? '중' : '상');
                else if (difficulty === '중') monsterType = rand < 50 ? '하' : (rand < 80 ? '중' : '상');
                else monsterType = rand < 40 ? '하' : (rand < 70 ? '중' : '상');
            }
            
            gameState.currentMonster = { type: monsterType, imageKey: monsterType };
            startQuiz();
        }

        function startQuiz() {
            let quizDifficulty = gameState.isBossFight ? (gameState.difficulty === '하' ? '상' : '최상') : gameState.currentMonster.type;

            monsterInfoDisplay.innerHTML = `몬스터 등급: ${gameState.currentMonster.type}<br>문제 난이도: ${quizDifficulty}`;
            monsterInfoDisplay.style.display = 'block';

            const availableQuizzes = quizzes.filter(q => q.difficulty === quizDifficulty && !gameState.usedQuizIds.includes(q.id));

            if (availableQuizzes.length === 0) {
                showMessage("모든 문제를 정복했습니다!", prepareNextEncounter);
                return;
            }

            gameState.currentQuiz = availableQuizzes[Math.floor(Math.random() * availableQuizzes.length)];
            gameState.usedQuizIds.push(gameState.currentQuiz.id);
            
            displayQuiz();
        }

        function displayQuiz() {
            quizCaseEl.textContent = `[사례] ${gameState.currentQuiz.case}\n\nQ1: 이 행위는 범죄가 성립하는가?`;
            q1OptionsEl.style.display = 'flex';
            q2OptionsEl.style.display = 'none';
            q2OptionsEl.innerHTML = '';
            quizContainer.style.display = 'flex';
        }

        function handleQ1Answer(answer) {
            if (answer === gameState.currentQuiz.q1) {
                quizCaseEl.textContent = `Q2: 그 이유는 무엇인가?`;
                q1OptionsEl.style.display = 'none';
                
                gameState.currentQuiz.q2.forEach((option, index) => {
                    const btn = document.createElement('button');
                    btn.classList.add('btn', 'quiz-btn', 'q2-btn');
                    btn.textContent = `${index + 1}. ${option}`;
                    btn.dataset.answerIndex = index;
                    q2OptionsEl.appendChild(btn);
                });
                q2OptionsEl.style.display = 'flex';
            } else {
                handleIncorrectAnswer();
            }
        }

        function handleQ2Answer(index) {
            if (index == gameState.currentQuiz.answerIndex) handleCorrectAnswer();
            else handleIncorrectAnswer();
        }

        function handleCorrectAnswer() {
            quizContainer.style.display = 'none';
            monsterInfoDisplay.style.display = 'none';
            gameState.animation = { type: 'attack', progress: 0, duration: 1000 };
            effectParticles = [];

            if (gameState.isBossFight) {
                if (gameState.difficulty === '상' && gameState.bossStage === 0) {
                    gameState.bossStage = 1;
                    showMessage("여기서 쓰러질 수 없지!", startQuiz);
                } else {
                    handleStageClear();
                }
            } else {
                showMessage("몬스터를 물리쳤다!", prepareNextEncounter);
            }
        }
        
        function handleIncorrectAnswer() {
            quizContainer.style.display = 'none';
            monsterInfoDisplay.style.display = 'none';
            gameState.animation = { type: 'damage', progress: 0, duration: 1000 };
            gameState.lives--;
            updateStatus();

            if (gameState.lives <= 0) {
                gameState.animation = { type: 'game-over', progress: 0, duration: 2500 };
                setTimeout(() => {
                    showMessage("GAME OVER", () => showScreen('start-screen'));
                }, 2500);
            } else {
                showMessage("오답입니다! 다시 집중하세요.", startDungeonAnimation);
            }
        }
        
        function prepareNextEncounter() {
            gameState.monstersDefeated++;
            if (Math.random() < 0.3) gameState.lives = Math.min(5, gameState.lives + 1);
            updateStatus();

            const diff = gameState.difficulty;
            const defeated = gameState.monstersDefeated;
            let bossConditionMet = (diff === '하' && defeated >= 5) || (diff === '중' && defeated >= 8) || (diff === '상' && defeated >= 10);
            
            if (bossConditionMet) {
                gameState.isBossFight = true;
                gameState.bossStage = 0;
                showTemporaryMessage("보스가 등장했다!", 1000, spawnMonster);
            } else {
                startDungeonAnimation();
            }
        }
        
        function handleStageClear() {
            gameState.clearedStages[gameState.difficulty] = true;
            gameState.player.level++;
            gameState.animation = { type: 'game-clear', progress: 0, duration: 3000 };
            effectParticles = [];
            for (let i = 0; i < 100; i++) {
                effectParticles.push({
                    type: 'confetti',
                    x: Math.random() * canvas.width,
                    y: Math.random() * -canvas.height,
                    vx: Math.random() * 4 - 2,
                    vy: Math.random() * 5 + 2,
                    size: Math.random() * 8 + 4,
                    color: `hsl(${Math.random() * 360}, 100%, 70%)`
                });
            }
            
            setTimeout(() => {
                saveGame();
                showMessage(`난이도 '${gameState.difficulty}' 클리어! 레벨 업! (현재 LV.${gameState.player.level})`, setupDifficultyScreen);
            }, 3000);
        }

        function updateStatus() {
            document.getElementById('status-name').textContent = gameState.player.name;
            document.getElementById('status-level').textContent = gameState.player.level;
            document.getElementById('status-lives').textContent = '❤️'.repeat(gameState.lives);
        }
        
        function showMessage(text, callback) {
            messageText.textContent = text;
            messageModal.style.display = 'block';
            messageOkBtn.onclick = () => {
                messageModal.style.display = 'none';
                if (callback) callback();
            };
        }
        
        function showTemporaryMessage(text, duration, callback) {
            tempMessageOverlay.textContent = text;
            tempMessageOverlay.classList.add('visible');
            setTimeout(() => {
                tempMessageOverlay.classList.remove('visible');
                if (callback) callback();
            }, duration);
        }

        function saveGame() {
            localStorage.setItem('crimeQuizRPGSave', JSON.stringify({
                player: gameState.player,
                clearedStages: gameState.clearedStages
            }));
        }

        function loadGame() {
            const saveData = localStorage.getItem('crimeQuizRPGSave');
            if (saveData) {
                const parsedData = JSON.parse(saveData);
                gameState.player = parsedData.player;
                gameState.clearedStages = parsedData.clearedStages;
                showMessage(`'${gameState.player.name}'님의 데이터를 불러왔습니다.`, setupDifficultyScreen);
            } else {
                showMessage("저장된 게임이 없습니다.");
            }
        }

        function resizeCanvas() {
            const container = document.getElementById('game-screen');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }

        function drawDungeonBackground() {
            ctx.fillStyle = '#3d3a5e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#5e5a80';
            ctx.fillRect(0, canvas.height * 0.6, canvas.width, canvas.height * 0.4);
            ctx.strokeStyle = '#33304a';
            ctx.lineWidth = 2;
            for(let y = 0; y < canvas.height * 0.6; y += 40) {
                for(let x = (y/40 % 2) * -20; x < canvas.width; x += 40) {
                    ctx.strokeRect(x, y, 40, 40);
                }
            }
        }

        function drawCharacter(bobbing) {
            const img = loadedImages[gameState.player.imageKey];
            if (!img) return;

            const size = Math.min(canvas.width, canvas.height) * 0.25;
            let yOffset = bobbing ? Math.sin(Date.now() / 200) * 5 : 0;
            const xPos = canvas.width * 0.2;
            
            if (gameState.animation.type === 'game-clear') {
                yOffset += Math.abs(Math.sin(Date.now() / 150) * -15);
            } else if (gameState.animation.type === 'game-over') {
                ctx.save();
                ctx.translate(xPos + size / 2, canvas.height * 0.6 - size / 2 + yOffset);
                ctx.rotate(Math.sin(Date.now() / 500) * 0.1);
                ctx.drawImage(img, -size / 2, -size / 2, size, size);
                ctx.restore();
                return;
            }
            
            ctx.drawImage(img, xPos, canvas.height * 0.6 - size + yOffset, size, size);
        }

        function drawMonster() {
            if (gameState.currentMonster) {
                const img = loadedImages[gameState.currentMonster.imageKey];
                if (img) {
                    const size = Math.min(canvas.width, canvas.height) * 0.3;
                    let x = canvas.width * 0.8 - size;
                    let y = canvas.height * 0.6 - size;
                    if (gameState.animation.type === 'damage') {
                        const progress = gameState.animation.progress / gameState.animation.duration;
                        x += Math.sin(progress * Math.PI * 10) * 10;
                    }
                    ctx.drawImage(img, x, y, size, size);
                } else {
                    ctx.fillStyle = 'red';
                    ctx.font = "bold 16px 'Noto Sans KR', sans-serif";
                    ctx.textAlign = 'center';
                    ctx.fillText(`${gameState.currentMonster.type}급 몬스터\n이미지 로딩 실패`, canvas.width * 0.8 - (Math.min(canvas.width, canvas.height) * 0.15), canvas.height * 0.4);
                }
            }
        }

        function drawEffects(deltaTime) {
            if (gameState.animation.type === 'attack') {
                const progress = gameState.animation.progress / gameState.animation.duration;
                const level = gameState.player.level;
                const startX = canvas.width * 0.25;
                const startY = canvas.height * 0.45;
                const endX = canvas.width * 0.7;
                const endY = canvas.height * 0.45;

                if (gameState.player.class === '전사') {
                    ctx.save();
                    ctx.strokeStyle = `rgba(255, 255, 255, ${1 - progress})`;
                    ctx.lineWidth = 5 + level * 2;
                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.quadraticCurveTo(
                        startX + (endX - startX) * progress,
                        startY - 100 * Math.sin(progress * Math.PI),
                        startX + (endX - startX) * progress * 1.2,
                        startY
                    );
                    ctx.stroke();
                    if (level > 2) {
                         ctx.strokeStyle = `rgba(255, 223, 0, ${0.7 - progress})`;
                         ctx.lineWidth = 3 + level;
                         ctx.beginPath();
                         ctx.moveTo(startX, startY + 20);
                         ctx.quadraticCurveTo(
                            startX + (endX - startX) * progress,
                            startY + 20 - 80 * Math.sin(progress * Math.PI),
                            startX + (endX - startX) * progress * 1.1,
                            startY + 20
                         );
                         ctx.stroke();
                    }
                    ctx.restore();
                } else if (gameState.player.class === '마법사') {
                    if (effectParticles.length === 0) {
                        for (let i = 0; i < 5 + level * 3; i++) {
                            effectParticles.push({
                                type: 'ice',
                                x: startX,
                                y: startY,
                                vx: (endX - startX) / (500 + Math.random() * 200),
                                vy: (Math.random() - 0.5) * 2,
                                size: 8 + level,
                                rotation: Math.random() * Math.PI * 2,
                                life: 1
                            });
                        }
                    }
                }
            } else if (gameState.animation.type === 'dungeon-intro') {
                ctx.fillStyle = '#2a2845';
                dungeonPillars.forEach(pillar => {
                    ctx.fillRect(pillar.x, pillar.y, pillar.width, pillar.height);
                    pillar.x -= (canvas.width / 1.5) * (deltaTime / 1000);
                });
            } else if (gameState.animation.type === 'game-over') {
                const progress = gameState.animation.progress / gameState.animation.duration;
                ctx.fillStyle = `rgba(0, 0, 0, ${progress * 0.7})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.globalCompositeOperation = 'saturation';
                ctx.fillStyle = 'black';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.globalCompositeOperation = 'source-over';
            }
            
            // 파티클 업데이트 및 그리기
            effectParticles.forEach((p, index) => {
                p.x += p.vx * (deltaTime / 16);
                p.y += p.vy * (deltaTime / 16);
                p.life -= 0.02;

                if (p.life <= 0) {
                    effectParticles.splice(index, 1);
                    return;
                }

                ctx.save();
                ctx.globalAlpha = p.life > 0 ? p.life : 0;
                ctx.translate(p.x, p.y);
                
                if (p.type === 'ice') {
                    ctx.rotate(p.rotation);
                    ctx.fillStyle = `rgba(173, 216, 230, ${p.life})`;
                    ctx.strokeStyle = `rgba(255, 255, 255, ${p.life})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        let angle = (i / 5) * Math.PI * 2;
                        ctx.lineTo(Math.cos(angle) * p.size, Math.sin(angle) * p.size);
                        angle += (0.5 / 5) * Math.PI * 2;
                        ctx.lineTo(Math.cos(angle) * p.size * 0.5, Math.sin(angle) * p.size * 0.5);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                } else if (p.type === 'confetti') {
                    ctx.fillStyle = p.color;
                    ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
                }

                ctx.restore();
            });
        }

        let lastTime = 0;
        function gameLoop(timestamp) {
            if (gameState.currentScreen !== 'game-screen') return;

            const deltaTime = (timestamp - lastTime) || 0;
            lastTime = timestamp;

            if (gameState.animation.type) {
                gameState.animation.progress += deltaTime;
                if (gameState.animation.progress >= gameState.animation.duration) {
                    gameState.animation.type = null;
                }
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawDungeonBackground();
            
            if (gameState.animation.type === 'dungeon-intro') {
                drawCharacter(true);
            } else {
                drawCharacter(false);
                drawMonster();
            }
            
            drawEffects(deltaTime);

            requestAnimationFrame(gameLoop);
        }

        // 이벤트 리스너 설정
        window.addEventListener('load', async () => {
            await loadAssets();
            initGame();
        });
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        document.getElementById('start-new-game-btn').addEventListener('click', () => {
            initAndPlayBGM();
            startNewGame();
        });
        document.getElementById('load-game-btn').addEventListener('click', () => {
            initAndPlayBGM();
            loadGame();
        });
        document.getElementById('save-game-btn').addEventListener('click', saveGame);

        document.querySelectorAll('.char-card').forEach(card => {
            card.addEventListener('click', () => {
                document.querySelectorAll('.char-card').forEach(c => c.classList.remove('selected'));
                card.classList.add('selected');
            });
        });

        document.getElementById('confirm-character-btn').addEventListener('click', () => {
            const name = document.getElementById('character-name').value.trim();
            const selected = document.querySelector('.char-card.selected');
            if (!name) { showMessage("캐릭터 이름을 입력해주세요."); return; }
            if (!selected) { showMessage("캐릭터를 선택해주세요."); return; }
            
            gameState.player.name = name;
            gameState.player.class = selected.dataset.class;
            gameState.player.gender = selected.dataset.gender;
            gameState.player.imageKey = `${gameState.player.class}_${gameState.player.gender}`;
            
            setupDifficultyScreen();
        });
        
        document.querySelectorAll('.difficulty-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                if (!btn.classList.contains('disabled')) startGame(btn.dataset.difficulty);
            });
        });

        q1OptionsEl.addEventListener('click', (e) => {
            if (e.target.matches('.quiz-btn')) handleQ1Answer(e.target.dataset.answer);
        });

        q2OptionsEl.addEventListener('click', (e) => {
            const target = e.target.closest('.q2-btn');
            if (target) handleQ2Answer(target.dataset.answerIndex);
        });

    </script>
</body>
</html>
